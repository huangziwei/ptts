<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>pTTS player</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Fraunces:opsz,wght@9..144,600&family=Source+Serif+4:wght@400;600&family=Work+Sans:wght@400;600&display=swap");

      :root {
        --bg: #f6f1ea;
        --panel: #fffaf2;
        --panel-2: #f1e8dc;
        --ink: #2c2620;
        --muted: #7b7066;
        --accent: #1d7f6e;
        --accent-2: #e07a5f;
        --highlight: #fff0c2;
        --shadow: 0 12px 30px rgba(32, 28, 24, 0.15);
        --radius: 16px;
        --cover-thumb-height: 70px;
        --ui: "Work Sans", "Segoe UI", sans-serif;
        --read: "Source Serif 4", Georgia, serif;
        --title: "Fraunces", "Times New Roman", serif;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: var(--ui);
        color: var(--ink);
        background: linear-gradient(130deg, #f6f1ea 0%, #f2e8da 40%, #e9f2ef 100%);
      }

      .app {
        display: grid;
        grid-template-columns: 280px 1fr;
        min-height: 100vh;
      }

      .library {
        padding: 24px 20px;
        background: rgba(255, 250, 242, 0.9);
        border-right: 1px solid #eadfd2;
        position: sticky;
        top: 0;
        height: 100vh;
        overflow-y: auto;
        padding-bottom: 140px;
        animation: fade-up 0.6s ease;
      }

      .brand {
        font-family: var(--title);
        font-size: 22px;
        letter-spacing: 0.5px;
        margin-bottom: 8px;
      }

      .root-path {
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 16px;
      }

      .upload-panel {
        display: grid;
        gap: 8px;
        margin-bottom: 16px;
      }

      .upload-zone {
        border: 1px dashed #d8caba;
        border-radius: 14px;
        padding: 12px;
        text-align: center;
        background: #fffdf9;
        cursor: pointer;
        transition: border 0.2s ease, background 0.2s ease;
        min-height: var(--cover-thumb-height);
        display: flex;
        flex-direction: column;
        justify-content: center;
      }

      .upload-zone strong {
        display: block;
        font-size: 12px;
        font-weight: 600;
      }

      .upload-zone span {
        display: block;
        font-size: 11px;
        color: var(--muted);
        margin-top: 2px;
      }

      .upload-zone.dragover {
        border-color: var(--accent);
        background: #f0faf7;
      }

      .upload-zone.disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .upload-status {
        font-size: 11px;
        color: var(--muted);
        min-height: 14px;
      }

      .upload-status[data-tone="error"] {
        color: #b04838;
      }

      .book-list {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .book-card {
        display: grid;
        grid-template-columns: 52px 1fr;
        gap: 12px;
        padding: 10px;
        border-radius: 14px;
        border: 1px solid #eadfd2;
        background: #fffdf9;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease, border 0.2s ease;
      }

      .book-card:hover {
        transform: translateY(-2px);
        box-shadow: var(--shadow);
      }

      .book-card.active {
        border-color: var(--accent);
        box-shadow: 0 10px 24px rgba(29, 127, 110, 0.18);
      }

      .book-cover {
        width: 52px;
        height: var(--cover-thumb-height);
        border-radius: 10px;
        background: linear-gradient(150deg, #f2cc8f, #e07a5f);
        overflow: hidden;
      }

      .book-cover img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .book-meta h4 {
        margin: 0 0 4px;
        font-size: 14px;
        font-weight: 600;
      }

      .book-meta p {
        margin: 0;
        font-size: 12px;
        color: var(--muted);
      }

      .reader {
        padding: 28px 18px 120px;
        animation: fade-up 0.6s ease;
      }

      .reader-header {
        display: flex;
        gap: 20px;
        align-items: center;
        margin-bottom: 24px;
      }

      .tts-panel {
        background: var(--panel);
        border-radius: var(--radius);
        padding: 16px 18px;
        border: 1px solid #eadfd2;
        margin-bottom: 24px;
        box-shadow: var(--shadow);
      }

      .tts-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      .tts-toggle {
        border: 1px solid #d8caba;
        background: #fff;
        color: var(--ink);
        padding: 6px 12px;
        border-radius: 999px;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
      }

      .tts-panel.collapsed .tts-grid,
      .tts-panel.collapsed .tts-actions {
        display: none;
      }

      .tts-panel h3 {
        margin-bottom: 6px; 
        font-size: 13px;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: var(--muted);
      }

      .tts-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 12px;
        margin-bottom: 12px;
      }

      .tts-field label {
        display: block;
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 4px;
      }

      .tts-field input,
      .tts-field select {
        width: 100%;
        padding: 8px 10px;
        border-radius: 10px;
        border: 1px solid #d8caba;
        font-family: var(--ui);
      }

      .voice-groups {
        display: grid;
        gap: 10px;
      }

      .voice-group-title {
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.6px;
        color: var(--muted);
        margin-bottom: 6px;
      }

      .voice-buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .voice-button {
        border: 1px solid #d8caba;
        background: #fff;
        color: var(--ink);
        padding: 6px 12px;
        border-radius: 999px;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
      }

      .voice-button.active {
        background: var(--accent);
        border-color: var(--accent);
        color: #fff;
      }

      .voice-button:focus-visible {
        outline: 2px solid var(--accent-2);
        outline-offset: 2px;
      }

      .voice-empty {
        font-size: 12px;
        color: var(--muted);
      }

      .tts-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        align-items: center;
        margin-bottom: 12px;
      }

      .tts-actions label {
        font-size: 13px;
        color: var(--muted);
        display: flex;
        gap: 6px;
        align-items: center;
      }

      .progress-track {
        width: 100%;
        height: 10px;
        background: #efe5d8;
        border-radius: 999px;
        overflow: hidden;
      }

      .progress-fill {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, var(--accent), var(--accent-2));
        transition: width 0.3s ease;
      }

      .progress-text {
        margin-top: 8px;
        font-size: 13px;
        color: var(--muted);
      }

      .progress-detail {
        margin-top: 4px;
        font-size: 12px;
        color: #8a7a6e;
      }

      .merge-status {
        margin-top: 6px;
        font-size: 12px;
        color: var(--muted);
      }

      .cover-large {
        width: 120px;
        height: 160px;
        border-radius: 16px;
        background: linear-gradient(160deg, #f2cc8f, #e07a5f);
        overflow: hidden;
        box-shadow: var(--shadow);
      }

      .cover-large img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .book-title {
        font-family: var(--title);
        font-size: 30px;
        margin: 0 0 8px;
      }

      .book-subtitle {
        margin: 0 0 4px;
        color: var(--muted);
        font-size: 14px;
      }

      .book-actions {
        margin-top: 10px;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .book-menu {
        position: relative;
      }

      .menu-panel {
        position: absolute;
        top: 42px;
        right: 0;
        background: #fffdf9;
        border: 1px solid #eadfd2;
        border-radius: 12px;
        box-shadow: 0 12px 24px rgba(30, 25, 20, 0.18);
        padding: 8px;
        display: none;
        min-width: 160px;
        z-index: 10;
      }

      .menu-panel.open {
        display: block;
      }

      .menu-panel button {
        width: 100%;
        text-align: left;
      }

      .reader-body {
        display: grid;
        grid-template-columns: 230px 1fr;
        gap: 24px;
        align-items: start;
      }

      .toc {
        background: var(--panel);
        border-radius: var(--radius);
        padding: 14px;
        border: 1px solid #eadfd2;
        max-height: calc(100vh - 320px);
        overflow-y: auto;
      }

      .toc-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 10px;
      }

      .toc h3 {
        font-size: 13px;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: var(--muted);
        margin: 0;
      }

      .toc-item {
        padding: 8px 10px;
        border-radius: 10px;
        margin-bottom: 6px;
        cursor: pointer;
        transition: background 0.2s ease;
      }

      .toc-item.active {
        background: #f2e2c7;
        color: #3a2e22;
      }

      .toc-item small {
        display: block;
        color: var(--muted);
        font-size: 11px;
      }

      .text-pane {
        background: rgba(255, 255, 255, 0.9);
        border-radius: 22px;
        padding: 22px;
        box-shadow: var(--shadow);
        min-height: 300px;
      }

      .chapter-title {
        font-family: var(--title);
        font-size: 22px;
        margin: 0 0 14px;
      }

      .chapter-text {
        font-family: var(--read);
        font-size: 18px;
        line-height: 1.7;
        white-space: pre-line;
      }

      .chapter-text p {
        margin: 0 0 16px;
      }

      .panel {
        background: #fffdf9;
        border: 1px solid #eadfd2;
        border-radius: 12px;
        padding: 12px;
      }

      .chunk {
        padding: 2px 1px;
        border-radius: 6px;
        transition: background 0.2s ease, color 0.2s ease;
      }

      .chunk.last-played {
        background: #fff4d6;
      }

      .chunk.active {
        background: var(--highlight);
      }

      .chunk.waiting {
        background: #fde2cf;
      }

      .chunk.played {
        color: #897d72;
      }

      .empty-state {
        color: var(--muted);
        font-size: 15px;
      }

      .edit-panel {
        margin-top: 24px;
        background: var(--panel);
        border-radius: var(--radius);
        border: 1px solid #eadfd2;
        padding: 18px;
        display: none;
      }

      .edit-panel.open {
        display: block;
      }

      .edit-header {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 16px;
      }

      .edit-header h3 {
        margin: 0;
        font-size: 13px;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: var(--muted);
      }

      .edit-meta {
        margin: 6px 0 0;
        font-size: 12px;
        color: var(--muted);
      }

      .edit-actions {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
      }

      .edit-status {
        font-size: 12px;
        color: var(--muted);
      }

      .edit-grid {
        display: grid;
        grid-template-columns: 240px 1fr;
        gap: 16px;
      }

      .edit-sidebar,
      .edit-main {
        display: flex;
        flex-direction: column;
        gap: 14px;
      }

      .edit-section-title {
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.8px;
        color: var(--muted);
        margin-bottom: 8px;
      }

      .edit-chapter-list,
      .edit-dropped-list {
        display: flex;
        flex-direction: column;
        gap: 6px;
        max-height: 280px;
        overflow-y: auto;
      }

      .edit-chapter-item,
      .edit-dropped-item {
        border: 1px solid #eadfd2;
        background: #fffdf9;
        color: var(--ink);
        padding: 6px 8px;
        border-radius: 8px;
        font-size: 12px;
        cursor: pointer;
        text-align: left;
      }

      .edit-chapter-item.active {
        background: #f2e2c7;
      }

      .edit-dropped-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
      }

      .edit-selected {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      .edit-selected-title {
        font-weight: 600;
        font-size: 13px;
      }

      .edit-split {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 16px;
      }

      .edit-block h4 {
        margin: 0;
        font-size: 13px;
        color: var(--muted);
      }

      .edit-block-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        margin-bottom: 8px;
      }

      .edit-block pre {
        margin: 0;
        white-space: pre-wrap;
        line-height: 1.5;
        font-size: 13px;
      }

      .edit-clean-textarea {
        width: 100%;
        min-height: 220px;
        border: 1px solid #eadfd2;
        border-radius: 8px;
        padding: 8px;
        font-family: var(--read);
        font-size: 13px;
        line-height: 1.5;
        color: var(--ink);
      }

      .edit-clean-actions {
        display: flex;
        gap: 8px;
        justify-content: flex-end;
        margin-top: 8px;
      }

      .edit-panel mark {
        background: #ffe4a8;
        padding: 0 2px;
        border-radius: 3px;
      }

      .edit-rules label {
        display: block;
        font-size: 12px;
        color: var(--muted);
        margin: 10px 0 4px;
      }

      .edit-rules textarea {
        width: 100%;
        min-height: 80px;
        border: 1px solid #eadfd2;
        border-radius: 8px;
        padding: 8px;
        font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
        font-size: 12px;
        color: var(--ink);
      }

      .edit-rules input[type="checkbox"] {
        margin-right: 6px;
      }

      .player-bar {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: #fffdf9;
        border-top: 1px solid #eadfd2;
        box-shadow: 0 -8px 20px rgba(30, 25, 20, 0.12);
        padding: 12px 20px;
        display: flex;
        align-items: center;
        gap: 16px;
        flex-wrap: wrap;
      }

      .player-controls {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .jump-btn {
        position: absolute;
        right: 14px;
        bottom: 14px;
        border: 1px solid rgba(123, 112, 102, 0.6);
        background: rgba(123, 112, 102, 0.75);
        color: #fff;
        width: 44px;
        height: 44px;
        border-radius: 50%;
        font-size: 18px;
        font-weight: 700;
        cursor: pointer;
        box-shadow: 0 8px 18px rgba(32, 28, 24, 0.2);
        display: none;
        z-index: 10;
      }

      .jump-btn:hover {
        background: rgba(123, 112, 102, 0.9);
      }

      .player-left,
      .player-right {
        display: flex;
        align-items: center;
        gap: 16px;
        flex: 1;
        min-width: 0;
      }

      .player-left {
        justify-content: flex-start;
      }

      .player-right {
        justify-content: flex-end;
      }

      .btn {
        border: 1px solid #d8caba;
        background: #fff;
        color: var(--ink);
        padding: 8px 14px;
        border-radius: 999px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s ease, background 0.2s ease;
      }

      .btn.circle {
        width: 36px;
        height: 36px;
        padding: 0;
        border-radius: 50%;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
      }

      .btn.primary {
        background: var(--accent);
        border-color: var(--accent);
        color: #fff;
      }

      .btn.danger {
        background: #b04838;
        border-color: #b04838;
        color: #fff;
      }

      .btn:active {
        transform: scale(0.98);
      }

      .status {
        color: var(--muted);
        font-size: 13px;
      }

      .marks {
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
        font-size: 12px;
        color: var(--muted);
        position: relative;
      }

      .bookmark-panel {
        position: absolute;
        bottom: 52px;
        left: 0;
        width: 280px;
        background: #fffdf9;
        border: 1px solid #eadfd2;
        border-radius: 16px;
        box-shadow: 0 16px 30px rgba(30, 25, 20, 0.18);
        padding: 12px;
        display: none;
        z-index: 20;
      }

      .bookmark-panel.open {
        display: block;
      }

      .bookmark-title {
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 8px;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .bookmark-list {
        max-height: 220px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-bottom: 12px;
      }

      .bookmark-item {
        background: #f7efe3;
        border-radius: 12px;
        padding: 8px 10px;
        display: grid;
        gap: 8px;
      }

      .bookmark-item span {
        font-size: 12px;
        color: #50463f;
      }

      .bookmark-actions {
        display: flex;
        gap: 8px;
      }

      .btn.small {
        padding: 4px 10px;
        font-size: 11px;
      }

      .bookmark-empty {
        font-size: 12px;
        color: var(--muted);
        padding: 6px 4px;
      }

      .marks span {
        max-width: 220px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .speed {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 13px;
      }

      .speed-btn {
        border: 1px solid #d8caba;
        background: #fff;
        color: var(--ink);
        padding: 6px 12px;
        border-radius: 999px;
        font-weight: 600;
        cursor: pointer;
      }

      @keyframes fade-up {
        from {
          opacity: 0;
          transform: translateY(12px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @media (max-width: 980px) {
        .app {
          grid-template-columns: 1fr;
        }
        .library {
          position: relative;
          height: auto;
          border-right: none;
          border-bottom: 1px solid #eadfd2;
          padding-bottom: 160px;
        }
        .book-list {
          display: grid;
          grid-template-columns: repeat(auto-fill, minmax(72px, 1fr));
          gap: 12px;
        }
        .upload-zone {
          padding: 10px;
        }
        .book-card {
          grid-template-columns: 1fr;
          justify-items: stretch;
          padding: 6px;
          overflow: hidden;
        }
        .book-meta {
          display: none;
        }
        .book-cover {
          width: 100%;
          height: auto;
          aspect-ratio: 2 / 3;
        }
        .book-cover img {
          display: block;
        }
        .reader-body {
          grid-template-columns: 1fr;
        }
        .toc {
          max-height: none;
        }
        .edit-panel {
          display: none !important;
        }
        .edit-toggle {
          display: none;
        }
        .jump-btn {
          display: inline-flex;
          align-items: center;
          justify-content: center;
        }
      }

      @media (max-width: 720px) {
        .reader-header {
          flex-direction: column;
          align-items: flex-start;
        }
        .player-bar {
          flex-wrap: wrap;
          gap: 10px;
        }
        .player-controls {
          order: 0;
          width: 100%;
          justify-content: center;
        }
        .player-left {
          order: 1;
          flex: 1 1 100%;
          justify-content: center;
        }
        .player-right {
          order: 2;
          flex: 1 1 100%;
          justify-content: center;
          flex-wrap: wrap;
        }
        .status {
          text-align: center;
        }
      }
    </style>
  </head>
  <body>
    <div class="app">
      <aside class="library" id="bookshelf">
        <div class="brand">pTTS player</div>
        <div class="root-path">Root: {{ root_dir }}</div>
        <div class="upload-panel">
          <div class="upload-zone" id="uploadZone" role="button" tabindex="0">
            <strong>Drop EPUB here</strong>
            <span>or click to browse</span>
          </div>
          <input type="file" id="uploadInput" accept=".epub" hidden />
          <div class="upload-status" id="uploadStatus"></div>
        </div>
        <div id="bookList" class="book-list"></div>
      </aside>
      <main class="reader" id="bookSection">
        <div class="reader-header">
          <div class="cover-large" id="coverLarge"></div>
          <div>
            <h1 class="book-title" id="bookTitle">Select a book</h1>
            <p class="book-subtitle" id="bookMeta">No book loaded.</p>
            <p class="book-subtitle" id="bookStatus"></p>
            <div class="book-actions">
              <div class="book-menu">
                <button class="btn circle" id="bookMenuBtn" type="button" aria-haspopup="true" aria-expanded="false" disabled aria-label="More">⋯</button>
                <div class="menu-panel" id="bookMenuPanel">
                  <button class="btn danger" id="deleteBookBtn" type="button" disabled>Delete book</button>
                </div>
              </div>
            </div>
          </div>
        </div>
        <section class="tts-panel" id="ttsPanel">
          <div class="tts-header">
            <h3>Text To Speech</h3>
            <button class="tts-toggle" id="ttsToggle">Collapse</button>
          </div>
          <div class="tts-grid">
            <div class="tts-field">
              <div class="voice-groups" id="voiceGroup">
                <div class="voice-empty">Loading voices...</div>
              </div>
            </div>
          </div>
          <div class="tts-actions">
            <button class="btn primary" id="startTts">Start TTS</button>
            <button class="btn" id="sampleTts" type="button">Sample</button>
            <button class="btn" id="mergeBtn" type="button">Merge M4B</button>
            <button class="btn" id="clearTtsBtn" type="button" title="Delete tts/ for this book.">Delete TTS cache</button>
          </div>
          <div class="progress-track">
            <div class="progress-fill" id="progressFill"></div>
          </div>
          <div class="progress-text" id="progressText">Idle.</div>
          <div class="progress-detail" id="progressDetail"></div>
          <div class="merge-status" id="ffmpegStatus"></div>
          <div class="merge-status" id="mergeStatus"></div>
        </section>
        <div class="reader-body">
          <aside class="toc">
            <div class="toc-header">
              <h3>Chapters</h3>
              <button class="btn small edit-toggle" id="editToggle" type="button">Edit</button>
            </div>
            <div id="chapterList"></div>
          </aside>
          <section class="text-pane" id="textPane">
            <h2 class="chapter-title" id="chapterTitle">Waiting for a book...</h2>
            <div class="chapter-text" id="chapterText">
              <p class="empty-state">Pick a book on the left to start.</p>
            </div>
          </section>
        </div>
        <section class="edit-panel" id="editPanel">
          <div class="edit-header">
            <div>
              <h3>Sanitize & Preview</h3>
              <p class="edit-meta">Rules auto-save. Re-sanitize refreshes clean text and clears TTS cache.</p>
            </div>
            <div class="edit-actions">
              <button class="btn" id="sanitizeBtn" type="button">Re-sanitize</button>
              <button class="btn" id="editReload" type="button">Reload</button>
              <span class="edit-status" id="editStatus"></span>
            </div>
          </div>
          <div class="edit-grid">
            <aside class="edit-sidebar">
              <div class="panel">
                <div class="edit-section-title">Chapters</div>
                <div class="edit-chapter-list" id="editChapterList"></div>
              </div>
              <div class="panel">
                <div class="edit-section-title">Dropped</div>
                <div class="edit-dropped-list" id="editDroppedList"></div>
              </div>
            </aside>
            <div class="edit-main">
              <div class="panel edit-selected">
                <div class="edit-selected-title" id="editSelectedTitle">Select a chapter</div>
                <button class="btn small" id="dropChapterBtn" type="button">Drop chapter</button>
              </div>
              <div class="panel edit-split">
                <div class="edit-block">
                  <div class="edit-block-header">
                    <h4>Raw</h4>
                  </div>
                  <pre id="editRaw"></pre>
                </div>
                <div class="edit-block">
                  <div class="edit-block-header">
                    <h4>Clean</h4>
                    <button class="btn small" id="editCleanBtn" type="button">Edit</button>
                  </div>
                  <pre id="editClean"></pre>
                  <textarea id="editCleanInput" class="edit-clean-textarea" hidden></textarea>
                  <div class="edit-clean-actions" id="editCleanActions" hidden>
                    <button class="btn small" id="saveCleanBtn" type="button">Save</button>
                    <button class="btn small" id="cancelCleanBtn" type="button">Cancel</button>
                  </div>
                </div>
              </div>
              <div class="panel edit-rules">
                <div class="edit-section-title">Rules</div>
                <label for="rulesDrop">Drop chapter title patterns</label>
                <textarea id="rulesDrop"></textarea>
                <label for="rulesCutoff">Section cutoff patterns</label>
                <textarea id="rulesCutoff"></textarea>
                <label for="rulesRemove">Remove patterns</label>
                <textarea id="rulesRemove"></textarea>
                <label><input type="checkbox" id="rulesReplace" /> Replace defaults</label>
              </div>
            </div>
          </div>
        </section>
      </main>
    </div>

    <div class="player-bar">
      <div class="player-left">
        <div class="status" id="status">Last: —</div>
      </div>
      <div class="player-controls">
        <button class="btn" id="prevBtn">Prev</button>
        <button class="btn primary" id="playBtn">Play</button>
        <button class="btn" id="nextBtn">Next</button>
      </div>
      <div class="player-right">
        <div class="marks">
          <button class="btn" id="bookmarkBtn">Bookmarks</button>
          <div class="bookmark-panel" id="bookmarkPanel">
            <div class="bookmark-title">Bookmarks</div>
            <div class="bookmark-list" id="bookmarkList"></div>
            <button class="btn" id="saveBookmarkBtn">Save current</button>
          </div>
        </div>
        <div class="speed">
          <button class="speed-btn" id="speedBtn" type="button">Speed 1.0x</button>
        </div>
      </div>
      <button class="jump-btn" id="jumpShelf" type="button" aria-label="Back to bookshelf">↑</button>
    </div>

    <audio id="audio"></audio>
    <audio id="audioNext" preload="auto"></audio>

    <script>
      const state = {
        books: [],
        book: null,
        chapters: [],
        chapterMap: {},
        queue: [],
        chapterOffsets: {},
        currentChapterId: null,
        currentQueueIndex: 0,
        activeQueueIndex: null,
        waitingFor: null,
        waitTimer: null,
        audioBase: "",
        synthTimer: null,
        loadingBook: false,
        initialBookId: null,
        initialChapterId: null,
        pendingManifestRefresh: false,
        needsRechunk: false,
        synthRunning: false,
        synthMode: "tts",
        statusMode: "idle",
        playbackSaveTimer: null,
        playback: {
          lastPlayed: null,
          furthestPlayed: null,
          bookmarks: [],
        },
        voicePreference: null,
        preloadedIndex: null,
        padMs: 0,
        gaplessArmedIndex: null,
        playbackRate: 1.0,
        mergeRunning: false,
        mergeReady: false,
        mergeExitCode: null,
        mergeOutputExists: false,
        mergeStage: "idle",
        editOpen: false,
        previewChapterIndex: null,
        previewSelectedTitle: "",
        previewSelectedKind: "",
        rulesLoading: false,
        rulesSaveTimer: null,
        ingestRunning: false,
        cleanEditing: false,
        cleanEditOriginal: "",
        cleanEditChapter: null,
        bookVoice: null,
      };

      const bookList = document.getElementById("bookList");
      const uploadZone = document.getElementById("uploadZone");
      const uploadInput = document.getElementById("uploadInput");
      const uploadStatus = document.getElementById("uploadStatus");
      const chapterList = document.getElementById("chapterList");
      const chapterTitle = document.getElementById("chapterTitle");
      const chapterText = document.getElementById("chapterText");
      const bookTitle = document.getElementById("bookTitle");
      const bookMeta = document.getElementById("bookMeta");
      const bookStatus = document.getElementById("bookStatus");
      const coverLarge = document.getElementById("coverLarge");
      const editToggle = document.getElementById("editToggle");
      const editPanel = document.getElementById("editPanel");
      const sanitizeBtn = document.getElementById("sanitizeBtn");
      const editReload = document.getElementById("editReload");
      const editStatus = document.getElementById("editStatus");
      const editChapterList = document.getElementById("editChapterList");
      const editDroppedList = document.getElementById("editDroppedList");
      const editSelectedTitle = document.getElementById("editSelectedTitle");
      const dropChapterBtn = document.getElementById("dropChapterBtn");
      const editRaw = document.getElementById("editRaw");
      const editClean = document.getElementById("editClean");
      const editCleanBtn = document.getElementById("editCleanBtn");
      const editCleanInput = document.getElementById("editCleanInput");
      const editCleanActions = document.getElementById("editCleanActions");
      const saveCleanBtn = document.getElementById("saveCleanBtn");
      const cancelCleanBtn = document.getElementById("cancelCleanBtn");
      const bookMenuBtn = document.getElementById("bookMenuBtn");
      const bookMenuPanel = document.getElementById("bookMenuPanel");
      const deleteBookBtn = document.getElementById("deleteBookBtn");
      const rulesDrop = document.getElementById("rulesDrop");
      const rulesCutoff = document.getElementById("rulesCutoff");
      const rulesRemove = document.getElementById("rulesRemove");
      const rulesReplace = document.getElementById("rulesReplace");
      const status = document.getElementById("status");
      const playBtn = document.getElementById("playBtn");
      const prevBtn = document.getElementById("prevBtn");
      const nextBtn = document.getElementById("nextBtn");
      const speedBtn = document.getElementById("speedBtn");
      const jumpShelf = document.getElementById("jumpShelf");
      const audio = document.getElementById("audio");
      const audioNext = document.getElementById("audioNext");
      let currentAudio = audio;
      let nextAudio = audioNext;
      const bookmarkBtn = document.getElementById("bookmarkBtn");
      const bookmarkList = document.getElementById("bookmarkList");
      const bookmarkPanel = document.getElementById("bookmarkPanel");
      const saveBookmarkBtn = document.getElementById("saveBookmarkBtn");
      const voiceGroup = document.getElementById("voiceGroup");
      const startTts = document.getElementById("startTts");
      const sampleTts = document.getElementById("sampleTts");
      const mergeBtn = document.getElementById("mergeBtn");
      const clearTtsBtn = document.getElementById("clearTtsBtn");
      const progressFill = document.getElementById("progressFill");
      const progressText = document.getElementById("progressText");
      const progressDetail = document.getElementById("progressDetail");
      const ffmpegStatus = document.getElementById("ffmpegStatus");
      const mergeStatus = document.getElementById("mergeStatus");
      const ttsPanel = document.getElementById("ttsPanel");
      const ttsToggle = document.getElementById("ttsToggle");

      function setStatus(message, mode = "message") {
        status.textContent = message;
        state.statusMode = mode;
      }

      function setUploadStatus(message, tone = "idle") {
        uploadStatus.textContent = message || "";
        uploadStatus.dataset.tone = tone;
      }

      function setIngestRunning(running) {
        state.ingestRunning = running;
        uploadZone.classList.toggle("disabled", running);
        uploadInput.disabled = running;
      }

      function pad6(num) {
        return String(num).padStart(6, "0");
      }

      function readUrlState() {
        const params = new URLSearchParams(window.location.search);
        state.initialBookId = params.get("book");
        state.initialChapterId = params.get("chapter");
      }

      function updateUrl(bookId, chapterId) {
        const params = new URLSearchParams();
        if (bookId) {
          params.set("book", bookId);
        }
        if (chapterId) {
          params.set("chapter", chapterId);
        }
        const query = params.toString();
        const next = query ? `/?${query}` : "/";
        history.replaceState(null, "", next);
      }

      function isMobileLayout() {
        return window.matchMedia("(max-width: 980px)").matches;
      }

      function scrollToBookSection() {
        if (!isMobileLayout()) {
          return;
        }
        const target = document.getElementById("bookSection");
        if (target) {
          target.scrollIntoView({ behavior: "smooth", block: "start" });
        }
      }

      function scrollToTextPane() {
        if (!isMobileLayout()) {
          return;
        }
        const target = document.getElementById("textPane");
        if (target) {
          target.scrollIntoView({ behavior: "smooth", block: "start" });
        }
      }

      function getBookmarks() {
        return state.playback.bookmarks || [];
      }

      function saveBookmarks(bookmarks, persist = true) {
        state.playback.bookmarks = Array.isArray(bookmarks) ? bookmarks : [];
        if (persist) {
          schedulePlaybackSave();
        }
      }

      function getLastPlayed() {
        const value = state.playback.lastPlayed;
        return typeof value === "number" ? value : null;
      }

      function getFurthestPlayed() {
        const value = state.playback.furthestPlayed;
        return typeof value === "number" ? value : null;
      }

      function setLastPlayed(index, persist = true) {
        state.playback.lastPlayed =
          typeof index === "number" ? index : null;
        if (typeof index === "number") {
          const currentFurthest = getFurthestPlayed();
          if (currentFurthest === null || index > currentFurthest) {
            state.playback.furthestPlayed = index;
          }
        }
        if (persist) {
          schedulePlaybackSave();
        }
      }

      async function fetchJson(url, options = {}) {
        const opts = { cache: "no-store", ...options };
        if (options.headers) {
          opts.headers = { ...options.headers };
        }
        const res = await fetch(url, opts);
        if (!res.ok) {
          let detail = `Request failed: ${res.status}`;
          try {
            const payload = await res.json();
            if (payload && payload.detail) {
              detail = payload.detail;
            }
          } catch (err) {
            // ignore parse errors
          }
          throw new Error(detail);
        }
        return res.json();
      }

      async function ingestFile(file) {
        if (!file) {
          return;
        }
        const name = file.name || "";
        if (!name.toLowerCase().endsWith(".epub")) {
          setUploadStatus("Only .epub files are supported.", "error");
          return;
        }
        if (state.ingestRunning) {
          return;
        }
        setIngestRunning(true);
        setUploadStatus(`Ingesting and sanitizing ${name}...`);
        const body = new FormData();
        body.append("file", file);
        try {
          const data = await fetchJson("/api/ingest", {
            method: "POST",
            body,
          });
          const title = data.title || data.book_id || "Book";
          setUploadStatus(`Ingested and sanitized ${title}.`);
          await loadBooks();
          if (data.book_id) {
            await selectBook(data.book_id);
          }
        } catch (err) {
          setUploadStatus(err.message || "Ingest failed.", "error");
        } finally {
          setIngestRunning(false);
          uploadInput.value = "";
        }
      }

      function setSelectedVoice(value) {
        state.voicePreference = value;
        const buttons = voiceGroup.querySelectorAll(".voice-button");
        buttons.forEach((button) => {
          button.classList.toggle("active", button.dataset.voice === value);
        });
        if (value) {
          localStorage.setItem("ptts.voice", value);
        }
      }

      function getSelectedVoice() {
        return state.voicePreference;
      }

      function appendVoiceGroup(container, label, items) {
        if (!items.length) {
          return;
        }
        const group = document.createElement("div");
        group.className = "voice-group";
        const title = document.createElement("div");
        title.className = "voice-group-title";
        title.textContent = label;
        const buttons = document.createElement("div");
        buttons.className = "voice-buttons";
        items.forEach((item) => {
          const button = document.createElement("button");
          button.type = "button";
          button.className = "voice-button";
          button.dataset.voice = item.value;
          button.textContent = formatVoiceLabel(item.label);
          button.addEventListener("click", () => {
            setSelectedVoice(item.value);
          });
          buttons.appendChild(button);
        });
        group.appendChild(title);
        group.appendChild(buttons);
        container.appendChild(group);
      }

      function formatVoiceLabel(label) {
        if (!label) {
          return "";
        }
        const cleaned = String(label).replace(/[_-]+/g, " ").trim();
        if (!cleaned) {
          return "";
        }
        return cleaned
          .split(/\s+/)
          .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
          .join(" ");
      }

      async function loadVoices() {
        try {
          const data = await fetchJson("/api/voices");
          const local = Array.isArray(data.local) ? data.local : [];
          const builtin = Array.isArray(data.builtin) ? data.builtin : [];
          const defaultVoice = data.default || "";

          voiceGroup.innerHTML = "";
          appendVoiceGroup(voiceGroup, "Local voices", local);
          appendVoiceGroup(voiceGroup, "Built-in voices", builtin);

          const available = [...local, ...builtin].map((item) => item.value);
          if (!available.length) {
            voiceGroup.innerHTML = "<div class=\"voice-empty\">No voices found.</div>";
            setSelectedVoice(null);
            return;
          }

          let selected = state.bookVoice || state.voicePreference;
          if (!selected || !available.includes(selected)) {
            if (local.length) {
              selected = local[0].value;
            } else if (defaultVoice && available.includes(defaultVoice)) {
              selected = defaultVoice;
            } else {
              selected = builtin[0].value;
            }
          }
          setSelectedVoice(selected);
        } catch (err) {
          voiceGroup.innerHTML = "<div class=\"voice-empty\">Unable to load voices.</div>";
        }
      }

      function schedulePlaybackSave() {
        if (!state.book) {
          return;
        }
        if (state.playbackSaveTimer) {
          clearTimeout(state.playbackSaveTimer);
        }
        state.playbackSaveTimer = setTimeout(() => {
          persistPlayback();
        }, 500);
      }

      async function persistPlayback(payload) {
        if (!state.book) {
          return;
        }
        const body = payload || {
          last_played: getLastPlayed(),
          furthest_played: getFurthestPlayed(),
          bookmarks: getBookmarks(),
        };
        try {
          await fetchJson(
            `/api/playback?book_id=${encodeURIComponent(state.book.id)}`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(body),
            }
          );
        } catch (err) {
          console.warn("Failed to persist playback state.", err);
        }
      }

      function clearBookView() {
        state.book = null;
        state.chapters = [];
        state.chapterMap = {};
        state.queue = [];
        state.chapterOffsets = {};
        state.currentChapterId = null;
        state.currentQueueIndex = 0;
        state.activeQueueIndex = null;
        state.audioBase = "";
        state.padMs = 0;
        state.mergeRunning = false;
        state.mergeReady = false;
        state.mergeExitCode = null;
        state.mergeOutputExists = false;
        state.mergeStage = "idle";
        state.synthRunning = false;
        state.synthMode = "tts";
        state.playback = { lastPlayed: null, furthestPlayed: null, bookmarks: [] };
        state.bookVoice = null;
        resetAudioPlayers();
        bookTitle.textContent = "Select a book";
        bookMeta.textContent = "No book loaded.";
        bookStatus.textContent = "";
        coverLarge.innerHTML = "";
        chapterTitle.textContent = "Waiting for a book...";
        chapterText.innerHTML =
          "<p class=\"empty-state\">Pick a book on the left to start.</p>";
        chapterList.innerHTML = "";
        ffmpegStatus.textContent = "";
        editPanel.classList.remove("open");
        editToggle.textContent = "Edit";
        state.editOpen = false;
        state.previewChapterIndex = null;
        state.previewSelectedTitle = "";
        state.previewSelectedKind = "";
        updateUrl(null, null);
        updateMergeButtonState();
        updateClearButtonState();
        updateMarks();
      }

      async function loadPlayback() {
        if (!state.book) {
          return;
        }
        try {
          const data = await fetchJson(
            `/api/playback?book_id=${encodeURIComponent(state.book.id)}`
          );
          const last =
            typeof data.last_played === "number" ? data.last_played : null;
          const furthest =
            typeof data.furthest_played === "number" ? data.furthest_played : null;
          const marks = Array.isArray(data.bookmarks) ? data.bookmarks : [];
          const effectiveFurthest = furthest === null ? last : furthest;
          state.playback.furthestPlayed = effectiveFurthest;
          setLastPlayed(last, false);
          saveBookmarks(marks, false);
          if (!data.exists) {
            await persistPlayback({
              last_played: last,
              furthest_played: effectiveFurthest,
              bookmarks: marks,
            });
          }
        } catch (err) {
          console.warn("Failed to load playback state.", err);
        }
      }

      async function loadBooks() {
        try {
          const data = await fetchJson("/api/books");
          state.books = data.books || [];
          renderBooks();
          if (state.initialBookId && !state.book) {
            const initial = state.initialBookId;
            const chapter = state.initialChapterId;
            state.initialBookId = null;
            state.initialChapterId = null;
            await selectBook(initial, chapter);
          }
        } catch (err) {
          bookList.innerHTML = "<p class=\"empty-state\">Failed to load books.</p>";
        }
      }

      function loadSettings() {
        state.voicePreference = localStorage.getItem("ptts.voice");
        const collapsed = localStorage.getItem("ptts.ttsCollapsed") === "1";
        if (collapsed) {
          ttsPanel.classList.add("collapsed");
          ttsToggle.textContent = "Expand";
        }
      }

      function saveSettings() {
        if (state.voicePreference) {
          localStorage.setItem("ptts.voice", state.voicePreference);
        }
      }

      function renderBooks() {
        bookList.innerHTML = "";
        if (!state.books.length) {
          bookList.innerHTML = "<p class=\"empty-state\">No books found.</p>";
          return;
        }
        state.books.forEach((book) => {
          const card = document.createElement("div");
          card.className = "book-card";
          if (state.book && state.book.id === book.id) {
            card.classList.add("active");
          }
          card.innerHTML = `
            <div class="book-cover">${book.cover_url ? `<img src="${book.cover_url}" alt="Cover" />` : ""}</div>
            <div class="book-meta">
              <h4>${book.title}</h4>
              <p>${(book.authors || []).join(", ")}</p>
              <p>${book.has_audio ? "Audio ready" : "No audio yet"}</p>
            </div>
          `;
          card.addEventListener("click", () => selectBook(book.id));
          bookList.appendChild(card);
        });
      }

      async function selectBook(bookId, chapterId) {
        state.loadingBook = true;
        resetAudioPlayers();
        try {
          const data = await fetchJson(`/api/books/${bookId}`);
          state.book = data.book;
          state.chapters = data.chapters || [];
          state.padMs = data.book ? data.book.pad_ms || 0 : 0;
          state.bookVoice = data.book ? data.book.last_voice || null : null;
          state.playback = { lastPlayed: null, furthestPlayed: null, bookmarks: [] };
          state.mergeRunning = false;
          state.mergeReady = false;
          state.mergeExitCode = null;
          state.mergeOutputExists = false;
          state.mergeStage = "idle";
          state.synthMode = "tts";
          mergeStatus.textContent = "";
          state.chapterMap = {};
          state.chapters.forEach((chapter) => {
            if (chapter && chapter.id) {
              state.chapterMap[chapter.id] = chapter;
            }
          });
          state.audioBase = data.audio_base || "";
          state.currentQueueIndex = 0;
          state.activeQueueIndex = null;
          state.waitingFor = null;
          if (state.waitTimer) {
            clearTimeout(state.waitTimer);
          }
          await loadPlayback();
          buildQueue();
          const hasSpanData = state.chapters.some(
            (chapter) => (chapter.chunk_spans || []).length > 0
          );
          state.needsRechunk = state.chapters.length > 0 && !hasSpanData;
          renderBooks();
          renderBookHeader();
          await loadVoices();
          updateDeleteButtonState();
          renderChapters();
          if (state.chapters.length) {
            const desired = chapterId || state.chapters[0].id;
            renderChapter(desired);
            const offset = state.chapterOffsets[desired];
            state.currentQueueIndex =
              typeof offset === "number" ? offset : state.currentQueueIndex;
            setIdleStatus();
            if (state.needsRechunk) {
              setStatus("Manifest missing chunk spans. Delete TTS cache and start TTS.");
            }
          } else {
            chapterTitle.textContent = "No audio yet";
            chapterText.innerHTML =
              "<p class=\"empty-state\">Run `ptts synth` to generate audio chunks.</p>";
            setStatus("No audio available.");
          }
          updateUrl(state.book.id, state.currentChapterId);
          startSynthPolling();
          if (state.editOpen) {
            await loadPreview(state.previewChapterIndex);
          }
          scrollToBookSection();
        } catch (err) {
          setStatus("Failed to load book.");
        } finally {
          state.loadingBook = false;
        }
      }

      function renderBookHeader() {
        if (!state.book) {
          return;
        }
        bookTitle.textContent = state.book.title || state.book.id;
        const author = (state.book.authors || []).join(", ");
        const year = state.book.year ? ` (${state.book.year})` : "";
        bookMeta.textContent = `${author}${year}`;
        bookStatus.textContent = state.book.has_audio
          ? "Audio manifest loaded."
          : "Waiting for audio.";
        if (state.book.cover_url) {
          coverLarge.innerHTML = `<img src="${state.book.cover_url}" alt="Cover" />`;
        } else {
          coverLarge.innerHTML = "";
        }
      }

      function snippet(text, length) {
        if (!text) {
          return "";
        }
        const cleaned = text.replace(/\s+/g, " ").trim();
        return cleaned.slice(0, length);
      }

      function getChapterById(chapterId) {
        return state.chapterMap[chapterId] || null;
      }

      function getChunkSpan(item) {
        const chapter = getChapterById(item.chapterId);
        if (!chapter) {
          return null;
        }
        const spans = chapter.chunk_spans || [];
        return spans[item.chunkIndex] || null;
      }

      function getChunkText(item) {
        const chapter = getChapterById(item.chapterId);
        if (!chapter) {
          return "";
        }
        const span = getChunkSpan(item);
        if (!span || !chapter.clean_text) {
          return "";
        }
        return chapter.clean_text.slice(span[0], span[1]);
      }

      function splitParagraphSpans(text) {
        const spans = [];
        const re = /\n\s*\n+/g;
        let start = 0;
        let match;
        while ((match = re.exec(text)) !== null) {
          const end = match.index;
          let paraStart = start;
          let paraEnd = end;
          while (paraStart < paraEnd && /\s/.test(text[paraStart])) {
            paraStart += 1;
          }
          while (paraEnd > paraStart && /\s/.test(text[paraEnd - 1])) {
            paraEnd -= 1;
          }
          if (paraStart < paraEnd) {
            spans.push([paraStart, paraEnd]);
          }
          start = match.index + match[0].length;
        }
        let tailStart = start;
        let tailEnd = text.length;
        while (tailStart < tailEnd && /\s/.test(text[tailStart])) {
          tailStart += 1;
        }
        while (tailEnd > tailStart && /\s/.test(text[tailEnd - 1])) {
          tailEnd -= 1;
        }
        if (tailStart < tailEnd) {
          spans.push([tailStart, tailEnd]);
        }
        return spans;
      }

      function describeIndex(index) {
        const item = state.queue[index];
        if (!item) {
          return "—";
        }
        const chapterNum = item.chapterIndex + 1;
        const chunkNum = item.chunkIndex + 1;
        const snip = snippet(getChunkText(item), 10);
        return snip ? `${chapterNum}/${chunkNum} ${snip}` : `${chapterNum}/${chunkNum}`;
      }

      function idleStatusText() {
        const lastIndex = getLastPlayed();
        const furthestIndex = getFurthestPlayed();
        const lastLabel =
          lastIndex === null ? "—" : describeIndex(lastIndex);
        const furthestLabel =
          furthestIndex === null ? "—" : describeIndex(furthestIndex);
        return `Last: ${lastLabel} · Furthest: ${furthestLabel}`;
      }

      function setIdleStatus() {
        setStatus(idleStatusText(), "idle");
      }

      function applyLastPlayedHighlight() {
        const prev = chapterText.querySelector(".chunk.last-played");
        if (prev) {
          prev.classList.remove("last-played");
        }
        const lastIndex = getLastPlayed();
        if (lastIndex === null) {
          return;
        }
        const item = state.queue[lastIndex];
        if (!item || item.chapterId !== state.currentChapterId) {
          return;
        }
        const span = chapterText.querySelector(
          `.chunk[data-queue-index="${lastIndex}"]`
        );
        if (span) {
          span.classList.add("last-played");
        }
      }

      function updateMarks() {
        if (!state.book) {
          bookmarkList.innerHTML = "<div class=\"bookmark-empty\">No bookmarks yet.</div>";
          saveBookmarkBtn.disabled = true;
          return;
        }
        const bookmarks = getBookmarks();
        bookmarkList.innerHTML = "";
        const furthestIndex = getFurthestPlayed();
        if (furthestIndex !== null) {
          const item = document.createElement("div");
          item.className = "bookmark-item";
          const label = describeIndex(furthestIndex);
          item.innerHTML = `
            <span>Furthest: ${label}</span>
            <div class="bookmark-actions">
              <button class="btn small" data-action="play-furthest" data-index="${furthestIndex}">Play</button>
            </div>
          `;
          bookmarkList.appendChild(item);
        }
        if (!bookmarks.length) {
          if (furthestIndex === null) {
            bookmarkList.innerHTML = "<div class=\"bookmark-empty\">No bookmarks yet.</div>";
          }
        } else {
          bookmarks.forEach((entry) => {
            const item = document.createElement("div");
            item.className = "bookmark-item";
            const label = describeIndex(entry.index);
            item.innerHTML = `
              <span>${label}</span>
              <div class="bookmark-actions">
                <button class="btn small" data-action="play" data-index="${entry.index}">Play</button>
                <button class="btn small" data-action="remove" data-index="${entry.index}">Remove</button>
              </div>
            `;
            bookmarkList.appendChild(item);
          });
        }
        saveBookmarkBtn.disabled = !state.queue.length;
        if (state.statusMode === "idle") {
          setIdleStatus();
        }
      }

      function jumpToIndex(index, autoplay) {
        if (index === null || index < 0 || index >= state.queue.length) {
          return;
        }
        state.currentQueueIndex = index;
        setActiveChunk(index, false);
        if (autoplay) {
          playIndex(index);
        } else {
          const item = state.queue[index];
          if (item && state.currentChapterId !== item.chapterId) {
            renderChapter(item.chapterId);
          }
        }
        updateMarks();
      }

      function addBookmark(index) {
        if (index === null || index < 0 || index >= state.queue.length) {
          return;
        }
        const bookmarks = getBookmarks();
        if (bookmarks.some((entry) => entry.index === index)) {
          return;
        }
        bookmarks.push({
          index,
          label: describeIndex(index),
          created_at: Date.now(),
        });
        saveBookmarks(bookmarks);
      }

      function removeBookmark(index) {
        const bookmarks = getBookmarks();
        const next = bookmarks.filter((entry) => entry.index !== index);
        saveBookmarks(next);
      }

      function startSynthPolling() {
        if (state.synthTimer) {
          clearInterval(state.synthTimer);
        }
        state.synthTimer = setInterval(loadSynthStatus, 2000);
        loadSynthStatus();
      }

      async function loadSynthStatus() {
        if (!state.book) {
          return;
        }
        try {
          const data = await fetchJson(
            `/api/synth/status?book_id=${encodeURIComponent(state.book.id)}`
          );
          updateSynthUI(data);
          await loadMergeStatus();
          if (
            !state.loadingBook &&
            data.progress &&
            data.progress.total > 0 &&
            (state.pendingManifestRefresh || !state.chapters.length)
          ) {
            await selectBook(state.book.id);
            state.pendingManifestRefresh = false;
          }
        } catch (err) {
          progressText.textContent = "Unable to load TTS status.";
        }
      }

      function updateSynthUI(data) {
        state.synthRunning = !!data.running;
        state.synthMode = data.mode || "tts";
        const sampling = state.synthMode === "sample";
        if (state.synthRunning && sampling) {
          startTts.textContent = "Start TTS";
          startTts.disabled = true;
          sampleTts.textContent = "Stop Sample";
        } else {
          startTts.textContent = state.synthRunning ? "Stop TTS" : "Start TTS";
          startTts.disabled = false;
          sampleTts.textContent = "Sample";
        }
        const progress = data.progress;
        const overall = data.overall_progress || null;
        state.mergeReady =
          !sampling &&
          !!progress &&
          progress.total > 0 &&
          progress.done >= progress.total &&
          !state.synthRunning;
        updateMergeButtonState();
        const stage = data.stage || "idle";
        if (stage === "chunking") {
          progressFill.style.width =
            sampling && overall
              ? `${overall.percent}%`
              : "0%";
          progressText.textContent = sampling
            ? "Chunking sample..."
            : "Chunking text...";
          progressDetail.textContent = "Preparing manifest and spans.";
        } else if (stage === "cloning") {
          progressFill.style.width =
            sampling && overall
              ? `${overall.percent}%`
              : "0%";
          progressText.textContent = sampling
            ? "Cloning voice for sample..."
            : "Cloning voice...";
          progressDetail.textContent = "Preparing voice prompt.";
        } else if (stage === "sampled") {
          progressFill.style.width =
            sampling && overall
              ? `${overall.percent}%`
              : "100%";
          progressText.textContent = "Sample ready.";
          if (progress && progress.current) {
            progressDetail.textContent = `${progress.current.chapter_title} · sample done.`;
          } else {
            progressDetail.textContent = "";
          }
        } else if (!progress) {
          progressFill.style.width = "0%";
          progressText.textContent = "Idle.";
          progressDetail.textContent = "";
        } else {
          const barPercent =
            sampling && overall
              ? overall.percent
              : progress.percent;
          progressFill.style.width = `${barPercent}%`;
          const prefix = sampling ? "Sample" : "Progress";
          progressText.textContent = `${prefix}: ${progress.done} / ${progress.total} chunks (${progress.percent}%).`;
          if (progress.current) {
            progressDetail.textContent = `${progress.current.chapter_title} · chunk ${progress.current.chunk_index} of ${progress.current.chunk_total}`;
          } else {
            progressDetail.textContent = progress.total ? "Completed." : "Idle.";
          }
        }

        if (sampling) {
          if (stage === "chunking") {
            bookStatus.textContent = "Preparing sample...";
          } else if (stage === "cloning") {
            bookStatus.textContent = "Cloning sample voice...";
          } else if (stage === "sampling") {
            bookStatus.textContent = "Generating sample...";
          } else if (stage === "sampled") {
            bookStatus.textContent = "Sample ready.";
          } else {
            bookStatus.textContent = state.book && state.book.has_audio ? "Audio ready." : "Waiting for audio.";
          }
        } else if (stage === "chunking") {
          bookStatus.textContent = "Chunking text...";
        } else if (stage === "synthesizing") {
          bookStatus.textContent = "Synthesizing audio...";
        } else if (stage === "done") {
          bookStatus.textContent = "Audio ready.";
        } else {
          bookStatus.textContent = state.book && state.book.has_audio ? "Audio ready." : "Waiting for audio.";
        }
        startTts.disabled = state.synthRunning && sampling;
        const ffmpegState = data.ffmpeg_status || "unknown";
        if (ffmpegState === "installing") {
          ffmpegStatus.textContent = "Installing ffmpeg...";
        } else if (ffmpegState === "error") {
          ffmpegStatus.textContent =
            data.ffmpeg_error || "ffmpeg install failed.";
        } else if (ffmpegState === "missing") {
          ffmpegStatus.textContent =
            data.ffmpeg_error || "ffmpeg missing: merge will fail.";
        } else {
          ffmpegStatus.textContent = "";
        }
        updateClearButtonState();
      }

      async function loadMergeStatus() {
        if (!state.book) {
          return;
        }
        try {
          const data = await fetchJson(
            `/api/merge/status?book_id=${encodeURIComponent(state.book.id)}`
          );
          updateMergeUI(data);
        } catch (err) {
          mergeStatus.textContent = err.message || "Unable to load merge status.";
        }
      }

      function updateMergeButtonState() {
        mergeBtn.disabled =
          !state.mergeReady || state.mergeRunning || state.mergeOutputExists;
        if (state.mergeRunning && state.mergeStage === "installing") {
          mergeBtn.textContent = "Installing ffmpeg...";
        } else if (state.mergeRunning) {
          mergeBtn.textContent = "Merging...";
        } else {
          mergeBtn.textContent = "Merge M4B";
        }
      }

      function updateClearButtonState() {
        clearTtsBtn.disabled = state.synthRunning || state.mergeRunning;
        updateDeleteButtonState();
        sampleTts.disabled =
          !state.book ||
          state.mergeRunning ||
          (state.synthRunning && state.synthMode !== "sample");
      }

      function updateDeleteButtonState() {
        const disabled = !state.book || state.synthRunning || state.mergeRunning;
        deleteBookBtn.disabled = disabled;
        bookMenuBtn.disabled = disabled;
        if (disabled) {
          bookMenuPanel.classList.remove("open");
          bookMenuBtn.setAttribute("aria-expanded", "false");
        }
      }

      function updateMergeUI(data) {
        state.mergeRunning = !!data.running;
        state.mergeExitCode =
          typeof data.exit_code === "number" ? data.exit_code : null;
        state.mergeOutputExists = !!data.output_exists;
        state.mergeStage = data.stage || (state.mergeRunning ? "merging" : "idle");
        updateMergeButtonState();
        let percentText = "";
        if (data.progress && typeof data.progress.percent === "number") {
          percentText = ` ${data.progress.percent.toFixed(1)}%`;
        }
        if (state.mergeStage === "installing") {
          mergeStatus.textContent = "Installing ffmpeg...";
        } else if (state.mergeStage === "merging") {
          mergeStatus.textContent = `Merging book...${percentText}`;
        } else if (state.mergeStage === "done") {
          mergeStatus.textContent = "M4B ready.";
        } else if (state.mergeStage === "failed") {
          mergeStatus.textContent = "Merge failed. Check tts/merge.log.";
        } else {
          mergeStatus.textContent = "";
        }
        updateClearButtonState();
      }

      function toggleBookMenu() {
        if (bookMenuBtn.disabled) {
          return;
        }
        const open = bookMenuPanel.classList.toggle("open");
        bookMenuBtn.setAttribute("aria-expanded", open ? "true" : "false");
      }

      function closeBookMenu() {
        bookMenuPanel.classList.remove("open");
        bookMenuBtn.setAttribute("aria-expanded", "false");
      }

      async function startSynth() {
        if (!state.book) {
          return;
        }
        saveSettings();
        state.mergeExitCode = null;
        state.mergeOutputExists = false;
        mergeStatus.textContent = "";
        updateMergeButtonState();
        const payload = {
          book_id: state.book.id,
          voice: getSelectedVoice(),
        };
        state.pendingManifestRefresh = !state.chapters.length;
        try {
          await fetchJson("/api/synth/start", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          setStatus("TTS started.");
          await loadSynthStatus();
        } catch (err) {
          setStatus("Failed to start TTS.");
        }
      }

      async function startMerge() {
        if (!state.book) {
          return;
        }
        if (!state.mergeReady) {
          setStatus("Finish TTS before merging.");
          return;
        }
        if (state.mergeOutputExists) {
          setStatus("M4B already exists.");
          return;
        }
        mergeStatus.textContent = "Starting merge...";
        try {
          await fetchJson("/api/merge/start", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ book_id: state.book.id }),
          });
          setStatus("Merge started.");
          await loadMergeStatus();
        } catch (err) {
          mergeStatus.textContent = err.message || "Merge failed to start.";
          setStatus(err.message || "Merge failed to start.");
        }
      }

      async function sampleSynth() {
        if (!state.book) {
          return;
        }
        if (state.synthRunning) {
          setStatus("Stop TTS before sampling.");
          return;
        }
        saveSettings();
        try {
          await fetchJson("/api/synth/sample", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              book_id: state.book.id,
              voice: getSelectedVoice(),
            }),
          });
          setStatus("Generating sample...");
          await loadSynthStatus();
        } catch (err) {
          setStatus(err.message || "Sample failed.");
        }
      }

      function toggleSample() {
        if (state.synthRunning && state.synthMode === "sample") {
          stopSynth();
        } else {
          sampleSynth();
        }
      }

      async function deleteBook() {
        if (!state.book) {
          return;
        }
        if (state.synthRunning || state.mergeRunning) {
          setStatus("Stop TTS or merge before deleting.");
          return;
        }
        const label = state.book.title || state.book.id;
        const confirmed = window.confirm(
          `Delete "${label}" and all files in this book folder?`
        );
        if (!confirmed) {
          return;
        }
        closeBookMenu();
        setStatus("Deleting book...");
        try {
          await fetchJson("/api/books/delete", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ book_id: state.book.id }),
          });
          clearBookView();
          await loadBooks();
          setStatus("Book deleted.");
        } catch (err) {
          setStatus(err.message || "Failed to delete book.");
        }
      }

      async function clearTtsCache() {
        if (!state.book) {
          return;
        }
        if (state.synthRunning || state.mergeRunning) {
          setStatus("Stop TTS/merge before clearing cache.");
          return;
        }
        const ok = confirm("Delete all TTS cache for this book?");
        if (!ok) {
          return;
        }
        try {
          await fetchJson("/api/tts/clear", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ book_id: state.book.id }),
          });
          setStatus("TTS cache deleted.");
          state.mergeOutputExists = false;
          state.mergeExitCode = null;
          state.mergeStage = "idle";
          mergeStatus.textContent = "";
          updateMergeButtonState();
          await selectBook(state.book.id);
          if (state.editOpen) {
            await loadPreview(state.previewChapterIndex);
          }
        } catch (err) {
          setStatus(err.message || "Failed to clear TTS cache.");
        }
      }

      async function stopSynth() {
        if (!state.book) {
          return;
        }
        try {
          await fetchJson("/api/synth/stop", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ book_id: state.book.id }),
          });
          setStatus("TTS stopped.");
          await loadSynthStatus();
        } catch (err) {
          setStatus("Failed to stop TTS.");
        }
      }

      function toggleSynth() {
        if (state.synthRunning) {
          stopSynth();
        } else {
          startSynth();
        }
      }

      function buildQueue() {
        state.queue = [];
        state.chapterOffsets = {};
        let offset = 0;
        state.chapters.forEach((chapter, chapterIndex) => {
          state.chapterOffsets[chapter.id] = offset;
          const spans = chapter.chunk_spans || [];
          spans.forEach((_span, chunkIndex) => {
            state.queue.push({
              chapterId: chapter.id,
              chapterIndex,
              chunkIndex,
            });
          });
          offset += spans.length;
        });
      }

      function renderChapters() {
        chapterList.innerHTML = "";
        if (!state.chapters.length) {
          chapterList.innerHTML = "<p class=\"empty-state\">No chapters yet.</p>";
          return;
        }
        state.chapters.forEach((chapter) => {
          const item = document.createElement("div");
          item.className = "toc-item";
          if (chapter.id === state.currentChapterId) {
            item.classList.add("active");
          }
          item.innerHTML = `
            <div>${chapter.title}</div>
            <small>${chapter.chunk_count} chunks</small>
          `;
          item.addEventListener("click", () => {
            renderChapter(chapter.id);
            state.currentQueueIndex = state.chapterOffsets[chapter.id] || 0;
            setIdleStatus();
            updateUrl(state.book ? state.book.id : null, chapter.id);
            scrollToTextPane();
          });
          chapterList.appendChild(item);
        });
      }

      function renderChapter(chapterId) {
        const chapter = getChapterById(chapterId);
        if (!chapter) {
          return;
        }
        state.currentChapterId = chapter.id;
        chapterTitle.textContent = chapter.title;
        chapterText.innerHTML = "";
        const cleanText = chapter.clean_text || "";
        const spans = chapter.chunk_spans || [];
        const startIndex = state.chapterOffsets[chapter.id] || 0;
        const paragraphs = splitParagraphSpans(cleanText);
        let spanIndex = 0;

        if (!paragraphs.length) {
          chapterText.innerHTML = "<p class=\"empty-state\">No text available.</p>";
        } else {
          paragraphs.forEach(([paraStart, paraEnd]) => {
            const p = document.createElement("p");
            let cursor = paraStart;

            while (spanIndex < spans.length && spans[spanIndex][1] <= paraStart) {
              spanIndex += 1;
            }

            while (spanIndex < spans.length && spans[spanIndex][0] < paraEnd) {
              const spanEntry = spans[spanIndex];
              const spanStart = spanEntry[0];
              const spanEnd = spanEntry[1];
              if (spanStart > cursor) {
                p.appendChild(
                  document.createTextNode(cleanText.slice(cursor, spanStart))
                );
              }
              const span = document.createElement("span");
              span.className = "chunk";
              span.dataset.queueIndex = startIndex + spanIndex;
              span.textContent = cleanText.slice(spanStart, spanEnd);
              p.appendChild(span);
              cursor = spanEnd;
              spanIndex += 1;
            }

            if (cursor < paraEnd) {
              p.appendChild(
                document.createTextNode(cleanText.slice(cursor, paraEnd))
              );
            }
            chapterText.appendChild(p);
          });
        }
        renderChapters();
        applyLastPlayedHighlight();
        if (state.activeQueueIndex !== null) {
          const activeItem = state.queue[state.activeQueueIndex];
          if (activeItem && activeItem.chapterId === chapter.id) {
            setActiveChunk(state.activeQueueIndex, false);
          }
        }
        updateUrl(state.book ? state.book.id : null, chapter.id);
        updateMarks();
      }

      function setActiveChunk(index, waiting) {
        if (state.activeQueueIndex !== null) {
          const prev = chapterText.querySelector(
            `.chunk[data-queue-index="${state.activeQueueIndex}"]`
          );
          if (prev) {
            prev.classList.remove("active", "waiting");
            prev.classList.add("played");
          }
        }
        const item = state.queue[index];
        if (!item) {
          return;
        }
        if (state.currentChapterId !== item.chapterId) {
          renderChapter(item.chapterId);
        }
        const span = chapterText.querySelector(
          `.chunk[data-queue-index="${index}"]`
        );
        if (span) {
          span.classList.add(waiting ? "waiting" : "active");
          span.classList.remove(waiting ? "active" : "waiting");
          span.scrollIntoView({ block: "center", behavior: "smooth" });
        }
        state.activeQueueIndex = index;
        applyLastPlayedHighlight();
      }

      function hasUnsavedCleanChanges() {
        return (
          state.cleanEditing &&
          editCleanInput.value !== state.cleanEditOriginal
        );
      }

      function setCleanEditMode(enabled) {
        state.cleanEditing = enabled;
        editCleanInput.hidden = !enabled;
        editCleanActions.hidden = !enabled;
        editClean.hidden = enabled;
        editCleanBtn.disabled = enabled;
        editReload.disabled = enabled;
        dropChapterBtn.disabled =
          enabled ||
          !state.previewSelectedTitle ||
          state.previewSelectedKind === "title";
        if (enabled) {
          const text = editClean.textContent || "";
          editCleanInput.value = text;
          state.cleanEditOriginal = text;
          state.cleanEditChapter = state.previewChapterIndex;
          editStatus.textContent = "Editing clean text...";
          setTimeout(() => editCleanInput.focus(), 0);
        } else {
          editCleanInput.value = "";
          state.cleanEditOriginal = "";
          state.cleanEditChapter = null;
        }
      }

      function startCleanEdit() {
        if (!state.book || state.previewChapterIndex === null) {
          editStatus.textContent = "Select a chapter to edit.";
          return;
        }
        setCleanEditMode(true);
      }

      function cancelCleanEdit() {
        if (!state.cleanEditing) {
          return;
        }
        if (hasUnsavedCleanChanges()) {
          const discard = window.confirm("Discard unsaved clean text edits?");
          if (!discard) {
            return;
          }
        }
        setCleanEditMode(false);
        editStatus.textContent = "Edit canceled.";
      }

      async function saveCleanText() {
        if (!state.book || state.previewChapterIndex === null) {
          return;
        }
        const text = editCleanInput.value || "";
        editStatus.textContent = "Saving clean text...";
        try {
          const data = await fetchJson("/api/sanitize/clean", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              book_id: state.book.id,
              chapter_index: state.previewChapterIndex,
              text,
            }),
          });
          setCleanEditMode(false);
          editStatus.textContent = data.tts_cleared
            ? "Saved clean text. TTS cache cleared."
            : "Saved clean text.";
          await selectBook(state.book.id, state.currentChapterId);
          await loadPreview(state.previewChapterIndex);
        } catch (err) {
          editStatus.textContent = err.message || "Failed to save clean text.";
        }
      }

      function parseRuleLines(text) {
        return text
          .split("\n")
          .map((line) => line.trim())
          .filter((line) => line.length > 0);
      }

      function rulesFromForm() {
        return {
          drop_chapter_title_patterns: parseRuleLines(rulesDrop.value || ""),
          section_cutoff_patterns: parseRuleLines(rulesCutoff.value || ""),
          remove_patterns: parseRuleLines(rulesRemove.value || ""),
          replace_defaults: !!rulesReplace.checked,
        };
      }

      function applyRulesToForm(rules) {
        state.rulesLoading = true;
        rulesDrop.value = (rules.drop_chapter_title_patterns || []).join("\n");
        rulesCutoff.value = (rules.section_cutoff_patterns || []).join("\n");
        rulesRemove.value = (rules.remove_patterns || []).join("\n");
        rulesReplace.checked = !!rules.replace_defaults;
        state.rulesLoading = false;
      }

      function scheduleRulesSave() {
        if (state.rulesLoading) {
          return;
        }
        if (state.rulesSaveTimer) {
          clearTimeout(state.rulesSaveTimer);
        }
        state.rulesSaveTimer = setTimeout(() => {
          saveRules();
        }, 700);
      }

      async function saveRules() {
        if (!state.book) {
          return;
        }
        const payload = rulesFromForm();
        editStatus.textContent = "Saving rules...";
        try {
          await fetchJson("/api/sanitize/rules", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          editStatus.textContent = "Rules saved.";
          await loadPreview(state.previewChapterIndex);
        } catch (err) {
          editStatus.textContent = err.message || "Failed to save rules.";
        }
      }

      function renderEditChapterList(chapters, selectedIndex) {
        editChapterList.innerHTML = "";
        if (!chapters.length) {
          editChapterList.innerHTML = "<p class=\"empty-state\">No chapters.</p>";
          return;
        }
        chapters.forEach((entry) => {
          const button = document.createElement("button");
          button.type = "button";
          button.className = "edit-chapter-item";
          if (entry.index === selectedIndex) {
            button.classList.add("active");
          }
          const title = entry.title || "Chapter";
          button.textContent = `${entry.index}. ${title}`;
          button.addEventListener("click", () => {
            loadPreview(entry.index);
          });
          editChapterList.appendChild(button);
        });
      }

      function renderDroppedList(items) {
        editDroppedList.innerHTML = "";
        if (!items.length) {
          editDroppedList.innerHTML = "<p class=\"empty-state\">None.</p>";
          return;
        }
        items.forEach((entry) => {
          const row = document.createElement("div");
          row.className = "edit-dropped-item";
          const title = entry.title || "Chapter";
          row.innerHTML = `
            <span>${entry.index}. ${title}</span>
            <button class="btn small" type="button">Restore</button>
          `;
          const button = row.querySelector("button");
          button.addEventListener("click", () => restoreChapter(entry.title));
          editDroppedList.appendChild(row);
        });
      }

      async function loadPreview(chapterIndex) {
        if (!state.book) {
          return;
        }
        if (
          state.cleanEditing &&
          chapterIndex !== undefined &&
          chapterIndex !== null &&
          chapterIndex !== state.cleanEditChapter
        ) {
          if (hasUnsavedCleanChanges()) {
            const discard = window.confirm(
              "Discard unsaved clean text edits?"
            );
            if (!discard) {
              return;
            }
          }
          setCleanEditMode(false);
        }
        const params = new URLSearchParams();
        params.set("book_id", state.book.id);
        if (chapterIndex) {
          params.set("chapter", chapterIndex);
        }
        try {
          const data = await fetchJson(`/api/sanitize/preview?${params.toString()}`);
          const selected = data.selected || {};
          state.previewChapterIndex = selected.index || null;
          state.previewSelectedTitle = selected.title || "";
          state.previewSelectedKind = selected.kind || "";
          if (selected.title) {
            const prefix = selected.index ? `${selected.index}. ` : "";
            editSelectedTitle.textContent = `${prefix}${selected.title}`;
          } else {
            editSelectedTitle.textContent = "Select a chapter";
          }
          dropChapterBtn.disabled =
            !selected.title || selected.kind === "title" || state.cleanEditing;
          editRaw.innerHTML = data.raw_text || "";
          const selectedIndex =
            typeof selected.index === "number"
              ? selected.index
              : state.previewChapterIndex;
          const preserveClean =
            state.cleanEditing && state.cleanEditChapter === selectedIndex;
          if (!preserveClean) {
            editClean.textContent = data.clean_text || "";
            editCleanInput.value = data.clean_text || "";
          }
          renderEditChapterList(data.chapters || [], selected.index);
          renderDroppedList(data.dropped || []);
          if (!state.cleanEditing) {
            applyRulesToForm(data.rules || {});
          }
          editStatus.textContent = "";
        } catch (err) {
          editStatus.textContent = err.message || "Failed to load preview.";
        }
      }

      function toggleEditPanel() {
        state.editOpen = !state.editOpen;
        editPanel.classList.toggle("open", state.editOpen);
        editToggle.textContent = state.editOpen ? "Close" : "Edit";
        if (state.editOpen) {
          loadPreview(state.previewChapterIndex);
        } else if (state.cleanEditing) {
          setCleanEditMode(false);
        }
      }

      async function dropSelectedChapter() {
        if (!state.book || !state.previewSelectedTitle) {
          return;
        }
        try {
          await fetchJson("/api/sanitize/drop", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              book_id: state.book.id,
              title: state.previewSelectedTitle,
            }),
          });
          editStatus.textContent = "Chapter queued for drop.";
          await loadPreview(state.previewChapterIndex);
        } catch (err) {
          editStatus.textContent = err.message || "Failed to drop chapter.";
        }
      }

      async function restoreChapter(title) {
        if (!state.book || !title) {
          return;
        }
        try {
          await fetchJson("/api/sanitize/restore", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ book_id: state.book.id, title }),
          });
          editStatus.textContent = "Chapter restored.";
          await loadPreview(state.previewChapterIndex);
        } catch (err) {
          editStatus.textContent = err.message || "Failed to restore chapter.";
        }
      }

      async function runSanitize() {
        if (!state.book) {
          return;
        }
        editStatus.textContent = "Sanitizing...";
        try {
          const data = await fetchJson("/api/sanitize/run", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ book_id: state.book.id }),
          });
          const cleared = data.tts_cleared ? " TTS cache cleared." : "";
          editStatus.textContent = `Sanitized.${cleared}`;
          await selectBook(state.book.id);
          await loadPreview(state.previewChapterIndex);
        } catch (err) {
          editStatus.textContent = err.message || "Sanitize failed.";
        }
      }

      async function chunkExists(item) {
        const chunkNum = item.chunkIndex + 1;
        const url = `/api/chunk-status?book_id=${encodeURIComponent(
          state.book.id
        )}&chapter_id=${encodeURIComponent(
          item.chapterId
        )}&chunk=${chunkNum}`;
        const data = await fetchJson(url);
        return data.exists;
      }

      function chunkUrl(item) {
        const chunkNum = item.chunkIndex + 1;
        return `${state.audioBase}/${item.chapterId}/${pad6(chunkNum)}.wav`;
      }

      function resetAudioPlayers() {
        [audio, audioNext].forEach((element) => {
          element.ontimeupdate = null;
          element.pause();
          element.removeAttribute("src");
          element.load();
        });
        currentAudio = audio;
        nextAudio = audioNext;
        state.preloadedIndex = null;
        state.gaplessArmedIndex = null;
        playBtn.textContent = "Play";
      }

      function setPlaybackRate(rate) {
        currentAudio.playbackRate = rate;
        nextAudio.playbackRate = rate;
      }

      function setSpeedRate(rate) {
        state.playbackRate = rate;
        speedBtn.textContent = `Speed ${rate.toFixed(1)}x`;
        setPlaybackRate(rate);
      }

      function clearPreload() {
        state.preloadedIndex = null;
        nextAudio.pause();
        nextAudio.removeAttribute("src");
        nextAudio.load();
      }

      function usePreloadedAudio(index) {
        if (state.preloadedIndex !== index || !nextAudio.src) {
          return false;
        }
        currentAudio.pause();
        [currentAudio, nextAudio] = [nextAudio, currentAudio];
        clearPreload();
        return true;
      }

      function clearGapless() {
        state.gaplessArmedIndex = null;
        currentAudio.ontimeupdate = null;
      }

      function gaplessTailSeconds() {
        const padMs = Number(state.padMs) || 0;
        if (!padMs) {
          return 0;
        }
        return Math.min(0.2, padMs / 1000);
      }

      function armGapless(index) {
        clearGapless();
        const tailSec = gaplessTailSeconds();
        if (!tailSec) {
          return;
        }
        state.gaplessArmedIndex = index;
        currentAudio.ontimeupdate = () => {
          if (state.gaplessArmedIndex !== index) {
            return;
          }
          if (currentAudio.paused) {
            return;
          }
          const duration = currentAudio.duration;
          if (!duration || Number.isNaN(duration)) {
            return;
          }
          const remaining = duration - currentAudio.currentTime;
          if (remaining > tailSec) {
            return;
          }
          currentAudio.ontimeupdate = null;
          const nextIndex = index + 1;
          if (state.preloadedIndex === nextIndex && nextAudio.src) {
            playIndex(nextIndex);
          }
        };
      }

      async function preloadIndex(index) {
        if (!state.queue.length) {
          return;
        }
        if (index < 0 || index >= state.queue.length) {
          clearPreload();
          return;
        }
        if (state.preloadedIndex === index && nextAudio.src) {
          return;
        }
        const item = state.queue[index];
        let available = false;
        if (state.preloadedIndex === index && nextAudio.src) {
          available = true;
        } else {
          try {
            available = await chunkExists(item);
          } catch (err) {
            available = false;
          }
        }
        if (!available) {
          return;
        }
        nextAudio.src = chunkUrl(item);
        nextAudio.load();
        nextAudio.playbackRate = state.playbackRate || 1;
        state.preloadedIndex = index;
      }

      async function playIndex(index) {
        if (!state.queue.length) {
          return;
        }
        if (index < 0 || index >= state.queue.length) {
          setStatus("End of book.");
          currentAudio.pause();
          clearGapless();
          return;
        }
        clearGapless();
        const item = state.queue[index];
        state.currentQueueIndex = index;
        setLastPlayed(index);
        setActiveChunk(index, true);
        setStatus(`Waiting for chunk ${index + 1} of ${state.queue.length}...`);
        updateMarks();

        let available = false;
        try {
          available = await chunkExists(item);
        } catch (err) {
          available = false;
        }

        if (!available) {
          waitForChunk(index);
          currentAudio.pause();
          playBtn.textContent = "Play";
          setStatus("Chunk not ready. Press Play to retry.");
          return;
        }

        if (state.waitTimer) {
          clearTimeout(state.waitTimer);
        }
        state.waitingFor = null;
        setActiveChunk(index, false);
        const usedPreload = usePreloadedAudio(index);
        if (!usedPreload) {
          clearPreload();
          currentAudio.pause();
          currentAudio.src = chunkUrl(item);
          currentAudio.load();
        }
        setPlaybackRate(state.playbackRate || 1);
        try {
          await currentAudio.play();
          setStatus(
            `Playing ${item.chapterId} ${item.chunkIndex + 1} / ${state.queue.length}`
          );
          playBtn.textContent = "Pause";
        } catch (err) {
          setStatus("Press Play to start audio.");
        }
        armGapless(index);
        void preloadIndex(index + 1);
      }

      function waitForChunk(index) {
        state.waitingFor = index;
        if (state.waitTimer) {
          clearTimeout(state.waitTimer);
        }
        state.waitTimer = null;
      }

      function togglePlay() {
        if (!state.queue.length) {
          return;
        }
        if (currentAudio.paused) {
          const lastIndex = getLastPlayed();
          const startIndex = lastIndex === null ? 0 : lastIndex;
          playIndex(startIndex);
        } else {
          currentAudio.pause();
          playBtn.textContent = "Play";
          setIdleStatus();
          clearGapless();
        }
      }

      function nextChunk() {
        playIndex(state.currentQueueIndex + 1);
      }

      function prevChunk() {
        playIndex(Math.max(0, state.currentQueueIndex - 1));
      }

      playBtn.addEventListener("click", togglePlay);
      prevBtn.addEventListener("click", prevChunk);
      nextBtn.addEventListener("click", nextChunk);
      uploadZone.addEventListener("click", () => {
        if (state.ingestRunning) {
          return;
        }
        uploadInput.click();
      });
      uploadZone.addEventListener("keydown", (event) => {
        if (event.key === "Enter" || event.key === " ") {
          event.preventDefault();
          if (!state.ingestRunning) {
            uploadInput.click();
          }
        }
      });
      uploadZone.addEventListener("dragover", (event) => {
        event.preventDefault();
        if (state.ingestRunning) {
          return;
        }
        uploadZone.classList.add("dragover");
      });
      uploadZone.addEventListener("dragleave", () => {
        uploadZone.classList.remove("dragover");
      });
      uploadZone.addEventListener("drop", (event) => {
        event.preventDefault();
        uploadZone.classList.remove("dragover");
        if (state.ingestRunning) {
          return;
        }
        const file = event.dataTransfer?.files?.[0];
        ingestFile(file);
      });
      uploadInput.addEventListener("change", () => {
        const file = uploadInput.files ? uploadInput.files[0] : null;
        ingestFile(file);
      });
      startTts.addEventListener("click", toggleSynth);
      sampleTts.addEventListener("click", toggleSample);
      mergeBtn.addEventListener("click", startMerge);
      clearTtsBtn.addEventListener("click", clearTtsCache);
      bookMenuBtn.addEventListener("click", toggleBookMenu);
      document.addEventListener("click", (event) => {
        if (!bookMenuPanel.classList.contains("open")) {
          return;
        }
        const target = event.target;
        if (
          target === bookMenuBtn ||
          bookMenuPanel.contains(target)
        ) {
          return;
        }
        closeBookMenu();
      });
      deleteBookBtn.addEventListener("click", deleteBook);
      editToggle.addEventListener("click", toggleEditPanel);
      sanitizeBtn.addEventListener("click", runSanitize);
      editReload.addEventListener("click", () => loadPreview(state.previewChapterIndex));
      dropChapterBtn.addEventListener("click", dropSelectedChapter);
      editCleanBtn.addEventListener("click", startCleanEdit);
      saveCleanBtn.addEventListener("click", saveCleanText);
      cancelCleanBtn.addEventListener("click", cancelCleanEdit);
      rulesDrop.addEventListener("input", scheduleRulesSave);
      rulesCutoff.addEventListener("input", scheduleRulesSave);
      rulesRemove.addEventListener("input", scheduleRulesSave);
      rulesReplace.addEventListener("change", scheduleRulesSave);
      bookmarkBtn.addEventListener("click", () => {
        bookmarkPanel.classList.toggle("open");
      });
      bookmarkList.addEventListener("click", (event) => {
        const target = event.target;
        if (!target || !target.dataset || !target.dataset.action) {
          return;
        }
        const action = target.dataset.action;
        const index = parseInt(target.dataset.index, 10);
        if (Number.isNaN(index)) {
          return;
        }
        if (action === "play" || action === "play-furthest") {
          jumpToIndex(index, true);
          bookmarkPanel.classList.remove("open");
          return;
        }
        if (action === "remove") {
          removeBookmark(index);
          updateMarks();
          setStatus("Bookmark removed.");
        }
      });
      saveBookmarkBtn.addEventListener("click", () => {
        if (!state.queue.length) {
          return;
        }
        addBookmark(state.currentQueueIndex);
        updateMarks();
        setStatus("Bookmark saved.");
      });
      ttsToggle.addEventListener("click", () => {
        ttsPanel.classList.toggle("collapsed");
        ttsToggle.textContent = ttsPanel.classList.contains("collapsed")
          ? "Expand"
          : "Collapse";
        localStorage.setItem(
          "ptts.ttsCollapsed",
          ttsPanel.classList.contains("collapsed") ? "1" : "0"
        );
      });
      function handleEnded(event) {
        if (event.target !== currentAudio) {
          return;
        }
        playIndex(state.currentQueueIndex + 1);
      }
      audio.addEventListener("ended", handleEnded);
      audioNext.addEventListener("ended", handleEnded);

      speedBtn.addEventListener("click", () => {
        const steps = [0.8, 1.0, 1.2, 1.4, 1.6, 1.8, 2.0];
        const current = state.playbackRate || 1.0;
        const idx = steps.findIndex((val) => Math.abs(val - current) < 0.01);
        const next = idx === -1 ? 1.0 : steps[(idx + 1) % steps.length];
        setSpeedRate(next);
      });
      jumpShelf.addEventListener("click", scrollToBookSection);

      chapterText.addEventListener("click", (event) => {
        const target = event.target;
        if (target && target.classList.contains("chunk")) {
          const index = parseInt(target.dataset.queueIndex, 10);
          if (!Number.isNaN(index)) {
            playIndex(index);
          }
        }
      });
      updateMergeButtonState();
      updateClearButtonState();
      loadSettings();
      loadVoices();
      readUrlState();
      loadBooks();
    </script>
  </body>
</html>
