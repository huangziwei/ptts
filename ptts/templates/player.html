<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>pTTS player</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Fraunces:opsz,wght@9..144,600&family=Source+Serif+4:wght@400;600&family=Work+Sans:wght@400;600&display=swap");

      :root {
        --bg: #f6f1ea;
        --panel: #fffaf2;
        --panel-2: #f1e8dc;
        --ink: #2c2620;
        --muted: #7b7066;
        --accent: #1d7f6e;
        --accent-2: #e07a5f;
        --highlight: #fff0c2;
        --shadow: 0 12px 30px rgba(32, 28, 24, 0.15);
        --radius: 16px;
        --ui: "Work Sans", "Segoe UI", sans-serif;
        --read: "Source Serif 4", Georgia, serif;
        --title: "Fraunces", "Times New Roman", serif;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: var(--ui);
        color: var(--ink);
        background: linear-gradient(130deg, #f6f1ea 0%, #f2e8da 40%, #e9f2ef 100%);
      }

      .app {
        display: grid;
        grid-template-columns: 280px 1fr;
        min-height: 100vh;
      }

      .library {
        padding: 24px 20px;
        background: rgba(255, 250, 242, 0.9);
        border-right: 1px solid #eadfd2;
        position: sticky;
        top: 0;
        height: 100vh;
        overflow-y: auto;
        animation: fade-up 0.6s ease;
      }

      .brand {
        font-family: var(--title);
        font-size: 22px;
        letter-spacing: 0.5px;
        margin-bottom: 8px;
      }

      .root-path {
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 16px;
      }

      .book-list {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .book-card {
        display: grid;
        grid-template-columns: 52px 1fr;
        gap: 12px;
        padding: 10px;
        border-radius: 14px;
        border: 1px solid #eadfd2;
        background: #fffdf9;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease, border 0.2s ease;
      }

      .book-card:hover {
        transform: translateY(-2px);
        box-shadow: var(--shadow);
      }

      .book-card.active {
        border-color: var(--accent);
        box-shadow: 0 10px 24px rgba(29, 127, 110, 0.18);
      }

      .book-cover {
        width: 52px;
        height: 70px;
        border-radius: 10px;
        background: linear-gradient(150deg, #f2cc8f, #e07a5f);
        overflow: hidden;
      }

      .book-cover img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .book-meta h4 {
        margin: 0 0 4px;
        font-size: 14px;
        font-weight: 600;
      }

      .book-meta p {
        margin: 0;
        font-size: 12px;
        color: var(--muted);
      }

      .reader {
        padding: 28px 18px 120px;
        animation: fade-up 0.6s ease;
      }

      .reader-header {
        display: flex;
        gap: 20px;
        align-items: center;
        margin-bottom: 24px;
      }

      .tts-panel {
        background: var(--panel);
        border-radius: var(--radius);
        padding: 16px 18px;
        border: 1px solid #eadfd2;
        margin-bottom: 24px;
        box-shadow: var(--shadow);
      }

      .tts-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      .tts-toggle {
        border: 1px solid #d8caba;
        background: #fff;
        color: var(--ink);
        padding: 6px 12px;
        border-radius: 999px;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
      }

      .tts-panel.collapsed .tts-grid,
      .tts-panel.collapsed .tts-actions {
        display: none;
      }

      .tts-panel h3 {
        margin-bottom: 6px; 
        font-size: 13px;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: var(--muted);
      }

      .tts-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 12px;
        margin-bottom: 12px;
      }

      .tts-field label {
        display: block;
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 4px;
      }

      .tts-field input,
      .tts-field select {
        width: 100%;
        padding: 8px 10px;
        border-radius: 10px;
        border: 1px solid #d8caba;
        font-family: var(--ui);
      }

      .tts-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        align-items: center;
        margin-bottom: 12px;
      }

      .tts-actions label {
        font-size: 13px;
        color: var(--muted);
        display: flex;
        gap: 6px;
        align-items: center;
      }

      .progress-track {
        width: 100%;
        height: 10px;
        background: #efe5d8;
        border-radius: 999px;
        overflow: hidden;
      }

      .progress-fill {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, var(--accent), var(--accent-2));
        transition: width 0.3s ease;
      }

      .progress-text {
        margin-top: 8px;
        font-size: 13px;
        color: var(--muted);
      }

      .progress-detail {
        margin-top: 4px;
        font-size: 12px;
        color: #8a7a6e;
      }

      .cover-large {
        width: 120px;
        height: 160px;
        border-radius: 16px;
        background: linear-gradient(160deg, #f2cc8f, #e07a5f);
        overflow: hidden;
        box-shadow: var(--shadow);
      }

      .cover-large img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .book-title {
        font-family: var(--title);
        font-size: 30px;
        margin: 0 0 8px;
      }

      .book-subtitle {
        margin: 0 0 4px;
        color: var(--muted);
        font-size: 14px;
      }

      .reader-body {
        display: grid;
        grid-template-columns: 230px 1fr;
        gap: 24px;
        align-items: start;
      }

      .toc {
        background: var(--panel);
        border-radius: var(--radius);
        padding: 14px;
        border: 1px solid #eadfd2;
        max-height: calc(100vh - 320px);
        overflow-y: auto;
      }

      .toc h3 {
        font-size: 13px;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: var(--muted);
        margin: 0 0 10px;
      }

      .toc-item {
        padding: 8px 10px;
        border-radius: 10px;
        margin-bottom: 6px;
        cursor: pointer;
        transition: background 0.2s ease;
      }

      .toc-item.active {
        background: #f2e2c7;
        color: #3a2e22;
      }

      .toc-item small {
        display: block;
        color: var(--muted);
        font-size: 11px;
      }

      .text-pane {
        background: rgba(255, 255, 255, 0.9);
        border-radius: 22px;
        padding: 22px;
        box-shadow: var(--shadow);
        min-height: 300px;
      }

      .chapter-title {
        font-family: var(--title);
        font-size: 22px;
        margin: 0 0 14px;
      }

      .chapter-text {
        font-family: var(--read);
        font-size: 18px;
        line-height: 1.7;
        white-space: pre-line;
      }

      .chapter-text p {
        margin: 0 0 16px;
      }

      .chunk {
        padding: 2px 1px;
        border-radius: 6px;
        transition: background 0.2s ease, color 0.2s ease;
      }

      .chunk.last-played {
        background: #fff4d6;
      }

      .chunk.active {
        background: var(--highlight);
      }

      .chunk.waiting {
        background: #fde2cf;
      }

      .chunk.played {
        color: #897d72;
      }

      .empty-state {
        color: var(--muted);
        font-size: 15px;
      }

      .player-bar {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: #fffdf9;
        border-top: 1px solid #eadfd2;
        box-shadow: 0 -8px 20px rgba(30, 25, 20, 0.12);
        padding: 12px 20px;
        display: flex;
        align-items: center;
        gap: 16px;
        flex-wrap: wrap;
      }

      .player-controls {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .btn {
        border: 1px solid #d8caba;
        background: #fff;
        color: var(--ink);
        padding: 8px 14px;
        border-radius: 999px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s ease, background 0.2s ease;
      }

      .btn.primary {
        background: var(--accent);
        border-color: var(--accent);
        color: #fff;
      }

      .btn:active {
        transform: scale(0.98);
      }

      .status {
        flex: 1;
        color: var(--muted);
        font-size: 13px;
      }

      .marks {
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
        font-size: 12px;
        color: var(--muted);
        position: relative;
      }

      .bookmark-panel {
        position: absolute;
        bottom: 52px;
        left: 0;
        width: 280px;
        background: #fffdf9;
        border: 1px solid #eadfd2;
        border-radius: 16px;
        box-shadow: 0 16px 30px rgba(30, 25, 20, 0.18);
        padding: 12px;
        display: none;
        z-index: 20;
      }

      .bookmark-panel.open {
        display: block;
      }

      .bookmark-title {
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 8px;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .bookmark-list {
        max-height: 220px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-bottom: 12px;
      }

      .bookmark-item {
        background: #f7efe3;
        border-radius: 12px;
        padding: 8px 10px;
        display: grid;
        gap: 8px;
      }

      .bookmark-item span {
        font-size: 12px;
        color: #50463f;
      }

      .bookmark-actions {
        display: flex;
        gap: 8px;
      }

      .btn.small {
        padding: 4px 10px;
        font-size: 11px;
      }

      .bookmark-empty {
        font-size: 12px;
        color: var(--muted);
        padding: 6px 4px;
      }

      .marks span {
        max-width: 220px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .speed {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 13px;
      }

      .speed input[type="range"] {
        accent-color: var(--accent-2);
      }

      @keyframes fade-up {
        from {
          opacity: 0;
          transform: translateY(12px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @media (max-width: 980px) {
        .app {
          grid-template-columns: 1fr;
        }
        .library {
          position: relative;
          height: auto;
          border-right: none;
          border-bottom: 1px solid #eadfd2;
        }
        .reader-body {
          grid-template-columns: 1fr;
        }
        .toc {
          max-height: none;
        }
      }

      @media (max-width: 720px) {
        .reader-header {
          flex-direction: column;
          align-items: flex-start;
        }
        .player-bar {
          flex-wrap: wrap;
          gap: 10px;
        }
        .status {
          flex: 1 1 100%;
        }
      }
    </style>
  </head>
  <body>
    <div class="app">
      <aside class="library">
        <div class="brand">pTTS player</div>
        <div class="root-path">Root: {{ root_dir }}</div>
        <div id="bookList" class="book-list"></div>
      </aside>
      <main class="reader">
        <div class="reader-header">
          <div class="cover-large" id="coverLarge"></div>
          <div>
            <h1 class="book-title" id="bookTitle">Select a book</h1>
            <p class="book-subtitle" id="bookMeta">No book loaded.</p>
            <p class="book-subtitle" id="bookStatus"></p>
          </div>
        </div>
        <section class="tts-panel" id="ttsPanel">
          <div class="tts-header">
            <h3>Text To Speech</h3>
            <button class="tts-toggle" id="ttsToggle">Collapse</button>
          </div>
          <div class="tts-grid">
            <div class="tts-field">
              <label for="voiceInput">Voice (wav path)</label>
              <input id="voiceInput" type="text" placeholder="voices/ray.wav" />
            </div>
            <div class="tts-field">
              <label for="maxCharsInput">Max chars</label>
              <input id="maxCharsInput" type="number" min="100" step="50" value="800" />
            </div>
            <div class="tts-field">
              <label for="padMsInput">Pad ms</label>
              <input id="padMsInput" type="number" min="0" step="10" value="150" />
            </div>
            <div class="tts-field">
              <label for="chunkModeSelect">Chunk mode</label>
              <select id="chunkModeSelect">
                <option value="sentence">Sentence</option>
                <option value="packed">Packed</option>
              </select>
            </div>
          </div>
          <div class="tts-actions">
            <button class="btn primary" id="startTts">Start TTS</button>
            <label><input id="rechunkInput" type="checkbox" /> Rechunk</label>
          </div>
          <div class="progress-track">
            <div class="progress-fill" id="progressFill"></div>
          </div>
          <div class="progress-text" id="progressText">Idle.</div>
          <div class="progress-detail" id="progressDetail"></div>
        </section>
        <div class="reader-body">
          <aside class="toc">
            <h3>Chapters</h3>
            <div id="chapterList"></div>
          </aside>
          <section class="text-pane">
            <h2 class="chapter-title" id="chapterTitle">Waiting for a book...</h2>
            <div class="chapter-text" id="chapterText">
              <p class="empty-state">Pick a book on the left to start.</p>
            </div>
          </section>
        </div>
      </main>
    </div>

    <div class="player-bar">
      <div class="player-controls">
        <button class="btn" id="prevBtn">Prev</button>
        <button class="btn primary" id="playBtn">Play</button>
        <button class="btn" id="nextBtn">Next</button>
      </div>
      <div class="status" id="status">Last: —</div>
      <div class="marks">
        <button class="btn" id="bookmarkBtn">Bookmarks</button>
        <div class="bookmark-panel" id="bookmarkPanel">
          <div class="bookmark-title">Bookmarks</div>
          <div class="bookmark-list" id="bookmarkList"></div>
          <button class="btn" id="saveBookmarkBtn">Save current</button>
        </div>
      </div>
      <div class="speed">
        Speed
        <input id="speedInput" type="range" min="0.8" max="1.4" step="0.05" value="1" />
        <span id="speedValue">1.0x</span>
      </div>
    </div>

    <audio id="audio"></audio>

    <script>
      const state = {
        books: [],
        book: null,
        chapters: [],
        chapterMap: {},
        queue: [],
        chapterOffsets: {},
        currentChapterId: null,
        currentQueueIndex: 0,
        activeQueueIndex: null,
        waitingFor: null,
        waitTimer: null,
        audioBase: "",
        synthTimer: null,
        loadingBook: false,
        initialBookId: null,
        initialChapterId: null,
        pendingManifestRefresh: false,
        needsRechunk: false,
        synthRunning: false,
        statusMode: "idle",
        playbackSaveTimer: null,
        playback: {
          lastPlayed: null,
          bookmarks: [],
        },
      };

      const bookList = document.getElementById("bookList");
      const chapterList = document.getElementById("chapterList");
      const chapterTitle = document.getElementById("chapterTitle");
      const chapterText = document.getElementById("chapterText");
      const bookTitle = document.getElementById("bookTitle");
      const bookMeta = document.getElementById("bookMeta");
      const bookStatus = document.getElementById("bookStatus");
      const coverLarge = document.getElementById("coverLarge");
      const status = document.getElementById("status");
      const playBtn = document.getElementById("playBtn");
      const prevBtn = document.getElementById("prevBtn");
      const nextBtn = document.getElementById("nextBtn");
      const speedInput = document.getElementById("speedInput");
      const speedValue = document.getElementById("speedValue");
      const audio = document.getElementById("audio");
      const bookmarkBtn = document.getElementById("bookmarkBtn");
      const bookmarkList = document.getElementById("bookmarkList");
      const bookmarkPanel = document.getElementById("bookmarkPanel");
      const saveBookmarkBtn = document.getElementById("saveBookmarkBtn");
      const voiceInput = document.getElementById("voiceInput");
      const maxCharsInput = document.getElementById("maxCharsInput");
      const padMsInput = document.getElementById("padMsInput");
      const chunkModeSelect = document.getElementById("chunkModeSelect");
      const rechunkInput = document.getElementById("rechunkInput");
      const startTts = document.getElementById("startTts");
      const progressFill = document.getElementById("progressFill");
      const progressText = document.getElementById("progressText");
      const progressDetail = document.getElementById("progressDetail");
      const ttsPanel = document.getElementById("ttsPanel");
      const ttsToggle = document.getElementById("ttsToggle");

      function setStatus(message, mode = "message") {
        status.textContent = message;
        state.statusMode = mode;
      }

      function pad6(num) {
        return String(num).padStart(6, "0");
      }

      function readUrlState() {
        const params = new URLSearchParams(window.location.search);
        state.initialBookId = params.get("book");
        state.initialChapterId = params.get("chapter");
      }

      function updateUrl(bookId, chapterId) {
        const params = new URLSearchParams();
        if (bookId) {
          params.set("book", bookId);
        }
        if (chapterId) {
          params.set("chapter", chapterId);
        }
        const query = params.toString();
        const next = query ? `/?${query}` : "/";
        history.replaceState(null, "", next);
      }

      function getBookmarks() {
        return state.playback.bookmarks || [];
      }

      function saveBookmarks(bookmarks, persist = true) {
        state.playback.bookmarks = Array.isArray(bookmarks) ? bookmarks : [];
        if (persist) {
          schedulePlaybackSave();
        }
      }

      function getLastPlayed() {
        const value = state.playback.lastPlayed;
        return typeof value === "number" ? value : null;
      }

      function setLastPlayed(index, persist = true) {
        state.playback.lastPlayed =
          typeof index === "number" ? index : null;
        if (persist) {
          schedulePlaybackSave();
        }
      }

      async function fetchJson(url, options = {}) {
        const opts = { cache: "no-store", ...options };
        if (options.headers) {
          opts.headers = { ...options.headers };
        }
        const res = await fetch(url, opts);
        if (!res.ok) {
          throw new Error(`Request failed: ${res.status}`);
        }
        return res.json();
      }

      function schedulePlaybackSave() {
        if (!state.book) {
          return;
        }
        if (state.playbackSaveTimer) {
          clearTimeout(state.playbackSaveTimer);
        }
        state.playbackSaveTimer = setTimeout(() => {
          persistPlayback();
        }, 500);
      }

      async function persistPlayback(payload) {
        if (!state.book) {
          return;
        }
        const body = payload || {
          last_played: getLastPlayed(),
          bookmarks: getBookmarks(),
        };
        try {
          await fetchJson(
            `/api/playback?book_id=${encodeURIComponent(state.book.id)}`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(body),
            }
          );
        } catch (err) {
          console.warn("Failed to persist playback state.", err);
        }
      }

      async function loadPlayback() {
        if (!state.book) {
          return;
        }
        try {
          const data = await fetchJson(
            `/api/playback?book_id=${encodeURIComponent(state.book.id)}`
          );
          const last =
            typeof data.last_played === "number" ? data.last_played : null;
          const marks = Array.isArray(data.bookmarks) ? data.bookmarks : [];
          setLastPlayed(last, false);
          saveBookmarks(marks, false);
          if (!data.exists) {
            await persistPlayback({
              last_played: last,
              bookmarks: marks,
            });
          }
        } catch (err) {
          console.warn("Failed to load playback state.", err);
        }
      }

      async function loadBooks() {
        try {
          const data = await fetchJson("/api/books");
          state.books = data.books || [];
          renderBooks();
          if (state.initialBookId && !state.book) {
            const initial = state.initialBookId;
            const chapter = state.initialChapterId;
            state.initialBookId = null;
            state.initialChapterId = null;
            await selectBook(initial, chapter);
          }
        } catch (err) {
          bookList.innerHTML = "<p class=\"empty-state\">Failed to load books.</p>";
        }
      }

      function loadSettings() {
        if (!voiceInput.value) {
          voiceInput.value = "voices/ray.wav";
        }
        if (!maxCharsInput.value) {
          maxCharsInput.value = "800";
        }
        if (!padMsInput.value) {
          padMsInput.value = "150";
        }
        if (!chunkModeSelect.value) {
          chunkModeSelect.value = "sentence";
        }
        const collapsed = localStorage.getItem("ptts.ttsCollapsed") === "1";
        if (collapsed) {
          ttsPanel.classList.add("collapsed");
          ttsToggle.textContent = "Expand";
        }
      }

      function saveSettings() {
        voiceInput.value = voiceInput.value.trim();
      }

      function renderBooks() {
        bookList.innerHTML = "";
        if (!state.books.length) {
          bookList.innerHTML = "<p class=\"empty-state\">No books found.</p>";
          return;
        }
        state.books.forEach((book) => {
          const card = document.createElement("div");
          card.className = "book-card";
          if (state.book && state.book.id === book.id) {
            card.classList.add("active");
          }
          card.innerHTML = `
            <div class="book-cover">${book.cover_url ? `<img src="${book.cover_url}" alt="Cover" />` : ""}</div>
            <div class="book-meta">
              <h4>${book.title}</h4>
              <p>${(book.authors || []).join(", ")}</p>
              <p>${book.has_audio ? "Audio ready" : "No audio yet"}</p>
            </div>
          `;
          card.addEventListener("click", () => selectBook(book.id));
          bookList.appendChild(card);
        });
      }

      async function selectBook(bookId, chapterId) {
        state.loadingBook = true;
        try {
          const data = await fetchJson(`/api/books/${bookId}`);
          state.book = data.book;
          state.chapters = data.chapters || [];
          state.playback = { lastPlayed: null, bookmarks: [] };
          state.chapterMap = {};
          state.chapters.forEach((chapter) => {
            if (chapter && chapter.id) {
              state.chapterMap[chapter.id] = chapter;
            }
          });
          state.audioBase = data.audio_base || "";
          state.currentQueueIndex = 0;
          state.activeQueueIndex = null;
          state.waitingFor = null;
          if (state.waitTimer) {
            clearTimeout(state.waitTimer);
          }
          await loadPlayback();
          buildQueue();
          const hasSpanData = state.chapters.some(
            (chapter) => (chapter.chunk_spans || []).length > 0
          );
          state.needsRechunk = state.chapters.length > 0 && !hasSpanData;
          renderBooks();
          renderBookHeader();
          renderChapters();
          if (state.chapters.length) {
            const desired = chapterId || state.chapters[0].id;
            renderChapter(desired);
            const offset = state.chapterOffsets[desired];
            state.currentQueueIndex =
              typeof offset === "number" ? offset : state.currentQueueIndex;
            setIdleStatus();
            if (state.needsRechunk) {
              setStatus("Manifest missing chunk spans. Run `ptts synth --rechunk`.");
            }
          } else {
            chapterTitle.textContent = "No audio yet";
            chapterText.innerHTML =
              "<p class=\"empty-state\">Run `ptts synth` to generate audio chunks.</p>";
            setStatus("No audio available.");
          }
          updateUrl(state.book.id, state.currentChapterId);
          startSynthPolling();
        } catch (err) {
          setStatus("Failed to load book.");
        } finally {
          state.loadingBook = false;
        }
      }

      function renderBookHeader() {
        if (!state.book) {
          return;
        }
        bookTitle.textContent = state.book.title || state.book.id;
        const author = (state.book.authors || []).join(", ");
        const year = state.book.year ? ` (${state.book.year})` : "";
        bookMeta.textContent = `${author}${year}`;
        bookStatus.textContent = state.book.has_audio
          ? "Audio manifest loaded."
          : "Waiting for audio.";
        if (state.book.cover_url) {
          coverLarge.innerHTML = `<img src="${state.book.cover_url}" alt="Cover" />`;
        } else {
          coverLarge.innerHTML = "";
        }
      }

      function snippet(text, length) {
        if (!text) {
          return "";
        }
        const cleaned = text.replace(/\s+/g, " ").trim();
        return cleaned.slice(0, length);
      }

      function getChapterById(chapterId) {
        return state.chapterMap[chapterId] || null;
      }

      function getChunkSpan(item) {
        const chapter = getChapterById(item.chapterId);
        if (!chapter) {
          return null;
        }
        const spans = chapter.chunk_spans || [];
        return spans[item.chunkIndex] || null;
      }

      function getChunkText(item) {
        const chapter = getChapterById(item.chapterId);
        if (!chapter) {
          return "";
        }
        const span = getChunkSpan(item);
        if (!span || !chapter.clean_text) {
          return "";
        }
        return chapter.clean_text.slice(span[0], span[1]);
      }

      function splitParagraphSpans(text) {
        const spans = [];
        const re = /\n\s*\n+/g;
        let start = 0;
        let match;
        while ((match = re.exec(text)) !== null) {
          const end = match.index;
          let paraStart = start;
          let paraEnd = end;
          while (paraStart < paraEnd && /\s/.test(text[paraStart])) {
            paraStart += 1;
          }
          while (paraEnd > paraStart && /\s/.test(text[paraEnd - 1])) {
            paraEnd -= 1;
          }
          if (paraStart < paraEnd) {
            spans.push([paraStart, paraEnd]);
          }
          start = match.index + match[0].length;
        }
        let tailStart = start;
        let tailEnd = text.length;
        while (tailStart < tailEnd && /\s/.test(text[tailStart])) {
          tailStart += 1;
        }
        while (tailEnd > tailStart && /\s/.test(text[tailEnd - 1])) {
          tailEnd -= 1;
        }
        if (tailStart < tailEnd) {
          spans.push([tailStart, tailEnd]);
        }
        return spans;
      }

      function describeIndex(index) {
        const item = state.queue[index];
        if (!item) {
          return "—";
        }
        const chapterNum = item.chapterIndex + 1;
        const chunkNum = item.chunkIndex + 1;
        const snip = snippet(getChunkText(item), 10);
        return snip ? `${chapterNum}/${chunkNum} ${snip}` : `${chapterNum}/${chunkNum}`;
      }

      function idleStatusText() {
        const lastIndex = getLastPlayed();
        if (lastIndex === null) {
          return "Last: —";
        }
        return `Last: ${describeIndex(lastIndex)}`;
      }

      function setIdleStatus() {
        setStatus(idleStatusText(), "idle");
      }

      function applyLastPlayedHighlight() {
        const prev = chapterText.querySelector(".chunk.last-played");
        if (prev) {
          prev.classList.remove("last-played");
        }
        const lastIndex = getLastPlayed();
        if (lastIndex === null) {
          return;
        }
        const item = state.queue[lastIndex];
        if (!item || item.chapterId !== state.currentChapterId) {
          return;
        }
        const span = chapterText.querySelector(
          `.chunk[data-queue-index="${lastIndex}"]`
        );
        if (span) {
          span.classList.add("last-played");
        }
      }

      function updateMarks() {
        if (!state.book) {
          bookmarkList.innerHTML = "<div class=\"bookmark-empty\">No bookmarks yet.</div>";
          saveBookmarkBtn.disabled = true;
          return;
        }
        const bookmarks = getBookmarks();
        bookmarkList.innerHTML = "";
        if (!bookmarks.length) {
          bookmarkList.innerHTML = "<div class=\"bookmark-empty\">No bookmarks yet.</div>";
        } else {
          bookmarks.forEach((entry) => {
            const item = document.createElement("div");
            item.className = "bookmark-item";
            const label = describeIndex(entry.index);
            item.innerHTML = `
              <span>${label}</span>
              <div class="bookmark-actions">
                <button class="btn small" data-action="play" data-index="${entry.index}">Play</button>
                <button class="btn small" data-action="remove" data-index="${entry.index}">Remove</button>
              </div>
            `;
            bookmarkList.appendChild(item);
          });
        }
        saveBookmarkBtn.disabled = !state.queue.length;
        if (state.statusMode === "idle") {
          setIdleStatus();
        }
      }

      function jumpToIndex(index, autoplay) {
        if (index === null || index < 0 || index >= state.queue.length) {
          return;
        }
        state.currentQueueIndex = index;
        setActiveChunk(index, false);
        if (autoplay) {
          playIndex(index);
        } else {
          const item = state.queue[index];
          if (item && state.currentChapterId !== item.chapterId) {
            renderChapter(item.chapterId);
          }
        }
        updateMarks();
      }

      function addBookmark(index) {
        if (index === null || index < 0 || index >= state.queue.length) {
          return;
        }
        const bookmarks = getBookmarks();
        if (bookmarks.some((entry) => entry.index === index)) {
          return;
        }
        bookmarks.push({
          index,
          label: describeIndex(index),
          created_at: Date.now(),
        });
        saveBookmarks(bookmarks);
      }

      function removeBookmark(index) {
        const bookmarks = getBookmarks();
        const next = bookmarks.filter((entry) => entry.index !== index);
        saveBookmarks(next);
      }

      function startSynthPolling() {
        if (state.synthTimer) {
          clearInterval(state.synthTimer);
        }
        state.synthTimer = setInterval(loadSynthStatus, 2000);
        loadSynthStatus();
      }

      async function loadSynthStatus() {
        if (!state.book) {
          return;
        }
        try {
          const data = await fetchJson(
            `/api/synth/status?book_id=${encodeURIComponent(state.book.id)}`
          );
          updateSynthUI(data);
          if (
            !state.loadingBook &&
            data.progress &&
            data.progress.total > 0 &&
            (state.pendingManifestRefresh || !state.chapters.length)
          ) {
            await selectBook(state.book.id);
            state.pendingManifestRefresh = false;
          }
        } catch (err) {
          progressText.textContent = "Unable to load TTS status.";
        }
      }

      function updateSynthUI(data) {
        state.synthRunning = !!data.running;
        startTts.textContent = state.synthRunning ? "Stop TTS" : "Start TTS";
        const stage = data.stage || "idle";
        const progress = data.progress;
        if (stage === "chunking") {
          progressFill.style.width = "0%";
          progressText.textContent = "Chunking text...";
          progressDetail.textContent = "Preparing manifest and spans.";
        } else if (!progress) {
          progressFill.style.width = "0%";
          progressText.textContent = "Idle.";
          progressDetail.textContent = "";
        } else {
          progressFill.style.width = `${progress.percent}%`;
          progressText.textContent = `${progress.done} / ${progress.total} chunks (${progress.percent}%).`;
          if (progress.current) {
            progressDetail.textContent = `${progress.current.chapter_title} · chunk ${progress.current.chunk_index} of ${progress.current.chunk_total}`;
          } else {
            progressDetail.textContent = progress.total ? "Completed." : "Idle.";
          }
        }

        if (stage === "chunking") {
          bookStatus.textContent = "Chunking text...";
        } else if (stage === "synthesizing") {
          bookStatus.textContent = "Synthesizing audio...";
        } else if (stage === "done") {
          bookStatus.textContent = "Audio ready.";
        } else {
          bookStatus.textContent = state.book && state.book.has_audio ? "Audio ready." : "Waiting for audio.";
        }
        startTts.disabled = false;
      }

      async function startSynth() {
        if (!state.book) {
          return;
        }
        saveSettings();
        const maxChars = parseInt(maxCharsInput.value, 10);
        const padMs = parseInt(padMsInput.value, 10);
        const payload = {
          book_id: state.book.id,
          voice: voiceInput.value.trim(),
          max_chars: Number.isNaN(maxChars) ? 800 : maxChars,
          pad_ms: Number.isNaN(padMs) ? 150 : padMs,
          chunk_mode: chunkModeSelect.value,
          rechunk: rechunkInput.checked,
        };
        state.pendingManifestRefresh = payload.rechunk || !state.chapters.length;
        try {
          await fetchJson("/api/synth/start", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          setStatus("TTS started.");
          await loadSynthStatus();
        } catch (err) {
          setStatus("Failed to start TTS.");
        }
      }

      async function stopSynth() {
        if (!state.book) {
          return;
        }
        try {
          await fetchJson("/api/synth/stop", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ book_id: state.book.id }),
          });
          setStatus("TTS stopped.");
          await loadSynthStatus();
        } catch (err) {
          setStatus("Failed to stop TTS.");
        }
      }

      function toggleSynth() {
        if (state.synthRunning) {
          stopSynth();
        } else {
          startSynth();
        }
      }

      function buildQueue() {
        state.queue = [];
        state.chapterOffsets = {};
        let offset = 0;
        state.chapters.forEach((chapter, chapterIndex) => {
          state.chapterOffsets[chapter.id] = offset;
          const spans = chapter.chunk_spans || [];
          spans.forEach((_span, chunkIndex) => {
            state.queue.push({
              chapterId: chapter.id,
              chapterIndex,
              chunkIndex,
            });
          });
          offset += spans.length;
        });
      }

      function renderChapters() {
        chapterList.innerHTML = "";
        if (!state.chapters.length) {
          chapterList.innerHTML = "<p class=\"empty-state\">No chapters yet.</p>";
          return;
        }
        state.chapters.forEach((chapter) => {
          const item = document.createElement("div");
          item.className = "toc-item";
          if (chapter.id === state.currentChapterId) {
            item.classList.add("active");
          }
          item.innerHTML = `
            <div>${chapter.title}</div>
            <small>${chapter.chunk_count} chunks</small>
          `;
          item.addEventListener("click", () => {
            renderChapter(chapter.id);
            state.currentQueueIndex = state.chapterOffsets[chapter.id] || 0;
            setIdleStatus();
            updateUrl(state.book ? state.book.id : null, chapter.id);
          });
          chapterList.appendChild(item);
        });
      }

      function renderChapter(chapterId) {
        const chapter = getChapterById(chapterId);
        if (!chapter) {
          return;
        }
        state.currentChapterId = chapter.id;
        chapterTitle.textContent = chapter.title;
        chapterText.innerHTML = "";
        const cleanText = chapter.clean_text || "";
        const spans = chapter.chunk_spans || [];
        const startIndex = state.chapterOffsets[chapter.id] || 0;
        const paragraphs = splitParagraphSpans(cleanText);
        let spanIndex = 0;

        if (!paragraphs.length) {
          chapterText.innerHTML = "<p class=\"empty-state\">No text available.</p>";
        } else {
          paragraphs.forEach(([paraStart, paraEnd]) => {
            const p = document.createElement("p");
            let cursor = paraStart;

            while (spanIndex < spans.length && spans[spanIndex][1] <= paraStart) {
              spanIndex += 1;
            }

            while (spanIndex < spans.length && spans[spanIndex][0] < paraEnd) {
              const spanEntry = spans[spanIndex];
              const spanStart = spanEntry[0];
              const spanEnd = spanEntry[1];
              if (spanStart > cursor) {
                p.appendChild(
                  document.createTextNode(cleanText.slice(cursor, spanStart))
                );
              }
              const span = document.createElement("span");
              span.className = "chunk";
              span.dataset.queueIndex = startIndex + spanIndex;
              span.textContent = cleanText.slice(spanStart, spanEnd);
              p.appendChild(span);
              cursor = spanEnd;
              spanIndex += 1;
            }

            if (cursor < paraEnd) {
              p.appendChild(
                document.createTextNode(cleanText.slice(cursor, paraEnd))
              );
            }
            chapterText.appendChild(p);
          });
        }
        renderChapters();
        applyLastPlayedHighlight();
        if (state.activeQueueIndex !== null) {
          const activeItem = state.queue[state.activeQueueIndex];
          if (activeItem && activeItem.chapterId === chapter.id) {
            setActiveChunk(state.activeQueueIndex, false);
          }
        }
        updateUrl(state.book ? state.book.id : null, chapter.id);
        updateMarks();
      }

      function setActiveChunk(index, waiting) {
        if (state.activeQueueIndex !== null) {
          const prev = chapterText.querySelector(
            `.chunk[data-queue-index="${state.activeQueueIndex}"]`
          );
          if (prev) {
            prev.classList.remove("active", "waiting");
            prev.classList.add("played");
          }
        }
        const item = state.queue[index];
        if (!item) {
          return;
        }
        if (state.currentChapterId !== item.chapterId) {
          renderChapter(item.chapterId);
        }
        const span = chapterText.querySelector(
          `.chunk[data-queue-index="${index}"]`
        );
        if (span) {
          span.classList.add(waiting ? "waiting" : "active");
          span.classList.remove(waiting ? "active" : "waiting");
          span.scrollIntoView({ block: "center", behavior: "smooth" });
        }
        state.activeQueueIndex = index;
        applyLastPlayedHighlight();
      }

      async function chunkExists(item) {
        const chunkNum = item.chunkIndex + 1;
        const url = `/api/chunk-status?book_id=${encodeURIComponent(
          state.book.id
        )}&chapter_id=${encodeURIComponent(
          item.chapterId
        )}&chunk=${chunkNum}`;
        const data = await fetchJson(url);
        return data.exists;
      }

      function chunkUrl(item) {
        const chunkNum = item.chunkIndex + 1;
        return `${state.audioBase}/${item.chapterId}/${pad6(chunkNum)}.wav`;
      }

      async function playIndex(index) {
        if (!state.queue.length) {
          return;
        }
        if (index < 0 || index >= state.queue.length) {
          setStatus("End of book.");
          audio.pause();
          return;
        }
        const item = state.queue[index];
        state.currentQueueIndex = index;
        setLastPlayed(index);
        setActiveChunk(index, true);
        setStatus(`Waiting for chunk ${index + 1} of ${state.queue.length}...`);
        updateMarks();

        let available = false;
        try {
          available = await chunkExists(item);
        } catch (err) {
          available = false;
        }

        if (!available) {
          waitForChunk(index);
          return;
        }

        if (state.waitTimer) {
          clearTimeout(state.waitTimer);
        }
        state.waitingFor = null;
        setActiveChunk(index, false);
        audio.src = chunkUrl(item);
        audio.playbackRate = parseFloat(speedInput.value);
        try {
          await audio.play();
          setStatus(
            `Playing ${item.chapterId} ${item.chunkIndex + 1} / ${state.queue.length}`
          );
          playBtn.textContent = "Pause";
        } catch (err) {
          setStatus("Press Play to start audio.");
        }
      }

      function waitForChunk(index) {
        state.waitingFor = index;
        if (state.waitTimer) {
          clearTimeout(state.waitTimer);
        }
        state.waitTimer = setTimeout(async () => {
          if (state.waitingFor !== index) {
            return;
          }
          await playIndex(index);
        }, 2000);
      }

      function togglePlay() {
        if (!state.queue.length) {
          return;
        }
        if (audio.paused) {
          const lastIndex = getLastPlayed();
          const startIndex = lastIndex === null ? 0 : lastIndex;
          playIndex(startIndex);
        } else {
          audio.pause();
          playBtn.textContent = "Play";
          setIdleStatus();
        }
      }

      function nextChunk() {
        playIndex(state.currentQueueIndex + 1);
      }

      function prevChunk() {
        playIndex(Math.max(0, state.currentQueueIndex - 1));
      }

      playBtn.addEventListener("click", togglePlay);
      prevBtn.addEventListener("click", prevChunk);
      nextBtn.addEventListener("click", nextChunk);
      startTts.addEventListener("click", toggleSynth);
      bookmarkBtn.addEventListener("click", () => {
        bookmarkPanel.classList.toggle("open");
      });
      bookmarkList.addEventListener("click", (event) => {
        const target = event.target;
        if (!target || !target.dataset || !target.dataset.action) {
          return;
        }
        const action = target.dataset.action;
        const index = parseInt(target.dataset.index, 10);
        if (Number.isNaN(index)) {
          return;
        }
        if (action === "play") {
          jumpToIndex(index, true);
          bookmarkPanel.classList.remove("open");
          return;
        }
        if (action === "remove") {
          removeBookmark(index);
          updateMarks();
          setStatus("Bookmark removed.");
        }
      });
      saveBookmarkBtn.addEventListener("click", () => {
        if (!state.queue.length) {
          return;
        }
        addBookmark(state.currentQueueIndex);
        updateMarks();
        setStatus("Bookmark saved.");
      });
      ttsToggle.addEventListener("click", () => {
        ttsPanel.classList.toggle("collapsed");
        ttsToggle.textContent = ttsPanel.classList.contains("collapsed")
          ? "Expand"
          : "Collapse";
        localStorage.setItem(
          "ptts.ttsCollapsed",
          ttsPanel.classList.contains("collapsed") ? "1" : "0"
        );
      });
      audio.addEventListener("ended", () => {
        playIndex(state.currentQueueIndex + 1);
      });

      speedInput.addEventListener("input", () => {
        const val = parseFloat(speedInput.value);
        speedValue.textContent = `${val.toFixed(2)}x`;
        audio.playbackRate = val;
      });

      chapterText.addEventListener("click", (event) => {
        const target = event.target;
        if (target && target.classList.contains("chunk")) {
          const index = parseInt(target.dataset.queueIndex, 10);
          if (!Number.isNaN(index)) {
            playIndex(index);
          }
        }
      });

      loadSettings();
      readUrlState();
      loadBooks();
    </script>
  </body>
</html>
