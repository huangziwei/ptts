<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>pTTS player</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Fraunces:opsz,wght@9..144,600&family=Source+Serif+4:wght@400;600&family=Work+Sans:wght@400;600&display=swap");

      :root {
        color-scheme: light;
        --bg: #f6f1ea;
        --panel: #fffaf2;
        --panel-2: #f1e8dc;
        --ink: #2c2620;
        --muted: #7b7066;
        --accent: #1d7f6e;
        --accent-2: #e07a5f;
        --accent-ink: #fff;
        --highlight: #fff0c2;
        --shadow: 0 12px 30px rgba(32, 28, 24, 0.15);
        --shadow-accent: 0 10px 24px rgba(29, 127, 110, 0.18);
        --shadow-pop: 0 12px 24px rgba(30, 25, 20, 0.18);
        --shadow-float: 0 8px 18px rgba(32, 28, 24, 0.2);
        --shadow-top: 0 -8px 20px rgba(30, 25, 20, 0.12);
        --bg-gradient: linear-gradient(130deg, #f6f1ea 0%, #f2e8da 40%, #e9f2ef 100%);
        --line: #eadfd2;
        --line-strong: #d8caba;
        --surface: #fffdf9;
        --surface-2: #fff;
        --surface-muted: #f2e2c7;
        --surface-soft: #efe5d8;
        --surface-soft-2: #e6d9cb;
        --surface-highlight: #fff4d6;
        --surface-wait: #fde2cf;
        --surface-drag: #f0faf7;
        --text-soft: #8a7a6e;
        --text-dim: #897d72;
        --active-ink: #3a2e22;
        --danger: #b04838;
        --danger-ink: #fff;
        --success-bg: #e4f3ee;
        --success-border: #a6d2c8;
        --success-ink: #1d7f6e;
        --subtle-bg: #faf6f0;
        --subtle-border: #e6d9cb;
        --subtle-ink: #6f6358;
        --bookmark-bg: #f7efe3;
        --bookmark-ink: #50463f;
        --mark-bg: #ffe4a8;
        --cover-gradient: linear-gradient(150deg, #f2cc8f, #e07a5f);
        --cover-gradient-large: linear-gradient(160deg, #f2cc8f, #e07a5f);
        --text-pane-bg: rgba(255, 255, 255, 0.9);
        --library-bg: rgba(255, 250, 242, 0.9);
        --player-bar-bg: #fffdf9;
        --jump-bg: rgba(123, 112, 102, 0.75);
        --jump-border: rgba(123, 112, 102, 0.6);
        --jump-hover-bg: rgba(123, 112, 102, 0.9);
        --radius: 16px;
        --cover-thumb-height: 70px;
        --ui: "Work Sans", "Segoe UI", sans-serif;
        --read: "Source Serif 4", Georgia, serif;
        --title: "Fraunces", "Times New Roman", serif;
      }

      @media (prefers-color-scheme: dark) {
        :root {
          color-scheme: dark;
          --bg: #14110e;
          --panel: #1b1814;
          --panel-2: #221e19;
          --ink: #f5efe6;
          --muted: #b9ada0;
          --accent: #2fa88f;
          --accent-2: #f0a269;
          --accent-ink: #fff;
          --highlight: #3b2a1c;
          --shadow: 0 16px 36px rgba(0, 0, 0, 0.35);
          --shadow-accent: 0 12px 26px rgba(47, 168, 143, 0.35);
          --shadow-pop: 0 18px 36px rgba(0, 0, 0, 0.45);
          --shadow-float: 0 10px 22px rgba(0, 0, 0, 0.5);
          --shadow-top: 0 -10px 26px rgba(0, 0, 0, 0.55);
          --bg-gradient: linear-gradient(130deg, #14110e 0%, #1a1613 45%, #0f1a17 100%);
          --line: #2c2621;
          --line-strong: #3b332c;
          --surface: #1c1916;
          --surface-2: #241f1a;
          --surface-muted: #2b241e;
          --surface-soft: #241f1a;
          --surface-soft-2: #312a23;
          --surface-highlight: #2c241b;
          --surface-wait: #2f211b;
          --surface-drag: #1b2a26;
          --text-soft: #a79c90;
          --text-dim: #7f756a;
          --active-ink: #f4eadc;
          --danger: #d56a59;
          --danger-ink: #fff;
          --success-bg: #1c3a32;
          --success-border: #2f5b51;
          --success-ink: #bfe9de;
          --subtle-bg: #221d19;
          --subtle-border: #353029;
          --subtle-ink: #c0b6ab;
          --bookmark-bg: #1f1b17;
          --bookmark-ink: #d8cec2;
          --mark-bg: #4b3520;
          --cover-gradient: linear-gradient(150deg, #8a5a32, #d17c46);
          --cover-gradient-large: linear-gradient(160deg, #8a5a32, #d17c46);
          --text-pane-bg: rgba(26, 22, 19, 0.96);
          --library-bg: rgba(23, 20, 18, 0.9);
          --player-bar-bg: #1b1814;
          --jump-bg: rgba(72, 61, 54, 0.88);
          --jump-border: rgba(140, 125, 112, 0.65);
          --jump-hover-bg: rgba(92, 79, 70, 0.95);
        }
      }

      :root[data-theme="light"] {
        color-scheme: light;
        --bg: #f6f1ea;
        --panel: #fffaf2;
        --panel-2: #f1e8dc;
        --ink: #2c2620;
        --muted: #7b7066;
        --accent: #1d7f6e;
        --accent-2: #e07a5f;
        --accent-ink: #fff;
        --highlight: #fff0c2;
        --shadow: 0 12px 30px rgba(32, 28, 24, 0.15);
        --shadow-accent: 0 10px 24px rgba(29, 127, 110, 0.18);
        --shadow-pop: 0 12px 24px rgba(30, 25, 20, 0.18);
        --shadow-float: 0 8px 18px rgba(32, 28, 24, 0.2);
        --shadow-top: 0 -8px 20px rgba(30, 25, 20, 0.12);
        --bg-gradient: linear-gradient(130deg, #f6f1ea 0%, #f2e8da 40%, #e9f2ef 100%);
        --line: #eadfd2;
        --line-strong: #d8caba;
        --surface: #fffdf9;
        --surface-2: #fff;
        --surface-muted: #f2e2c7;
        --surface-soft: #efe5d8;
        --surface-soft-2: #e6d9cb;
        --surface-highlight: #fff4d6;
        --surface-wait: #fde2cf;
        --surface-drag: #f0faf7;
        --text-soft: #8a7a6e;
        --text-dim: #897d72;
        --active-ink: #3a2e22;
        --danger: #b04838;
        --danger-ink: #fff;
        --success-bg: #e4f3ee;
        --success-border: #a6d2c8;
        --success-ink: #1d7f6e;
        --subtle-bg: #faf6f0;
        --subtle-border: #e6d9cb;
        --subtle-ink: #6f6358;
        --bookmark-bg: #f7efe3;
        --bookmark-ink: #50463f;
        --mark-bg: #ffe4a8;
        --cover-gradient: linear-gradient(150deg, #f2cc8f, #e07a5f);
        --cover-gradient-large: linear-gradient(160deg, #f2cc8f, #e07a5f);
        --text-pane-bg: rgba(255, 255, 255, 0.9);
        --library-bg: rgba(255, 250, 242, 0.9);
        --player-bar-bg: #fffdf9;
        --jump-bg: rgba(123, 112, 102, 0.75);
        --jump-border: rgba(123, 112, 102, 0.6);
        --jump-hover-bg: rgba(123, 112, 102, 0.9);
      }

      :root[data-theme="dark"] {
        color-scheme: dark;
        --bg: #14110e;
        --panel: #1b1814;
        --panel-2: #221e19;
        --ink: #f5efe6;
        --muted: #b9ada0;
        --accent: #2fa88f;
        --accent-2: #f0a269;
        --accent-ink: #fff;
        --highlight: #3b2a1c;
        --shadow: 0 16px 36px rgba(0, 0, 0, 0.35);
        --shadow-accent: 0 12px 26px rgba(47, 168, 143, 0.35);
        --shadow-pop: 0 18px 36px rgba(0, 0, 0, 0.45);
        --shadow-float: 0 10px 22px rgba(0, 0, 0, 0.5);
        --shadow-top: 0 -10px 26px rgba(0, 0, 0, 0.55);
        --bg-gradient: linear-gradient(130deg, #14110e 0%, #1a1613 45%, #0f1a17 100%);
        --line: #2c2621;
        --line-strong: #3b332c;
        --surface: #1c1916;
        --surface-2: #241f1a;
        --surface-muted: #2b241e;
        --surface-soft: #241f1a;
        --surface-soft-2: #312a23;
        --surface-highlight: #2c241b;
        --surface-wait: #2f211b;
        --surface-drag: #1b2a26;
        --text-soft: #a79c90;
        --text-dim: #7f756a;
        --active-ink: #f4eadc;
        --danger: #d56a59;
        --danger-ink: #fff;
        --success-bg: #1c3a32;
        --success-border: #2f5b51;
        --success-ink: #bfe9de;
        --subtle-bg: #221d19;
        --subtle-border: #353029;
        --subtle-ink: #c0b6ab;
        --bookmark-bg: #1f1b17;
        --bookmark-ink: #d8cec2;
        --mark-bg: #4b3520;
        --cover-gradient: linear-gradient(150deg, #8a5a32, #d17c46);
        --cover-gradient-large: linear-gradient(160deg, #8a5a32, #d17c46);
        --text-pane-bg: rgba(26, 22, 19, 0.96);
        --library-bg: rgba(23, 20, 18, 0.9);
        --player-bar-bg: #1b1814;
        --jump-bg: rgba(72, 61, 54, 0.88);
        --jump-border: rgba(140, 125, 112, 0.65);
        --jump-hover-bg: rgba(92, 79, 70, 0.95);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: var(--ui);
        color: var(--ink);
        background-color: var(--bg);
        background: var(--bg-gradient);
        touch-action: manipulation;
      }

      .app {
        display: grid;
        grid-template-columns: 280px 1fr;
        min-height: 100vh;
      }

      .library {
        padding: 24px 20px;
        background: var(--library-bg);
        border-right: 1px solid var(--line);
        position: sticky;
        top: 0;
        height: 100vh;
        overflow-y: auto;
        padding-bottom: 140px;
        animation: fade-up 0.6s ease;
      }

      .brand {
        font-family: var(--title);
        font-size: 22px;
        letter-spacing: 0.5px;
        margin-bottom: 8px;
      }

      .library-header .brand {
        margin-bottom: 0;
      }

      .root-path {
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 16px;
      }

      .upload-panel {
        display: grid;
        gap: 8px;
        margin-bottom: 16px;
      }

      .upload-zone {
        border: 1px dashed var(--line-strong);
        border-radius: 14px;
        padding: 12px;
        text-align: center;
        background: var(--surface);
        cursor: pointer;
        transition: border 0.2s ease, background 0.2s ease;
        min-height: var(--cover-thumb-height);
        display: flex;
        flex-direction: column;
        justify-content: center;
      }

      .upload-zone strong {
        display: block;
        font-size: 12px;
        font-weight: 600;
      }

      .upload-zone span {
        display: block;
        font-size: 11px;
        color: var(--muted);
        margin-top: 2px;
      }

      .upload-zone.dragover {
        border-color: var(--accent);
        background: var(--surface-drag);
      }

      .upload-zone.disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .upload-status {
        font-size: 11px;
        color: var(--muted);
        min-height: 14px;
      }

      .upload-status[data-tone="error"] {
        color: var(--danger);
      }

      .book-list {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .book-card {
        display: grid;
        grid-template-columns: 52px 1fr;
        gap: 12px;
        padding: 10px;
        border-radius: 14px;
        border: 1px solid var(--line);
        background: var(--surface);
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease, border 0.2s ease;
      }

      .book-card:hover {
        transform: translateY(-2px);
        box-shadow: var(--shadow);
      }

      .book-card.active {
        border-color: var(--accent);
        box-shadow: var(--shadow-accent);
      }

      .book-cover {
        width: 52px;
        height: var(--cover-thumb-height);
        border-radius: 10px;
        background: var(--cover-gradient);
        overflow: hidden;
      }

      .book-cover img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .book-meta h4 {
        margin: 0 0 4px;
        font-size: 14px;
        font-weight: 600;
      }

      .book-meta p {
        margin: 0;
        font-size: 12px;
        color: var(--muted);
      }

      .reader {
        padding: 28px 18px 120px;
        animation: fade-up 0.6s ease;
      }

      .reader-header {
        display: flex;
        gap: 20px;
        align-items: center;
        margin-bottom: 24px;
      }

      .tts-panel {
        background: var(--panel);
        border-radius: var(--radius);
        padding: 16px 18px;
        border: 1px solid var(--line);
        margin-bottom: 24px;
        box-shadow: var(--shadow);
      }

      .tts-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      .tts-header-actions {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .tts-toggle {
        border: 1px solid var(--line-strong);
        background: var(--surface-2);
        color: var(--ink);
        padding: 6px 12px;
        border-radius: 999px;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
      }

      .tts-toggle.mode-on {
        background: var(--accent);
        border-color: var(--accent);
        color: var(--accent-ink);
      }

      .tts-toggle.mode-off {
        background: var(--surface-2);
        border-color: var(--line-strong);
        color: var(--ink);
      }

      .tts-panel.collapsed .tts-grid,
      .tts-panel.collapsed .tts-actions,
      .tts-panel.collapsed .advanced-panel {
        display: none;
      }

      .tts-panel h3 {
        margin-bottom: 6px; 
        font-size: 13px;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: var(--muted);
      }

      .tts-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 12px;
        margin-bottom: 12px;
      }

      .tts-field label {
        display: block;
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 4px;
      }

      .tts-field input,
      .tts-field select {
        width: 100%;
        padding: 8px 10px;
        border-radius: 10px;
        border: 1px solid var(--line-strong);
        background: var(--surface-2);
        color: var(--ink);
        font-family: var(--ui);
      }

      .voice-groups {
        display: grid;
        gap: 10px;
      }

      .voice-group-title {
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.6px;
        color: var(--muted);
        margin-bottom: 6px;
      }

      .voice-buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .voice-button {
        border: 1px solid var(--line-strong);
        background: var(--surface-2);
        color: var(--ink);
        padding: 6px 12px;
        border-radius: 999px;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
      }

      .voice-button.active {
        background: var(--accent);
        border-color: var(--accent);
        color: var(--accent-ink);
      }

      .voice-button:focus-visible {
        outline: 2px solid var(--accent-2);
        outline-offset: 2px;
      }

      .voice-empty {
        font-size: 12px;
        color: var(--muted);
      }

      .advanced-panel {
        margin: 12px 0;
        padding: 10px;
        border-radius: 12px;
        border: 1px solid var(--line);
        background: var(--surface);
        display: none;
      }

      .advanced-panel.open {
        display: block;
      }

      .advanced-header {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-bottom: 10px;
      }

      .advanced-title {
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.8px;
        color: var(--muted);
      }

      .advanced-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
        font-size: 12px;
        color: var(--muted);
      }

      .advanced-actions label {
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .advanced-actions select {
        padding: 6px 8px;
        border-radius: 8px;
        border: 1px solid var(--line-strong);
        font-family: var(--ui);
        font-size: 12px;
        background: var(--surface-2);
        color: var(--ink);
      }

      .advanced-list {
        display: flex;
        flex-direction: column;
        gap: 6px;
        max-height: 260px;
        overflow-y: auto;
      }

      .advanced-row {
        display: grid;
        grid-template-columns: 22px 1fr 180px;
        gap: 10px;
        align-items: center;
        padding: 6px 8px;
        border-radius: 10px;
        border: 1px solid var(--line);
        background: var(--surface-2);
      }

      .advanced-row.selected {
        background: var(--surface-muted);
      }

      .advanced-meta {
        font-size: 11px;
        color: var(--muted);
      }

      .advanced-select {
        width: 100%;
        padding: 6px 8px;
        border-radius: 8px;
        border: 1px solid var(--line-strong);
        font-family: var(--ui);
        font-size: 12px;
        background: var(--surface-2);
        color: var(--ink);
      }

      .tts-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        align-items: center;
        margin-bottom: 12px;
      }

      .tts-divider {
        width: 1px;
        height: 24px;
        background: var(--surface-soft-2);
        border-radius: 999px;
      }

      .tts-delete {
        margin-left: auto;
      }

      .tts-actions label {
        font-size: 13px;
        color: var(--muted);
        display: flex;
        gap: 6px;
        align-items: center;
      }

      .progress-track {
        width: 100%;
        height: 10px;
        background: var(--surface-soft);
        border-radius: 999px;
        overflow: hidden;
      }

      .progress-fill {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, var(--accent), var(--accent-2));
        transition: width 0.3s ease;
      }

      .progress-text {
        margin-top: 8px;
        font-size: 13px;
        color: var(--muted);
      }

      .progress-detail {
        margin-top: 4px;
        font-size: 12px;
        color: var(--text-soft);
      }

      .merge-status {
        margin-top: 6px;
        font-size: 12px;
        color: var(--muted);
      }

      .cover-large {
        width: 120px;
        height: 160px;
        border-radius: 16px;
        background: var(--cover-gradient-large);
        overflow: hidden;
        box-shadow: var(--shadow);
      }

      .cover-large img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .book-title {
        font-family: var(--title);
        font-size: 30px;
        margin: 0 0 8px;
      }

      .book-subtitle {
        margin: 0 0 4px;
        color: var(--muted);
        font-size: 14px;
      }

      .book-actions {
        margin-top: 10px;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .library-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 8px;
      }

      .btn.theme-toggle {
        width: 28px;
        height: 28px;
        padding: 0;
        border-radius: 12px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }

      .theme-toggle svg {
        width: 18px;
        height: 18px;
        display: none;
        fill: currentColor;
      }

      .theme-toggle[data-theme-mode="dark"] svg[data-icon="dark"],
      .theme-toggle[data-theme-mode="light"] svg[data-icon="light"] {
        display: block;
      }

      .book-menu {
        position: relative;
      }

      .menu-panel {
        position: absolute;
        top: 42px;
        right: 0;
        background: var(--surface);
        border: 1px solid var(--line);
        border-radius: 12px;
        box-shadow: var(--shadow-pop);
        padding: 8px;
        display: none;
        min-width: 160px;
        z-index: 10;
      }

      .menu-panel.open {
        display: block;
      }

      .menu-panel button {
        width: 100%;
        text-align: left;
      }

      .reader-body {
        display: grid;
        grid-template-columns: 230px 1fr;
        gap: 16px;
        align-items: start;
      }

      .toc {
        background: var(--panel);
        border-radius: var(--radius);
        padding: 14px;
        border: 1px solid var(--line);
        max-height: calc(100vh - 320px);
        overflow-y: auto;
      }

      .toc-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 10px;
      }

      .toc h3 {
        font-size: 13px;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: var(--muted);
        margin: 0;
      }

      .toc-item {
        padding: 8px 10px;
        border-radius: 10px;
        margin-bottom: 6px;
        cursor: pointer;
        transition: background 0.2s ease;
      }

      .toc-item.active {
        background: var(--surface-muted);
        color: var(--active-ink);
      }

      .toc-item small {
        display: block;
        color: var(--muted);
        font-size: 11px;
      }

      .text-pane {
        background: var(--text-pane-bg);
        border-radius: 22px;
        padding: 22px;
        box-shadow: var(--shadow);
        min-height: 300px;
      }

      .chapter-title {
        font-family: var(--title);
        font-size: 22px;
        margin: 0 0 14px;
      }

      .chapter-text {
        font-family: var(--read);
        font-size: 18px;
        line-height: 1.7;
        white-space: pre-line;
      }

      .chapter-text p {
        margin: 0 0 16px;
      }

      .panel {
        background: var(--surface);
        border: 1px solid var(--line);
        border-radius: 12px;
        padding: 12px;
      }

      .chunk {
        padding: 2px 1px;
        border-radius: 6px;
        transition: background 0.2s ease, color 0.2s ease;
      }

      .chunk.last-played {
        background: var(--surface-highlight);
      }

      .chunk.active {
        background: var(--highlight);
      }

      .chunk.waiting {
        background: var(--surface-wait);
      }

      .chunk.played {
        color: var(--text-dim);
      }

      .empty-state {
        color: var(--muted);
        font-size: 15px;
      }

      .edit-panel {
        margin-top: 24px;
        background: var(--panel);
        border-radius: var(--radius);
        border: 1px solid var(--line);
        padding: 18px;
        display: none;
      }

      .edit-panel.open {
        display: block;
      }

      .edit-header {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 16px;
      }

      .edit-header h3 {
        margin: 0;
        font-size: 13px;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: var(--muted);
      }

      .edit-meta {
        margin: 6px 0 0;
        font-size: 12px;
        color: var(--muted);
      }

      .edit-actions {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
      }

      .edit-status {
        font-size: 12px;
        color: var(--muted);
      }

      .edit-grid {
        display: grid;
        grid-template-columns: 240px 1fr;
        gap: 16px;
      }

      .edit-sidebar,
      .edit-main {
        display: flex;
        flex-direction: column;
        gap: 14px;
      }

      .edit-section-title {
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.8px;
        color: var(--muted);
        margin-bottom: 8px;
      }

      .edit-chapter-list,
      .edit-dropped-list {
        display: flex;
        flex-direction: column;
        gap: 6px;
        max-height: 280px;
        overflow-y: auto;
      }

      .edit-chapter-item,
      .edit-dropped-item {
        border: 1px solid var(--line);
        background: var(--surface);
        color: var(--ink);
        padding: 6px 8px;
        border-radius: 8px;
        font-size: 12px;
        cursor: pointer;
        text-align: left;
      }

      .edit-chapter-item.active {
        background: var(--surface-muted);
      }

      .edit-dropped-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
      }

      .edit-selected {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      .edit-selected-title {
        font-weight: 600;
        font-size: 13px;
      }

      .edit-split {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 16px;
      }

      .edit-block h4 {
        margin: 0;
        font-size: 13px;
        color: var(--muted);
      }

      .edit-block-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        margin-bottom: 8px;
      }

      .edit-block pre {
        margin: 0;
        white-space: pre-wrap;
        line-height: 1.5;
        font-size: 13px;
      }

      .edit-clean-textarea {
        width: 100%;
        min-height: 220px;
        border: 1px solid var(--line);
        border-radius: 8px;
        padding: 8px;
        background: var(--surface);
        font-family: var(--read);
        font-size: 13px;
        line-height: 1.5;
        color: var(--ink);
      }

      .edit-clean-actions {
        display: flex;
        gap: 8px;
        justify-content: flex-end;
        margin-top: 8px;
      }

      .edit-panel mark {
        background: var(--mark-bg);
        padding: 0 2px;
        border-radius: 3px;
      }

      .edit-rules label {
        display: block;
        font-size: 12px;
        color: var(--muted);
        margin: 10px 0 4px;
      }

      .edit-rules textarea {
        width: 100%;
        min-height: 80px;
        border: 1px solid var(--line);
        border-radius: 8px;
        padding: 8px;
        background: var(--surface);
        font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
        font-size: 12px;
        color: var(--ink);
      }

      .edit-rules select {
        width: 100%;
        border: 1px solid var(--line);
        border-radius: 8px;
        padding: 6px 8px;
        font-size: 12px;
        color: var(--ink);
        background: var(--surface);
      }

      .edit-rules input[type="checkbox"] {
        margin-right: 6px;
      }

      .player-bar {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: var(--player-bar-bg);
        border-top: 1px solid var(--line);
        box-shadow: var(--shadow-top);
        padding: 12px 20px;
        display: flex;
        align-items: center;
        gap: 16px;
        flex-wrap: wrap;
      }

      .player-controls {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .jump-btn {
        position: absolute;
        right: 14px;
        bottom: 14px;
        border: 1px solid var(--jump-border);
        background: var(--jump-bg);
        color: var(--accent-ink);
        width: 44px;
        height: 44px;
        border-radius: 50%;
        font-size: 18px;
        font-weight: 700;
        cursor: pointer;
        box-shadow: var(--shadow-float);
        display: none;
        z-index: 10;
      }

      .jump-btn:hover {
        background: var(--jump-hover-bg);
      }

      .player-left,
      .player-right {
        display: flex;
        align-items: center;
        gap: 16px;
        flex: 1;
        min-width: 0;
      }

      .player-left {
        justify-content: flex-start;
      }

      .player-right {
        justify-content: flex-end;
      }

      .btn {
        border: 1px solid var(--line-strong);
        background: var(--surface-2);
        color: var(--ink);
        padding: 8px 14px;
        border-radius: 999px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s ease, background 0.2s ease;
      }

      .btn.circle {
        width: 36px;
        height: 36px;
        padding: 0;
        border-radius: 50%;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
      }

      .btn.primary {
        background: var(--accent);
        border-color: var(--accent);
        color: var(--accent-ink);
      }

      .btn.success {
        background: var(--success-bg);
        border-color: var(--success-border);
        color: var(--success-ink);
      }

      .btn.subtle {
        background: var(--subtle-bg);
        border-color: var(--subtle-border);
        color: var(--subtle-ink);
      }

      .btn.play {
        padding: 12px 22px;
        font-size: 16px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }

      .btn.icon {
        width: 36px;
        height: 36px;
        padding: 0;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }

      .btn.icon svg {
        width: 16px;
        height: 16px;
        display: block;
      }

      .btn.play svg {
        width: 18px;
        height: 18px;
        display: block;
      }

      .btn.play .pause-icon {
        display: none;
      }

      .btn.play.is-playing .play-icon {
        display: none;
      }

      .btn.play.is-playing .pause-icon {
        display: block;
      }

      .btn.danger {
        background: var(--danger);
        border-color: var(--danger);
        color: var(--danger-ink);
      }

      .btn:active {
        transform: scale(0.98);
      }

      .status {
        color: var(--muted);
        font-size: 13px;
      }

      .marks {
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
        font-size: 12px;
        color: var(--muted);
        position: relative;
      }

      .bookmark-panel {
        position: fixed;
        bottom: calc(env(safe-area-inset-bottom, 0px) + 84px);
        left: 50%;
        transform: translateX(-50%);
        width: 280px;
        max-width: min(280px, calc(100vw - 32px));
        background: var(--surface);
        border: 1px solid var(--line);
        border-radius: 16px;
        box-shadow: var(--shadow-pop);
        padding: 12px;
        display: none;
        z-index: 20;
      }

      .bookmark-panel.open {
        display: block;
      }

      .bookmark-title {
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 8px;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .bookmark-list {
        max-height: 220px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-bottom: 12px;
      }

      .bookmark-item {
        background: var(--bookmark-bg);
        border-radius: 12px;
        padding: 8px 10px;
        display: grid;
        gap: 8px;
      }

      .bookmark-item span {
        font-size: 12px;
        color: var(--bookmark-ink);
      }

      .bookmark-actions {
        display: flex;
        gap: 8px;
      }

      .btn.small {
        padding: 4px 10px;
        font-size: 11px;
      }

      .bookmark-empty {
        font-size: 12px;
        color: var(--muted);
        padding: 6px 4px;
      }

      .marks span {
        max-width: 220px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .speed {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 13px;
      }

      .btn.speed {
        border: 1px solid var(--line-strong);
        background: var(--surface-2);
        color: var(--ink);
        height: 36px;
        padding: 0 12px;
        border-radius: 999px;
        font-weight: 600;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .btn.speed svg {
        width: 16px;
        height: 16px;
        display: block;
      }

      @keyframes fade-up {
        from {
          opacity: 0;
          transform: translateY(12px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @media (max-width: 980px) {
        .app {
          grid-template-columns: 1fr;
        }
        .library {
          position: relative;
          height: auto;
          border-right: none;
          border-bottom: 1px solid var(--line);
          padding-bottom: 160px;
        }
        .book-list {
          display: grid;
          grid-template-columns: repeat(auto-fill, minmax(72px, 1fr));
          gap: 12px;
        }
        .upload-zone {
          padding: 10px;
        }
        .book-card {
          grid-template-columns: 1fr;
          justify-items: stretch;
          padding: 6px;
          overflow: hidden;
        }
        .book-meta {
          display: none;
        }
        .book-cover {
          width: 100%;
          height: auto;
          aspect-ratio: 2 / 3;
        }
        .book-cover img {
          display: block;
        }
        .reader-body {
          grid-template-columns: 1fr;
        }
        .toc {
          max-height: none;
        }
        .edit-panel {
          display: none !important;
        }
        .edit-toggle {
          display: none;
        }
        .jump-btn {
          display: inline-flex;
          align-items: center;
          justify-content: center;
        }
      }

      @media (max-width: 720px) {
        .reader-header {
          flex-direction: column;
          align-items: flex-start;
        }
        .player-bar {
          flex-wrap: wrap;
          gap: 10px;
        }
        .player-controls {
          order: 0;
          width: 100%;
          justify-content: center;
        }
        .player-left {
          order: 1;
          flex: 1 1 100%;
          justify-content: center;
        }
        .player-right {
          order: 2;
          flex: 1 1 100%;
          justify-content: center;
          flex-wrap: wrap;
        }
        .status {
          text-align: center;
        }

        .tts-delete {
          margin-left: 0;
        }

        .advanced-row {
          grid-template-columns: 22px 1fr;
          grid-template-rows: auto auto;
        }
        .advanced-row .advanced-select {
          grid-column: 2 / -1;
        }
      }
    </style>
    <script>
      (() => {
        try {
          const stored = localStorage.getItem("ptts.theme");
          if (stored === "dark" || stored === "light") {
            document.documentElement.setAttribute("data-theme", stored);
          }
        } catch (err) {
          // ignore storage errors
        }
      })();
    </script>
  </head>
  <body>
    <div class="app">
      <aside class="library" id="bookshelf">
        <div class="library-header">
          <div class="brand">pTTS player</div>
          <button class="btn subtle theme-toggle" id="themeToggle" type="button" data-theme-mode="light" aria-label="Theme: Light" title="Theme: Light">
            <svg data-icon="dark" viewBox="0 0 24 24" aria-hidden="true">
              <path d="M12,22 C17.5228475,22 22,17.5228475 22,12 C22,6.4771525 17.5228475,2 12,2 C6.4771525,2 2,6.4771525 2,12 C2,17.5228475 6.4771525,22 12,22 Z M12,20.5 L12,3.5 C16.6944204,3.5 20.5,7.30557963 20.5,12 C20.5,16.6944204 16.6944204,20.5 12,20.5 Z" fill="currentColor" fill-rule="evenodd"></path>
            </svg>
            <svg data-icon="light" viewBox="0 0 24 24" aria-hidden="true">
              <path d="M12,22 C17.5228475,22 22,17.5228475 22,12 C22,6.4771525 17.5228475,2 12,2 C6.4771525,2 2,6.4771525 2,12 C2,17.5228475 6.4771525,22 12,22 Z M12,20.5 L12,3.5 C16.6944204,3.5 20.5,7.30557963 20.5,12 C20.5,16.6944204 16.6944204,20.5 12,20.5 Z" fill="currentColor" fill-rule="evenodd" transform="translate(24 0) scale(-1 1)"></path>
            </svg>
          </button>
        </div>
        <div class="root-path">Root: {{ root_dir }}</div>
        <div class="upload-panel">
          <div class="upload-zone" id="uploadZone" role="button" tabindex="0">
            <strong>Drop EPUB here</strong>
            <span>or click to browse</span>
          </div>
          <input type="file" id="uploadInput" accept=".epub" hidden />
          <div class="upload-status" id="uploadStatus"></div>
        </div>
        <div id="bookList" class="book-list"></div>
      </aside>
      <main class="reader" id="bookSection">
        <div class="reader-header">
          <div class="cover-large" id="coverLarge"></div>
          <div>
            <h1 class="book-title" id="bookTitle">Select a book</h1>
            <p class="book-subtitle" id="bookMeta">No book loaded.</p>
            <p class="book-subtitle" id="bookStatus"></p>
            <div class="book-actions">
              <div class="book-menu">
                <button class="btn circle" id="bookMenuBtn" type="button" aria-haspopup="true" aria-expanded="false" disabled aria-label="More">⋯</button>
                <div class="menu-panel" id="bookMenuPanel">
                  <button class="btn danger" id="deleteBookBtn" type="button" disabled>Delete book</button>
                </div>
              </div>
            </div>
          </div>
        </div>
        <section class="tts-panel" id="ttsPanel">
          <div class="tts-header">
            <h3>Text To Speech</h3>
            <div class="tts-header-actions">
              <button class="tts-toggle" id="advancedToggle" type="button">Multi-Voices</button>
              <button class="tts-toggle" id="ttsToggle">Collapse</button>
            </div>
          </div>
          <div class="tts-grid">
            <div class="tts-field">
              <div class="voice-groups" id="voiceGroup">
                <div class="voice-empty">Loading voices...</div>
              </div>
            </div>
          </div>
          <div class="advanced-panel" id="advancedPanel">
            <div class="advanced-header">
              <div class="advanced-title">Per-chapter voices</div>
              <div class="advanced-actions">
                <label>
                  <input type="checkbox" id="advancedSelectAll" />
                  Select all
                </label>
                <span id="advancedSelectedCount">0 selected</span>
                <select id="advancedBulkVoice"></select>
                <button class="btn small" id="advancedApplyVoice" type="button">Assign</button>
                <button class="btn small" id="advancedClearVoice" type="button">Clear</button>
              </div>
            </div>
            <div class="advanced-list" id="advancedList"></div>
          </div>
          <div class="tts-actions">
            <button class="btn primary" id="startTts">Start TTS</button>
            <button class="btn" id="sampleTts" type="button">Sample</button>
            <span class="tts-divider" aria-hidden="true"></span>
            <button class="btn" id="mergeBtn" type="button">Merge M4B</button>
            <button class="btn subtle tts-delete" id="clearTtsBtn" type="button" title="Delete TTS segments for this book.">Delete TTS cache</button>
          </div>
          <div class="progress-track">
            <div class="progress-fill" id="progressFill"></div>
          </div>
          <div class="progress-text" id="progressText">Idle.</div>
          <div class="progress-detail" id="progressDetail"></div>
          <div class="merge-status" id="ffmpegStatus"></div>
          <div class="merge-status" id="mergeStatus"></div>
        </section>
        <div class="reader-body">
          <aside class="toc">
            <div class="toc-header">
              <h3>Chapters</h3>
              <button class="btn small edit-toggle" id="editToggle" type="button">Edit</button>
            </div>
            <div id="chapterList"></div>
          </aside>
          <section class="text-pane" id="textPane">
            <h2 class="chapter-title" id="chapterTitle">Waiting for a book...</h2>
            <div class="chapter-text" id="chapterText">
              <p class="empty-state">Pick a book on the left to start.</p>
            </div>
          </section>
        </div>
        <section class="edit-panel" id="editPanel">
          <div class="edit-header">
            <div>
              <h3>Sanitize & Preview</h3>
              <p class="edit-meta">Rules auto-save. Re-sanitize refreshes clean text and clears TTS cache.</p>
            </div>
            <div class="edit-actions">
              <button class="btn" id="sanitizeBtn" type="button">Re-sanitize</button>
              <button class="btn" id="editReload" type="button">Reload</button>
              <span class="edit-status" id="editStatus"></span>
            </div>
          </div>
          <div class="edit-grid">
            <aside class="edit-sidebar">
              <div class="panel">
                <div class="edit-section-title">Chapters</div>
                <div class="edit-chapter-list" id="editChapterList"></div>
              </div>
              <div class="panel">
                <div class="edit-section-title">Dropped</div>
                <div class="edit-dropped-list" id="editDroppedList"></div>
              </div>
            </aside>
            <div class="edit-main">
              <div class="panel edit-selected">
                <div class="edit-selected-title" id="editSelectedTitle">Select a chapter</div>
                <button class="btn small" id="dropChapterBtn" type="button">Drop chapter</button>
              </div>
              <div class="panel edit-split">
                <div class="edit-block">
                  <div class="edit-block-header">
                    <h4>Raw</h4>
                  </div>
                  <pre id="editRaw"></pre>
                </div>
                <div class="edit-block">
                  <div class="edit-block-header">
                    <h4>Clean</h4>
                    <button class="btn small" id="editCleanBtn" type="button">Edit</button>
                  </div>
                  <pre id="editClean"></pre>
                  <textarea id="editCleanInput" class="edit-clean-textarea" hidden></textarea>
                  <div class="edit-clean-actions" id="editCleanActions" hidden>
                    <button class="btn small" id="saveCleanBtn" type="button">Save</button>
                    <button class="btn small" id="cancelCleanBtn" type="button">Cancel</button>
                  </div>
                </div>
              </div>
              <div class="panel edit-rules">
                <div class="edit-section-title">Rules</div>
                <label for="rulesParagraphs">Paragraph breaks</label>
                <select id="rulesParagraphs">
                  <option value="double">Double newline (default)</option>
                  <option value="single">Single newline (treat line breaks as paragraphs)</option>
                </select>
                <label for="rulesDrop">Drop chapter title patterns</label>
                <textarea id="rulesDrop"></textarea>
                <label for="rulesCutoff">Section cutoff patterns</label>
                <textarea id="rulesCutoff"></textarea>
                <label for="rulesRemove">Remove patterns</label>
                <textarea id="rulesRemove"></textarea>
                <label><input type="checkbox" id="rulesReplace" /> Replace defaults</label>
              </div>
            </div>
          </div>
        </section>
      </main>
    </div>

    <div class="player-bar">
      <div class="player-left">
        <div class="status" id="status">Last: —</div>
      </div>
      <div class="player-controls">
        <button class="btn icon" id="prevBtn" aria-label="Previous" title="Previous">
          <svg
            viewBox="0 0 24 24"
            aria-hidden="true"
            focusable="false"
          >
            <path d="M6 6h2v12H6zM10 12l8-6v12z" fill="currentColor"></path>
          </svg>
        </button>
        <button class="btn primary play" id="playBtn" aria-label="Play" title="Play">
          <svg
            class="play-icon"
            viewBox="0 0 24 24"
            aria-hidden="true"
            focusable="false"
          >
            <path d="M6 4l12 8-12 8z" fill="currentColor"></path>
          </svg>
          <svg
            class="pause-icon"
            viewBox="0 0 24 24"
            aria-hidden="true"
            focusable="false"
          >
            <path d="M6 5h4v14H6zM14 5h4v14h-4z" fill="currentColor"></path>
          </svg>
        </button>
        <button class="btn icon" id="nextBtn" aria-label="Next" title="Next">
          <svg
            viewBox="0 0 24 24"
            aria-hidden="true"
            focusable="false"
          >
            <path d="M16 6h2v12h-2zM6 6l8 6-8 6z" fill="currentColor"></path>
          </svg>
        </button>
      </div>
      <div class="player-right">
        <div class="marks">
          <button class="btn icon" id="bookmarkBtn" aria-label="Bookmarks" title="Bookmarks">
            <svg
              viewBox="0 0 24 24"
              aria-hidden="true"
              focusable="false"
            >
              <path d="M6 3h12a1 1 0 0 1 1 1v17l-7-4-7 4V4a1 1 0 0 1 1-1z" fill="currentColor"></path>
            </svg>
          </button>
          <div class="bookmark-panel" id="bookmarkPanel">
            <div class="bookmark-title">Bookmarks</div>
            <div class="bookmark-list" id="bookmarkList"></div>
            <button class="btn" id="saveBookmarkBtn">Save current</button>
          </div>
        </div>
        <div class="speed">
          <button class="btn speed" id="speedBtn" type="button" aria-label="Playback speed" title="Playback speed">
            <svg
              viewBox="0 0 30 30"
              aria-hidden="true"
              focusable="false"
            >
              <path
                d="m 14.703125,5.5722656 a 12,12 0 0 0 -12,12.0000004 12,12 0 0 0 0.6894531,3.964843 A 10.746539,10.746539 0 0 1 3.0976562,19.09375 10.746539,10.746539 0 0 1 13.84375,8.3476562 10.746539,10.746539 0 0 1 19.826172,10.173828 L 21.966797,8.0332031 A 12,12 0 0 0 14.703125,5.5722656 Z m 9.148437,3.6035156 c -0.25173,0.00423 -0.507325,0.1022801 -0.71875,0.28125 l -9.193359,7.7812498 c -0.422789,0.35795 -1.416166,1.411952 -0.002,2.826172 1.414471,1.41445 2.468093,0.418804 2.826172,-0.0039 l 7.783203,-9.189453 c 0.358051,-0.42275 0.391737,-1.0223328 0,-1.4140628 -0.195869,-0.19587 -0.443582,-0.285475 -0.695313,-0.28125 z m 1.84961,3.6074218 -2.021484,2.021485 A 10.746539,10.746539 0 0 1 24.585938,19 h 2.015624 a 12,12 0 0 0 0.101563,-1.427734 12,12 0 0 0 -1.001953,-4.789063 z"
                fill="currentColor"
              ></path>
            </svg>
            <span id="speedValue">1.0x</span>
          </button>
        </div>
      </div>
      <button class="jump-btn" id="jumpShelf" type="button" aria-label="Back to bookshelf">↑</button>
    </div>

    <audio id="audio"></audio>
    <audio id="audioNext" preload="auto"></audio>

    <script>
      const state = {
        books: [],
        book: null,
        chapters: [],
        chapterMap: {},
        queue: [],
        chapterOffsets: {},
        currentChapterId: null,
        currentQueueIndex: 0,
        activeQueueIndex: null,
        waitingFor: null,
        waitTimer: null,
        audioBase: "",
        synthTimer: null,
        loadingBook: false,
        initialBookId: null,
        initialChapterId: null,
        pendingManifestRefresh: false,
        needsRechunk: false,
        synthRunning: false,
        synthMode: "tts",
        statusMode: "idle",
        themePreference: "system",
        playbackSaveTimer: null,
        playback: {
          lastPlayed: null,
          furthestPlayed: null,
          bookmarks: [],
        },
        voicePreference: null,
        selectedVoice: null,
        advancedMode: false,
        voiceMap: { default: null, chapters: {} },
        voiceOptions: [],
        advancedSelection: new Set(),
        advancedLastIndex: null,
        voiceMapSaveTimer: null,
        preloadedIndex: null,
        padMs: 0,
        gaplessArmedIndex: null,
        playbackRate: 1.0,
        mergeRunning: false,
        mergeReady: false,
        mergeExitCode: null,
        mergeOutputExists: false,
        mergeStage: "idle",
        editOpen: false,
        previewChapterIndex: null,
        previewSelectedTitle: "",
        previewSelectedKind: "",
        rulesLoading: false,
        rulesSaveTimer: null,
        ingestRunning: false,
        cleanEditing: false,
        cleanEditOriginal: "",
        cleanEditChapter: null,
        bookVoice: null,
        playTransitioning: false,
      };

      const bookList = document.getElementById("bookList");
      const uploadZone = document.getElementById("uploadZone");
      const uploadInput = document.getElementById("uploadInput");
      const uploadStatus = document.getElementById("uploadStatus");
      const chapterList = document.getElementById("chapterList");
      const chapterTitle = document.getElementById("chapterTitle");
      const chapterText = document.getElementById("chapterText");
      const bookTitle = document.getElementById("bookTitle");
      const bookMeta = document.getElementById("bookMeta");
      const bookStatus = document.getElementById("bookStatus");
      const themeToggle = document.getElementById("themeToggle");
      const coverLarge = document.getElementById("coverLarge");
      const editToggle = document.getElementById("editToggle");
      const editPanel = document.getElementById("editPanel");
      const sanitizeBtn = document.getElementById("sanitizeBtn");
      const editReload = document.getElementById("editReload");
      const editStatus = document.getElementById("editStatus");
      const editChapterList = document.getElementById("editChapterList");
      const editDroppedList = document.getElementById("editDroppedList");
      const editSelectedTitle = document.getElementById("editSelectedTitle");
      const dropChapterBtn = document.getElementById("dropChapterBtn");
      const editRaw = document.getElementById("editRaw");
      const editClean = document.getElementById("editClean");
      const editCleanBtn = document.getElementById("editCleanBtn");
      const editCleanInput = document.getElementById("editCleanInput");
      const editCleanActions = document.getElementById("editCleanActions");
      const saveCleanBtn = document.getElementById("saveCleanBtn");
      const cancelCleanBtn = document.getElementById("cancelCleanBtn");
      const bookMenuBtn = document.getElementById("bookMenuBtn");
      const bookMenuPanel = document.getElementById("bookMenuPanel");
      const deleteBookBtn = document.getElementById("deleteBookBtn");
      const rulesDrop = document.getElementById("rulesDrop");
      const rulesCutoff = document.getElementById("rulesCutoff");
      const rulesRemove = document.getElementById("rulesRemove");
      const rulesParagraphs = document.getElementById("rulesParagraphs");
      const rulesReplace = document.getElementById("rulesReplace");
      const status = document.getElementById("status");
      const playBtn = document.getElementById("playBtn");
      const prevBtn = document.getElementById("prevBtn");
      const nextBtn = document.getElementById("nextBtn");
      const speedBtn = document.getElementById("speedBtn");
      const speedValue = document.getElementById("speedValue");
      const jumpShelf = document.getElementById("jumpShelf");
      const audio = document.getElementById("audio");
      const audioNext = document.getElementById("audioNext");
      let currentAudio = audio;
      let nextAudio = audioNext;
      const bookmarkBtn = document.getElementById("bookmarkBtn");
      const bookmarkList = document.getElementById("bookmarkList");
      const bookmarkPanel = document.getElementById("bookmarkPanel");
      const saveBookmarkBtn = document.getElementById("saveBookmarkBtn");
      const voiceGroup = document.getElementById("voiceGroup");
      const startTts = document.getElementById("startTts");
      const sampleTts = document.getElementById("sampleTts");
      const mergeBtn = document.getElementById("mergeBtn");
      const clearTtsBtn = document.getElementById("clearTtsBtn");
      const progressFill = document.getElementById("progressFill");
      const progressText = document.getElementById("progressText");
      const progressDetail = document.getElementById("progressDetail");
      const ffmpegStatus = document.getElementById("ffmpegStatus");
      const mergeStatus = document.getElementById("mergeStatus");
      const ttsPanel = document.getElementById("ttsPanel");
      const ttsToggle = document.getElementById("ttsToggle");
      const advancedToggle = document.getElementById("advancedToggle");
      const advancedPanel = document.getElementById("advancedPanel");
      const advancedList = document.getElementById("advancedList");
      const advancedSelectAll = document.getElementById("advancedSelectAll");
      const advancedSelectedCount = document.getElementById("advancedSelectedCount");
      const advancedBulkVoice = document.getElementById("advancedBulkVoice");
      const advancedApplyVoice = document.getElementById("advancedApplyVoice");
      const advancedClearVoice = document.getElementById("advancedClearVoice");
      const themeQuery = window.matchMedia("(prefers-color-scheme: dark)");

      function setStatus(message, mode = "message") {
        status.textContent = message;
        state.statusMode = mode;
      }

      function setUploadStatus(message, tone = "idle") {
        uploadStatus.textContent = message || "";
        uploadStatus.dataset.tone = tone;
      }

      function setIngestRunning(running) {
        state.ingestRunning = running;
        uploadZone.classList.toggle("disabled", running);
        uploadInput.disabled = running;
      }

      function pad6(num) {
        return String(num).padStart(6, "0");
      }

      function readUrlState() {
        const params = new URLSearchParams(window.location.search);
        state.initialBookId = params.get("book");
        state.initialChapterId = params.get("chapter");
      }

      function updateUrl(bookId, chapterId) {
        const params = new URLSearchParams();
        if (bookId) {
          params.set("book", bookId);
        }
        if (chapterId) {
          params.set("chapter", chapterId);
        }
        const query = params.toString();
        const next = query ? `/?${query}` : "/";
        history.replaceState(null, "", next);
      }

      function isMobileLayout() {
        return window.matchMedia("(max-width: 980px)").matches;
      }

      function scrollToBookSection() {
        if (!isMobileLayout()) {
          return;
        }
        const target = document.getElementById("bookSection");
        if (target) {
          target.scrollIntoView({ behavior: "smooth", block: "start" });
        }
      }

      function scrollToTextPane() {
        if (!isMobileLayout()) {
          return;
        }
        const target = document.getElementById("textPane");
        if (target) {
          target.scrollIntoView({ behavior: "smooth", block: "start" });
        }
      }

      function normalizeTheme(value) {
        const cleaned = String(value || "").trim().toLowerCase();
        if (cleaned === "light" || cleaned === "dark") {
          return cleaned;
        }
        return "system";
      }

      function resolveTheme(preference) {
        const normalized = normalizeTheme(preference);
        if (normalized === "system") {
          return themeQuery.matches ? "dark" : "light";
        }
        return normalized;
      }

      function updateThemeToggle() {
        if (!themeToggle) {
          return;
        }
        const resolved = resolveTheme(state.themePreference);
        const prettyResolved =
          resolved.charAt(0).toUpperCase() + resolved.slice(1);
        const title = `Theme: ${prettyResolved}`;
        themeToggle.setAttribute("aria-label", title);
        themeToggle.setAttribute("title", title);
        themeToggle.dataset.themeMode = resolved;
      }

      function applyTheme(preference, persist = false) {
        const normalized = normalizeTheme(preference);
        state.themePreference = normalized;
        if (normalized === "system") {
          document.documentElement.removeAttribute("data-theme");
        } else {
          document.documentElement.setAttribute("data-theme", normalized);
        }
        updateThemeToggle();
        if (persist) {
          if (normalized === "system") {
            localStorage.removeItem("ptts.theme");
          } else {
            localStorage.setItem("ptts.theme", normalized);
          }
        }
      }

      function cycleTheme() {
        const resolved = resolveTheme(state.themePreference);
        const next = resolved === "dark" ? "light" : "dark";
        applyTheme(next, true);
      }

      function getBookmarks() {
        return state.playback.bookmarks || [];
      }

      function saveBookmarks(bookmarks, persist = true) {
        state.playback.bookmarks = Array.isArray(bookmarks) ? bookmarks : [];
        if (persist) {
          schedulePlaybackSave();
        }
      }

      function getLastPlayed() {
        const value = state.playback.lastPlayed;
        return typeof value === "number" ? value : null;
      }

      function getFurthestPlayed() {
        const value = state.playback.furthestPlayed;
        return typeof value === "number" ? value : null;
      }

      function setLastPlayed(index, persist = true) {
        state.playback.lastPlayed =
          typeof index === "number" ? index : null;
        if (typeof index === "number") {
          const currentFurthest = getFurthestPlayed();
          if (currentFurthest === null || index > currentFurthest) {
            state.playback.furthestPlayed = index;
          }
        }
        if (persist) {
          schedulePlaybackSave();
        }
      }

      async function fetchJson(url, options = {}) {
        const opts = { cache: "no-store", ...options };
        if (options.headers) {
          opts.headers = { ...options.headers };
        }
        const res = await fetch(url, opts);
        if (!res.ok) {
          let detail = `Request failed: ${res.status}`;
          try {
            const payload = await res.json();
            if (payload && payload.detail) {
              detail = payload.detail;
            }
          } catch (err) {
            // ignore parse errors
          }
          throw new Error(detail);
        }
        return res.json();
      }

      async function ingestFile(file) {
        if (!file) {
          return;
        }
        const name = file.name || "";
        if (!name.toLowerCase().endsWith(".epub")) {
          setUploadStatus("Only .epub files are supported.", "error");
          return;
        }
        if (state.ingestRunning) {
          return;
        }
        setIngestRunning(true);
        setUploadStatus(`Ingesting and sanitizing ${name}...`);
        const body = new FormData();
        body.append("file", file);
        try {
          const data = await fetchJson("/api/ingest", {
            method: "POST",
            body,
          });
          const title = data.title || data.book_id || "Book";
          setUploadStatus(`Ingested and sanitized ${title}.`);
          await loadBooks();
          if (data.book_id) {
            await selectBook(data.book_id);
          }
        } catch (err) {
          setUploadStatus(err.message || "Ingest failed.", "error");
        } finally {
          setIngestRunning(false);
          uploadInput.value = "";
        }
      }

      function setSelectedVoice(value, persist = true) {
        state.selectedVoice = value;
        const buttons = voiceGroup.querySelectorAll(".voice-button");
        buttons.forEach((button) => {
          button.classList.toggle("active", button.dataset.voice === value);
        });
        if (state.advancedMode) {
          state.voiceMap.default = value;
          if (persist) {
            scheduleVoiceMapSave();
          }
          renderAdvancedPanel();
        } else {
          state.voicePreference = value;
          if (persist && value) {
            localStorage.setItem("ptts.voice", value);
          }
        }
      }

      function getSelectedVoice() {
        return state.selectedVoice;
      }

      function appendVoiceGroup(container, label, items) {
        if (!items.length) {
          return;
        }
        const group = document.createElement("div");
        group.className = "voice-group";
        const title = document.createElement("div");
        title.className = "voice-group-title";
        title.textContent = label;
        const buttons = document.createElement("div");
        buttons.className = "voice-buttons";
        items.forEach((item) => {
          const button = document.createElement("button");
          button.type = "button";
          button.className = "voice-button";
          button.dataset.voice = item.value;
          button.textContent = formatVoiceLabel(item.label);
          button.addEventListener("click", () => {
            setSelectedVoice(item.value);
          });
          buttons.appendChild(button);
        });
        group.appendChild(title);
        group.appendChild(buttons);
        container.appendChild(group);
      }

      function formatVoiceLabel(label) {
        if (!label) {
          return "";
        }
        const cleaned = String(label).replace(/[_-]+/g, " ").trim();
        if (!cleaned) {
          return "";
        }
        return cleaned
          .split(/\s+/)
          .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
          .join(" ");
      }

      function voiceLabelFromValue(value) {
        if (!value) {
          return "";
        }
        const match = state.voiceOptions.find((entry) => entry.value === value);
        if (match && match.label) {
          return formatVoiceLabel(match.label);
        }
        const parts = String(value).split(/[\\/]/);
        let leaf = parts[parts.length - 1] || "";
        if (leaf) {
          leaf = leaf.replace(/\.[^.]+$/, "");
          return formatVoiceLabel(leaf);
        }
        return formatVoiceLabel(value);
      }

      async function loadVoices() {
        try {
          const data = await fetchJson("/api/voices");
          const local = Array.isArray(data.local) ? data.local : [];
          const builtin = Array.isArray(data.builtin) ? data.builtin : [];
          const defaultVoice = data.default || "";

          state.voiceOptions = [...local, ...builtin];
          voiceGroup.innerHTML = "";
          appendVoiceGroup(voiceGroup, "Local voices", local);
          appendVoiceGroup(voiceGroup, "Built-in voices", builtin);

          const available = state.voiceOptions.map((item) => item.value);
          if (!available.length) {
            voiceGroup.innerHTML = "<div class=\"voice-empty\">No voices found.</div>";
            setSelectedVoice(null, false);
            return;
          }

          let selected = state.advancedMode
            ? state.voiceMap.default
            : state.bookVoice || state.voicePreference;
          if (!selected || !available.includes(selected)) {
            if (local.length) {
              selected = local[0].value;
            } else if (defaultVoice && available.includes(defaultVoice)) {
              selected = defaultVoice;
            } else {
              selected = builtin[0].value;
            }
          }
          setSelectedVoice(selected, false);
          if (state.advancedMode && state.voiceMap.default !== selected) {
            state.voiceMap.default = selected;
            scheduleVoiceMapSave();
          }
          renderAdvancedPanel();
        } catch (err) {
          voiceGroup.innerHTML = "<div class=\"voice-empty\">Unable to load voices.</div>";
        }
      }

      async function loadVoiceMap() {
        if (!state.book) {
          return;
        }
        try {
          const data = await fetchJson(
            `/api/books/${encodeURIComponent(state.book.id)}/voices`
          );
          const chapters =
            data && typeof data.chapters === "object" ? data.chapters : {};
          state.voiceMap = {
            default: data.default || null,
            chapters,
          };
        } catch (err) {
          state.voiceMap = {
            default: state.voicePreference,
            chapters: {},
          };
        }
      }

      function scheduleVoiceMapSave() {
        if (!state.book || !state.advancedMode) {
          return;
        }
        if (state.voiceMapSaveTimer) {
          clearTimeout(state.voiceMapSaveTimer);
        }
        state.voiceMapSaveTimer = setTimeout(() => {
          saveVoiceMap();
        }, 600);
      }

      async function saveVoiceMap() {
        if (!state.book || !state.advancedMode) {
          return false;
        }
        const payload = {
          default: state.voiceMap.default,
          chapters: state.voiceMap.chapters || {},
        };
        try {
          const data = await fetchJson(
            `/api/books/${encodeURIComponent(state.book.id)}/voices`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
            }
          );
          const chapters =
            data && typeof data.chapters === "object" ? data.chapters : {};
          state.voiceMap = {
            default: data.default || state.voiceMap.default,
            chapters,
          };
          renderAdvancedPanel();
          return true;
        } catch (err) {
          console.warn("Failed to save voice map.", err);
          return false;
        }
      }

      function updateAdvancedMode(persist = true) {
        advancedPanel.classList.toggle("open", !!state.advancedMode);
        advancedToggle.textContent = "Multi-Voices";
        advancedToggle.classList.toggle("mode-on", state.advancedMode);
        advancedToggle.classList.toggle("mode-off", !state.advancedMode);
        if (persist) {
          saveSettings();
        }
        updateSampleButtonState();
        if (state.book) {
          loadVoiceMap().then(() => loadVoices());
        } else {
          renderAdvancedPanel();
        }
        updateAdvancedControls();
      }

      function renderAdvancedPanel() {
        const show = state.advancedMode && !!state.book;
        advancedPanel.classList.toggle("open", show);
        if (!show) {
          advancedList.innerHTML = "";
          return;
        }
        renderAdvancedList();
        updateAdvancedControls();
      }

      function renderAdvancedList() {
        advancedList.innerHTML = "";
        const chapters = state.chapters || [];
        if (!chapters.length) {
          advancedList.innerHTML =
            "<p class=\"voice-empty\">No chapters yet.</p>";
          updateAdvancedSelectionStats();
          return;
        }
        const chapterIds = new Set(
          chapters.map((chapter) => chapter.id).filter(Boolean)
        );
        state.advancedSelection = new Set(
          [...state.advancedSelection].filter((id) => chapterIds.has(id))
        );
        const defaultLabel = voiceLabelFromValue(state.voiceMap.default || "");
        buildVoiceOptions(advancedBulkVoice, defaultLabel);
        if (!advancedBulkVoice.value) {
          advancedBulkVoice.value = "default";
        }
        chapters.forEach((chapter, index) => {
          const row = document.createElement("div");
          const chapterId = chapter.id || "";
          row.className = "advanced-row";
          if (state.advancedSelection.has(chapterId)) {
            row.classList.add("selected");
          }
          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.checked = state.advancedSelection.has(chapterId);
          checkbox.addEventListener("click", (event) => {
            handleAdvancedSelection(event, index, chapterId);
          });

          const info = document.createElement("div");
          const title = document.createElement("div");
          title.textContent = chapter.title || chapterId || "Chapter";
          const meta = document.createElement("div");
          meta.className = "advanced-meta";
          meta.textContent = `${chapter.chunk_count || 0} chunks`;
          info.appendChild(title);
          info.appendChild(meta);

          const select = document.createElement("select");
          select.className = "advanced-select";
          buildVoiceOptions(select, defaultLabel);
          const override = state.voiceMap.chapters
            ? state.voiceMap.chapters[chapterId]
            : null;
          select.value = override || "default";
          select.addEventListener("change", () => {
            updateChapterVoice(chapterId, select.value);
          });

          row.appendChild(checkbox);
          row.appendChild(info);
          row.appendChild(select);
          advancedList.appendChild(row);
        });
        updateAdvancedSelectionStats();
      }

      function buildVoiceOptions(select, defaultLabel) {
        select.innerHTML = "";
        const defaultOption = document.createElement("option");
        defaultOption.value = "default";
        defaultOption.textContent = defaultLabel
          ? `Default (${defaultLabel})`
          : "Default";
        select.appendChild(defaultOption);
        state.voiceOptions.forEach((entry) => {
          const option = document.createElement("option");
          option.value = entry.value;
          option.textContent = formatVoiceLabel(entry.label);
          select.appendChild(option);
        });
      }

      function updateChapterVoice(chapterId, voiceValue) {
        if (!chapterId) {
          return;
        }
        if (voiceValue === "default" || !voiceValue) {
          delete state.voiceMap.chapters[chapterId];
        } else {
          state.voiceMap.chapters[chapterId] = voiceValue;
        }
        scheduleVoiceMapSave();
        renderAdvancedList();
      }

      function handleAdvancedSelection(event, index, chapterId) {
        const checked = event.target.checked;
        if (event.shiftKey && state.advancedLastIndex !== null) {
          const start = Math.min(state.advancedLastIndex, index);
          const end = Math.max(state.advancedLastIndex, index);
          for (let i = start; i <= end; i += 1) {
            const entry = state.chapters[i];
            if (!entry || !entry.id) {
              continue;
            }
            if (checked) {
              state.advancedSelection.add(entry.id);
            } else {
              state.advancedSelection.delete(entry.id);
            }
          }
        } else {
          if (checked) {
            state.advancedSelection.add(chapterId);
          } else {
            state.advancedSelection.delete(chapterId);
          }
        }
        state.advancedLastIndex = index;
        renderAdvancedList();
      }

      function updateAdvancedSelectionStats() {
        const total = state.chapters.length;
        const selected = state.advancedSelection.size;
        advancedSelectedCount.textContent = `${selected} selected`;
        if (total > 0) {
          advancedSelectAll.checked = selected === total;
          advancedSelectAll.indeterminate = selected > 0 && selected < total;
        } else {
          advancedSelectAll.checked = false;
          advancedSelectAll.indeterminate = false;
        }
      }

      function updateAdvancedControls() {
        const disabled =
          !state.book ||
          !state.advancedMode ||
          state.synthRunning ||
          state.mergeRunning;
        advancedSelectAll.disabled = disabled;
        advancedBulkVoice.disabled = disabled;
        const hasSelection = state.advancedSelection.size > 0;
        advancedApplyVoice.disabled = disabled || !hasSelection;
        advancedClearVoice.disabled = disabled || !hasSelection;
        advancedList.querySelectorAll("input, select").forEach((element) => {
          element.disabled = disabled;
        });
      }

      function schedulePlaybackSave() {
        if (!state.book) {
          return;
        }
        if (state.playbackSaveTimer) {
          clearTimeout(state.playbackSaveTimer);
        }
        state.playbackSaveTimer = setTimeout(() => {
          persistPlayback();
        }, 500);
      }

      async function persistPlayback(payload) {
        if (!state.book) {
          return;
        }
        const body = payload || {
          last_played: getLastPlayed(),
          furthest_played: getFurthestPlayed(),
          bookmarks: getBookmarks(),
        };
        try {
          await fetchJson(
            `/api/playback?book_id=${encodeURIComponent(state.book.id)}`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(body),
            }
          );
        } catch (err) {
          console.warn("Failed to persist playback state.", err);
        }
      }

      function clearBookView() {
        state.book = null;
        state.chapters = [];
        state.chapterMap = {};
        state.queue = [];
        state.chapterOffsets = {};
        state.currentChapterId = null;
        state.currentQueueIndex = 0;
        state.activeQueueIndex = null;
        state.audioBase = "";
        state.padMs = 0;
        state.mergeRunning = false;
        state.mergeReady = false;
        state.mergeExitCode = null;
        state.mergeOutputExists = false;
        state.mergeStage = "idle";
        state.synthRunning = false;
        state.synthMode = "tts";
        state.playback = { lastPlayed: null, furthestPlayed: null, bookmarks: [] };
        state.bookVoice = null;
        state.voiceMap = { default: null, chapters: {} };
        state.selectedVoice = null;
        state.voiceOptions = [];
        state.advancedSelection = new Set();
        state.advancedLastIndex = null;
        resetAudioPlayers();
        bookTitle.textContent = "Select a book";
        bookMeta.textContent = "No book loaded.";
        bookStatus.textContent = "";
        coverLarge.innerHTML = "";
        chapterTitle.textContent = "Waiting for a book...";
        chapterText.innerHTML =
          "<p class=\"empty-state\">Pick a book on the left to start.</p>";
        chapterList.innerHTML = "";
        ffmpegStatus.textContent = "";
        editPanel.classList.remove("open");
        editToggle.textContent = "Edit";
        state.editOpen = false;
        state.previewChapterIndex = null;
        state.previewSelectedTitle = "";
        state.previewSelectedKind = "";
        updateUrl(null, null);
        updateMergeButtonState();
        updateClearButtonState();
        renderAdvancedPanel();
        updateMarks();
      }

      async function loadPlayback() {
        if (!state.book) {
          return;
        }
        try {
          const data = await fetchJson(
            `/api/playback?book_id=${encodeURIComponent(state.book.id)}`
          );
          const last =
            typeof data.last_played === "number" ? data.last_played : null;
          const furthest =
            typeof data.furthest_played === "number" ? data.furthest_played : null;
          const marks = Array.isArray(data.bookmarks) ? data.bookmarks : [];
          const effectiveFurthest = furthest === null ? last : furthest;
          state.playback.furthestPlayed = effectiveFurthest;
          setLastPlayed(last, false);
          saveBookmarks(marks, false);
          if (!data.exists) {
            await persistPlayback({
              last_played: last,
              furthest_played: effectiveFurthest,
              bookmarks: marks,
            });
          }
        } catch (err) {
          console.warn("Failed to load playback state.", err);
        }
      }

      async function loadBooks() {
        try {
          const data = await fetchJson("/api/books");
          state.books = data.books || [];
          renderBooks();
          if (state.initialBookId && !state.book) {
            const initial = state.initialBookId;
            const chapter = state.initialChapterId;
            state.initialBookId = null;
            state.initialChapterId = null;
            await selectBook(initial, chapter);
          }
        } catch (err) {
          bookList.innerHTML = "<p class=\"empty-state\">Failed to load books.</p>";
        }
      }

      function loadSettings() {
        state.voicePreference = localStorage.getItem("ptts.voice");
        state.advancedMode = localStorage.getItem("ptts.advancedMode") === "1";
        applyTheme(normalizeTheme(localStorage.getItem("ptts.theme")), false);
        themeQuery.addEventListener("change", () => {
          if (normalizeTheme(state.themePreference) === "system") {
            updateThemeToggle();
          }
        });
        const collapsed = localStorage.getItem("ptts.ttsCollapsed") === "1";
        if (collapsed) {
          ttsPanel.classList.add("collapsed");
          ttsToggle.textContent = "Expand";
        }
        updateAdvancedMode(false);
      }

      function saveSettings() {
        if (state.voicePreference) {
          localStorage.setItem("ptts.voice", state.voicePreference);
        }
        localStorage.setItem("ptts.advancedMode", state.advancedMode ? "1" : "0");
      }

      function renderBooks() {
        bookList.innerHTML = "";
        if (!state.books.length) {
          bookList.innerHTML = "<p class=\"empty-state\">No books found.</p>";
          return;
        }
        state.books.forEach((book) => {
          const card = document.createElement("div");
          card.className = "book-card";
          if (state.book && state.book.id === book.id) {
            card.classList.add("active");
          }
          card.innerHTML = `
            <div class="book-cover">${book.cover_url ? `<img src="${book.cover_url}" alt="Cover" />` : ""}</div>
            <div class="book-meta">
              <h4>${book.title}</h4>
              <p>${(book.authors || []).join(", ")}</p>
              <p>${book.has_audio ? "Audio ready" : "No audio yet"}</p>
            </div>
          `;
          card.addEventListener("click", () => selectBook(book.id));
          bookList.appendChild(card);
        });
      }

      async function selectBook(bookId, chapterId) {
        state.loadingBook = true;
        resetAudioPlayers();
        try {
          const data = await fetchJson(`/api/books/${bookId}`);
          state.book = data.book;
          state.chapters = data.chapters || [];
          state.advancedSelection = new Set();
          state.advancedLastIndex = null;
          state.padMs = data.book ? data.book.pad_ms || 0 : 0;
          state.bookVoice = data.book ? data.book.last_voice || null : null;
          state.playback = { lastPlayed: null, furthestPlayed: null, bookmarks: [] };
          state.mergeRunning = false;
          state.mergeReady = false;
          state.mergeExitCode = null;
          state.mergeOutputExists = false;
          state.mergeStage = "idle";
          state.synthMode = "tts";
          mergeStatus.textContent = "";
          state.chapterMap = {};
          state.chapters.forEach((chapter) => {
            if (chapter && chapter.id) {
              state.chapterMap[chapter.id] = chapter;
            }
          });
          state.audioBase = data.audio_base || "";
          state.currentQueueIndex = 0;
          state.activeQueueIndex = null;
          state.waitingFor = null;
          if (state.waitTimer) {
            clearTimeout(state.waitTimer);
          }
          await loadPlayback();
          buildQueue();
          const hasSpanData = state.chapters.some(
            (chapter) => (chapter.chunk_spans || []).length > 0
          );
          state.needsRechunk = state.chapters.length > 0 && !hasSpanData;
          renderBooks();
          renderBookHeader();
          await loadVoiceMap();
          await loadVoices();
          updateDeleteButtonState();
          renderChapters();
          if (state.chapters.length) {
            const desired = chapterId || state.chapters[0].id;
            renderChapter(desired);
            const offset = state.chapterOffsets[desired];
            let anchorIndex =
              typeof offset === "number" ? offset : state.currentQueueIndex;
            const lastIndex = getLastPlayed();
            if (lastIndex !== null) {
              const lastItem = state.queue[lastIndex];
              if (lastItem && lastItem.chapterId === desired) {
                anchorIndex = lastIndex;
              }
            }
            state.currentQueueIndex = anchorIndex;
            setIdleStatus();
            if (state.needsRechunk) {
              setStatus("Manifest missing chunk spans. Delete TTS cache and start TTS.");
            }
          } else {
            chapterTitle.textContent = "No audio yet";
            chapterText.innerHTML =
              "<p class=\"empty-state\">Run `ptts synth` to generate audio chunks.</p>";
            setStatus("No audio available.");
          }
          updateUrl(state.book.id, state.currentChapterId);
          startSynthPolling();
          if (state.editOpen) {
            await loadPreview(state.previewChapterIndex);
          }
          scrollToBookSection();
        } catch (err) {
          setStatus("Failed to load book.");
        } finally {
          state.loadingBook = false;
        }
      }

      function renderBookHeader() {
        if (!state.book) {
          return;
        }
        bookTitle.textContent = state.book.title || state.book.id;
        const author = (state.book.authors || []).join(", ");
        const year = state.book.year ? ` (${state.book.year})` : "";
        bookMeta.textContent = `${author}${year}`;
        bookStatus.textContent = state.book.has_audio
          ? "Audio manifest loaded."
          : "Waiting for audio.";
        if (state.book.cover_url) {
          coverLarge.innerHTML = `<img src="${state.book.cover_url}" alt="Cover" />`;
        } else {
          coverLarge.innerHTML = "";
        }
      }

      function snippet(text, length) {
        if (!text) {
          return "";
        }
        const cleaned = text.replace(/\s+/g, " ").trim();
        return cleaned.slice(0, length);
      }

      function getChapterById(chapterId) {
        return state.chapterMap[chapterId] || null;
      }

      function getChunkSpan(item) {
        const chapter = getChapterById(item.chapterId);
        if (!chapter) {
          return null;
        }
        const spans = chapter.chunk_spans || [];
        return spans[item.chunkIndex] || null;
      }

      function getChunkText(item) {
        const chapter = getChapterById(item.chapterId);
        if (!chapter) {
          return "";
        }
        const span = getChunkSpan(item);
        if (!span || !chapter.clean_text) {
          return "";
        }
        return chapter.clean_text.slice(span[0], span[1]);
      }

      function splitParagraphSpans(text) {
        const spans = [];
        const re = /\n\s*\n+/g;
        let start = 0;
        let match;
        while ((match = re.exec(text)) !== null) {
          const end = match.index;
          let paraStart = start;
          let paraEnd = end;
          while (paraStart < paraEnd && /\s/.test(text[paraStart])) {
            paraStart += 1;
          }
          while (paraEnd > paraStart && /\s/.test(text[paraEnd - 1])) {
            paraEnd -= 1;
          }
          if (paraStart < paraEnd) {
            spans.push([paraStart, paraEnd]);
          }
          start = match.index + match[0].length;
        }
        let tailStart = start;
        let tailEnd = text.length;
        while (tailStart < tailEnd && /\s/.test(text[tailStart])) {
          tailStart += 1;
        }
        while (tailEnd > tailStart && /\s/.test(text[tailEnd - 1])) {
          tailEnd -= 1;
        }
        if (tailStart < tailEnd) {
          spans.push([tailStart, tailEnd]);
        }
        return spans;
      }

      function describeIndex(index) {
        const item = state.queue[index];
        if (!item) {
          return "—";
        }
        const chapterNum = item.chapterIndex + 1;
        const chunkNum = item.chunkIndex + 1;
        const snip = snippet(getChunkText(item), 10);
        return snip ? `${chapterNum}/${chunkNum} ${snip}` : `${chapterNum}/${chunkNum}`;
      }

      function idleStatusText() {
        const lastIndex = getLastPlayed();
        const furthestIndex = getFurthestPlayed();
        const lastLabel =
          lastIndex === null ? "—" : describeIndex(lastIndex);
        const furthestLabel =
          furthestIndex === null ? "—" : describeIndex(furthestIndex);
        return `Last: ${lastLabel} · Furthest: ${furthestLabel}`;
      }

      function setIdleStatus() {
        setStatus(idleStatusText(), "idle");
      }

      function applyLastPlayedHighlight() {
        const prev = chapterText.querySelector(".chunk.last-played");
        if (prev) {
          prev.classList.remove("last-played");
        }
        const lastIndex = getLastPlayed();
        if (lastIndex === null) {
          return;
        }
        const item = state.queue[lastIndex];
        if (!item || item.chapterId !== state.currentChapterId) {
          return;
        }
        const span = chapterText.querySelector(
          `.chunk[data-queue-index="${lastIndex}"]`
        );
        if (span) {
          span.classList.add("last-played");
        }
      }

      function updateMarks() {
        if (!state.book) {
          bookmarkList.innerHTML = "<div class=\"bookmark-empty\">No bookmarks yet.</div>";
          saveBookmarkBtn.disabled = true;
          return;
        }
        const bookmarks = getBookmarks();
        bookmarkList.innerHTML = "";
        const furthestIndex = getFurthestPlayed();
        if (furthestIndex !== null) {
          const item = document.createElement("div");
          item.className = "bookmark-item";
          const label = describeIndex(furthestIndex);
          item.innerHTML = `
            <span>Furthest: ${label}</span>
            <div class="bookmark-actions">
              <button class="btn small" data-action="play-furthest" data-index="${furthestIndex}">Play</button>
            </div>
          `;
          bookmarkList.appendChild(item);
        }
        if (!bookmarks.length) {
          if (furthestIndex === null) {
            bookmarkList.innerHTML = "<div class=\"bookmark-empty\">No bookmarks yet.</div>";
          }
        } else {
          bookmarks.forEach((entry) => {
            const item = document.createElement("div");
            item.className = "bookmark-item";
            const label = describeIndex(entry.index);
            item.innerHTML = `
              <span>${label}</span>
              <div class="bookmark-actions">
                <button class="btn small" data-action="play" data-index="${entry.index}">Play</button>
                <button class="btn small" data-action="remove" data-index="${entry.index}">Remove</button>
              </div>
            `;
            bookmarkList.appendChild(item);
          });
        }
        saveBookmarkBtn.disabled = !state.queue.length;
        if (state.statusMode === "idle") {
          setIdleStatus();
        }
      }

      function jumpToIndex(index, autoplay) {
        if (index === null || index < 0 || index >= state.queue.length) {
          return;
        }
        state.currentQueueIndex = index;
        setActiveChunk(index, false);
        if (autoplay) {
          playIndex(index);
        } else {
          const item = state.queue[index];
          if (item && state.currentChapterId !== item.chapterId) {
            renderChapter(item.chapterId);
          }
        }
        updateMarks();
      }

      function positionBookmarkPanel() {
        if (!bookmarkPanel.classList.contains("open")) {
          return;
        }
        const playerBar = document.querySelector(".player-bar");
        if (!playerBar) {
          return;
        }
        const barRect = playerBar.getBoundingClientRect();
        const panelRect = bookmarkPanel.getBoundingClientRect();
        const viewportWidth = window.innerWidth || document.documentElement.clientWidth;
        const margin = 16;
        const anchorRect = bookmarkBtn.getBoundingClientRect();
        const anchorCenter = anchorRect.left + anchorRect.width / 2;
        const idealLeft = anchorCenter - panelRect.width / 2;
        const maxLeft = viewportWidth - panelRect.width - margin;
        const left = Math.max(margin, Math.min(idealLeft, maxLeft));
        const top = Math.max(margin, barRect.top - panelRect.height - 12);
        bookmarkPanel.style.left = `${left}px`;
        bookmarkPanel.style.top = `${top}px`;
        bookmarkPanel.style.bottom = "auto";
        bookmarkPanel.style.transform = "none";
      }

      function openBookmarkPanel() {
        bookmarkPanel.classList.add("open");
        requestAnimationFrame(positionBookmarkPanel);
        window.addEventListener("resize", positionBookmarkPanel);
      }

      function closeBookmarkPanel() {
        bookmarkPanel.classList.remove("open");
        window.removeEventListener("resize", positionBookmarkPanel);
      }

      function addBookmark(index) {
        if (index === null || index < 0 || index >= state.queue.length) {
          return;
        }
        const bookmarks = getBookmarks();
        if (bookmarks.some((entry) => entry.index === index)) {
          return;
        }
        bookmarks.push({
          index,
          label: describeIndex(index),
          created_at: Date.now(),
        });
        saveBookmarks(bookmarks);
      }

      function removeBookmark(index) {
        const bookmarks = getBookmarks();
        const next = bookmarks.filter((entry) => entry.index !== index);
        saveBookmarks(next);
      }

      function startSynthPolling() {
        if (state.synthTimer) {
          clearInterval(state.synthTimer);
        }
        state.synthTimer = setInterval(loadSynthStatus, 2000);
        loadSynthStatus();
      }

      async function loadSynthStatus() {
        if (!state.book) {
          return;
        }
        try {
          const data = await fetchJson(
            `/api/synth/status?book_id=${encodeURIComponent(state.book.id)}`
          );
          updateSynthUI(data);
          await loadMergeStatus();
          if (
            !state.loadingBook &&
            data.progress &&
            data.progress.total > 0 &&
            (state.pendingManifestRefresh || !state.chapters.length)
          ) {
            await selectBook(state.book.id);
            state.pendingManifestRefresh = false;
          }
        } catch (err) {
          progressText.textContent = "Unable to load TTS status.";
        }
      }

      function updateSynthUI(data) {
        state.synthRunning = !!data.running;
        state.synthMode = data.mode || "tts";
        const sampling = state.synthMode === "sample";
        const progress = data.progress;
        const complete =
          !sampling &&
          !!progress &&
          progress.total > 0 &&
          progress.done >= progress.total;
        startTts.classList.remove("success");
        if (state.synthRunning && sampling) {
          startTts.textContent = "Start TTS";
          startTts.disabled = true;
          sampleTts.textContent = "Stop Sample";
        } else if (complete && !state.synthRunning) {
          startTts.textContent = "TTS Complete";
          startTts.disabled = true;
          startTts.classList.add("success");
          sampleTts.textContent = "Sample";
        } else {
          startTts.textContent = state.synthRunning ? "Stop TTS" : "Start TTS";
          startTts.disabled = false;
          sampleTts.textContent = "Sample";
        }
        const overall = data.overall_progress || null;
        state.mergeReady =
          complete &&
          !state.synthRunning;
        updateMergeButtonState();
        const stage = data.stage || "idle";
        if (stage === "chunking") {
          progressFill.style.width =
            sampling && overall
              ? `${overall.percent}%`
              : "0%";
          progressText.textContent = sampling
            ? "Chunking sample..."
            : "Chunking text...";
          progressDetail.textContent = "Preparing manifest and spans.";
        } else if (stage === "cloning") {
          progressFill.style.width =
            sampling && overall
              ? `${overall.percent}%`
              : "0%";
          progressText.textContent = sampling
            ? "Cloning voice for sample..."
            : "Cloning voice...";
          progressDetail.textContent = "Preparing voice prompt.";
        } else if (stage === "sampled") {
          progressFill.style.width =
            sampling && overall
              ? `${overall.percent}%`
              : "100%";
          progressText.textContent = "Sample ready.";
          if (progress && progress.current) {
            progressDetail.textContent = `${progress.current.chapter_title} · sample done.`;
          } else {
            progressDetail.textContent = "";
          }
        } else if (!progress) {
          progressFill.style.width = "0%";
          progressText.textContent = "Idle.";
          progressDetail.textContent = "";
        } else {
          const barPercent =
            sampling && overall
              ? overall.percent
              : progress.percent;
          progressFill.style.width = `${barPercent}%`;
          const prefix = sampling ? "Sample" : "Progress";
          progressText.textContent = `${prefix}: ${progress.done} / ${progress.total} chunks (${progress.percent}%).`;
          if (progress.current) {
            progressDetail.textContent = `${progress.current.chapter_title} · chunk ${progress.current.chunk_index} of ${progress.current.chunk_total}`;
          } else {
            progressDetail.textContent = progress.total ? "Completed." : "Idle.";
          }
        }

        if (sampling) {
          if (stage === "chunking") {
            bookStatus.textContent = "Preparing sample...";
          } else if (stage === "cloning") {
            bookStatus.textContent = "Cloning sample voice...";
          } else if (stage === "sampling") {
            bookStatus.textContent = "Generating sample...";
          } else if (stage === "sampled") {
            bookStatus.textContent = "Sample ready.";
          } else {
            bookStatus.textContent = state.book && state.book.has_audio ? "Audio ready." : "Waiting for audio.";
          }
        } else if (stage === "chunking") {
          bookStatus.textContent = "Chunking text...";
        } else if (stage === "synthesizing") {
          bookStatus.textContent = "Synthesizing audio...";
        } else if (stage === "done") {
          bookStatus.textContent = "Audio ready.";
        } else {
          bookStatus.textContent = state.book && state.book.has_audio ? "Audio ready." : "Waiting for audio.";
        }
        startTts.disabled =
          startTts.disabled || (state.synthRunning && sampling);
        const ffmpegState = data.ffmpeg_status || "unknown";
        if (ffmpegState === "installing") {
          ffmpegStatus.textContent = "Installing ffmpeg...";
        } else if (ffmpegState === "error") {
          ffmpegStatus.textContent =
            data.ffmpeg_error || "ffmpeg install failed.";
        } else if (ffmpegState === "missing") {
          ffmpegStatus.textContent =
            data.ffmpeg_error || "ffmpeg missing: merge will fail.";
        } else {
          ffmpegStatus.textContent = "";
        }
        updateClearButtonState();
      }

      async function loadMergeStatus() {
        if (!state.book) {
          return;
        }
        try {
          const data = await fetchJson(
            `/api/merge/status?book_id=${encodeURIComponent(state.book.id)}`
          );
          updateMergeUI(data);
        } catch (err) {
          mergeStatus.textContent = err.message || "Unable to load merge status.";
        }
      }

      function updateMergeButtonState() {
        if (state.mergeRunning && state.mergeStage === "installing") {
          mergeBtn.textContent = "Installing ffmpeg...";
          mergeBtn.disabled = true;
        } else if (state.mergeRunning) {
          mergeBtn.textContent = "Merging...";
          mergeBtn.disabled = true;
        } else if (state.mergeOutputExists) {
          mergeBtn.textContent = "Download M4B";
          mergeBtn.disabled = false;
        } else {
          mergeBtn.textContent = "Merge M4B";
          mergeBtn.disabled = !state.mergeReady;
        }
      }

      function updateSampleButtonState() {
        const disabled =
          !state.book ||
          state.mergeRunning ||
          state.advancedMode ||
          (state.synthRunning && state.synthMode !== "sample");
        sampleTts.disabled = disabled;
        sampleTts.title = state.advancedMode
          ? "Sample disabled in Advanced Mode."
          : "Sample";
      }

      function updateClearButtonState() {
        clearTtsBtn.disabled = state.synthRunning || state.mergeRunning;
        updateDeleteButtonState();
        updateSampleButtonState();
        updateAdvancedControls();
      }

      function updateDeleteButtonState() {
        const disabled = !state.book || state.synthRunning || state.mergeRunning;
        deleteBookBtn.disabled = disabled;
        bookMenuBtn.disabled = disabled;
        if (disabled) {
          bookMenuPanel.classList.remove("open");
          bookMenuBtn.setAttribute("aria-expanded", "false");
        }
      }

      function updateMergeUI(data) {
        state.mergeRunning = !!data.running;
        state.mergeExitCode =
          typeof data.exit_code === "number" ? data.exit_code : null;
        state.mergeOutputExists = !!data.output_exists;
        state.mergeStage = data.stage || (state.mergeRunning ? "merging" : "idle");
        updateMergeButtonState();
        let percentText = "";
        if (data.progress && typeof data.progress.percent === "number") {
          percentText = ` ${data.progress.percent.toFixed(1)}%`;
        }
        if (state.mergeStage === "installing") {
          mergeStatus.textContent = "Installing ffmpeg...";
        } else if (state.mergeStage === "merging") {
          mergeStatus.textContent = `Merging book...${percentText}`;
        } else if (state.mergeStage === "done") {
          mergeStatus.textContent = "M4B ready.";
        } else if (state.mergeStage === "failed") {
          mergeStatus.textContent = "Merge failed. Check tts/merge.log.";
        } else {
          mergeStatus.textContent = "";
        }
        updateClearButtonState();
      }

      function toggleBookMenu() {
        if (bookMenuBtn.disabled) {
          return;
        }
        const open = bookMenuPanel.classList.toggle("open");
        bookMenuBtn.setAttribute("aria-expanded", open ? "true" : "false");
      }

      function closeBookMenu() {
        bookMenuPanel.classList.remove("open");
        bookMenuBtn.setAttribute("aria-expanded", "false");
      }

      async function startSynth() {
        if (!state.book) {
          return;
        }
        saveSettings();
        if (state.advancedMode) {
          const saved = await saveVoiceMap();
          if (!saved) {
            setStatus("Failed to save voice map.");
            return;
          }
        }
        state.mergeExitCode = null;
        state.mergeOutputExists = false;
        mergeStatus.textContent = "";
        updateMergeButtonState();
        const payload = {
          book_id: state.book.id,
          voice: getSelectedVoice(),
          use_voice_map: state.advancedMode,
        };
        state.pendingManifestRefresh = !state.chapters.length;
        try {
          await fetchJson("/api/synth/start", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          setStatus("TTS started.");
          await loadSynthStatus();
        } catch (err) {
          setStatus("Failed to start TTS.");
        }
      }

      async function startMerge() {
        if (!state.book) {
          return;
        }
        if (!state.mergeReady) {
          setStatus("Finish TTS before merging.");
          return;
        }
        if (state.mergeOutputExists) {
          setStatus("M4B already exists.");
          return;
        }
        mergeStatus.textContent = "Starting merge...";
        try {
          await fetchJson("/api/merge/start", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ book_id: state.book.id }),
          });
          setStatus("Merge started.");
          await loadMergeStatus();
        } catch (err) {
          mergeStatus.textContent = err.message || "Merge failed to start.";
          setStatus(err.message || "Merge failed to start.");
        }
      }

      function downloadM4b() {
        if (!state.book) {
          return;
        }
        const url = `/api/m4b/download?book_id=${encodeURIComponent(
          state.book.id
        )}`;
        const link = document.createElement("a");
        link.href = url;
        link.download = `${state.book.id}.m4b`;
        document.body.appendChild(link);
        link.click();
        link.remove();
        setStatus("Downloading M4B...");
      }

      async function sampleSynth() {
        if (!state.book) {
          return;
        }
        if (state.advancedMode) {
          setStatus("Sample disabled in Advanced Mode.");
          return;
        }
        if (state.synthRunning) {
          setStatus("Stop TTS before sampling.");
          return;
        }
        saveSettings();
        try {
          await fetchJson("/api/synth/sample", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              book_id: state.book.id,
              voice: getSelectedVoice(),
            }),
          });
          setStatus("Generating sample...");
          await loadSynthStatus();
        } catch (err) {
          setStatus(err.message || "Sample failed.");
        }
      }

      function toggleSample() {
        if (state.synthRunning && state.synthMode === "sample") {
          stopSynth();
        } else {
          sampleSynth();
        }
      }

      async function deleteBook() {
        if (!state.book) {
          return;
        }
        if (state.synthRunning || state.mergeRunning) {
          setStatus("Stop TTS or merge before deleting.");
          return;
        }
        const label = state.book.title || state.book.id;
        const confirmed = window.confirm(
          `Delete "${label}" and all files in this book folder?`
        );
        if (!confirmed) {
          return;
        }
        closeBookMenu();
        setStatus("Deleting book...");
        try {
          await fetchJson("/api/books/delete", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ book_id: state.book.id }),
          });
          clearBookView();
          await loadBooks();
          setStatus("Book deleted.");
        } catch (err) {
          setStatus(err.message || "Failed to delete book.");
        }
      }

      async function clearTtsCache() {
        if (!state.book) {
          return;
        }
        if (state.synthRunning || state.mergeRunning) {
          setStatus("Stop TTS/merge before clearing cache.");
          return;
        }
        const ok = confirm("Delete all TTS segments for this book?");
        if (!ok) {
          return;
        }
        try {
          await fetchJson("/api/tts/clear", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ book_id: state.book.id }),
          });
          setStatus("TTS cache deleted.");
          state.mergeOutputExists = false;
          state.mergeExitCode = null;
          state.mergeStage = "idle";
          mergeStatus.textContent = "";
          updateMergeButtonState();
          await selectBook(state.book.id);
          if (state.editOpen) {
            await loadPreview(state.previewChapterIndex);
          }
        } catch (err) {
          setStatus(err.message || "Failed to clear TTS cache.");
        }
      }

      async function stopSynth() {
        if (!state.book) {
          return;
        }
        try {
          await fetchJson("/api/synth/stop", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ book_id: state.book.id }),
          });
          setStatus("TTS stopped.");
          await loadSynthStatus();
        } catch (err) {
          setStatus("Failed to stop TTS.");
        }
      }

      function toggleSynth() {
        if (state.synthRunning) {
          stopSynth();
        } else {
          startSynth();
        }
      }

      function buildQueue() {
        state.queue = [];
        state.chapterOffsets = {};
        let offset = 0;
        state.chapters.forEach((chapter, chapterIndex) => {
          state.chapterOffsets[chapter.id] = offset;
          const spans = chapter.chunk_spans || [];
          spans.forEach((_span, chunkIndex) => {
            state.queue.push({
              chapterId: chapter.id,
              chapterIndex,
              chunkIndex,
            });
          });
          offset += spans.length;
        });
      }

      function renderChapters() {
        chapterList.innerHTML = "";
        if (!state.chapters.length) {
          chapterList.innerHTML = "<p class=\"empty-state\">No chapters yet.</p>";
          return;
        }
        state.chapters.forEach((chapter) => {
          const item = document.createElement("div");
          item.className = "toc-item";
          if (chapter.id === state.currentChapterId) {
            item.classList.add("active");
          }
          item.innerHTML = `
            <div>${chapter.title}</div>
            <small>${chapter.chunk_count} chunks</small>
          `;
          item.addEventListener("click", () => {
            renderChapter(chapter.id);
            state.currentQueueIndex = state.chapterOffsets[chapter.id] || 0;
            setIdleStatus();
            updateUrl(state.book ? state.book.id : null, chapter.id);
            scrollToTextPane();
          });
          chapterList.appendChild(item);
        });
      }

      function renderChapter(chapterId) {
        const chapter = getChapterById(chapterId);
        if (!chapter) {
          return;
        }
        state.currentChapterId = chapter.id;
        chapterTitle.textContent = chapter.title;
        chapterText.innerHTML = "";
        const cleanText = chapter.clean_text || "";
        const spans = chapter.chunk_spans || [];
        const startIndex = state.chapterOffsets[chapter.id] || 0;
        const paragraphs = splitParagraphSpans(cleanText);
        let spanIndex = 0;

        if (!paragraphs.length) {
          chapterText.innerHTML = "<p class=\"empty-state\">No text available.</p>";
        } else {
          paragraphs.forEach(([paraStart, paraEnd]) => {
            const p = document.createElement("p");
            let cursor = paraStart;

            while (spanIndex < spans.length && spans[spanIndex][1] <= paraStart) {
              spanIndex += 1;
            }

            while (spanIndex < spans.length && spans[spanIndex][0] < paraEnd) {
              const spanEntry = spans[spanIndex];
              const spanStart = spanEntry[0];
              const spanEnd = spanEntry[1];
              if (spanStart > cursor) {
                p.appendChild(
                  document.createTextNode(cleanText.slice(cursor, spanStart))
                );
              }
              const span = document.createElement("span");
              span.className = "chunk";
              span.dataset.queueIndex = startIndex + spanIndex;
              span.textContent = cleanText.slice(spanStart, spanEnd);
              p.appendChild(span);
              cursor = spanEnd;
              spanIndex += 1;
            }

            if (cursor < paraEnd) {
              p.appendChild(
                document.createTextNode(cleanText.slice(cursor, paraEnd))
              );
            }
            chapterText.appendChild(p);
          });
        }
        renderChapters();
        applyLastPlayedHighlight();
        if (state.activeQueueIndex !== null) {
          const activeItem = state.queue[state.activeQueueIndex];
          if (activeItem && activeItem.chapterId === chapter.id) {
            setActiveChunk(state.activeQueueIndex, false);
          }
        }
        updateUrl(state.book ? state.book.id : null, chapter.id);
        updateMarks();
      }

      function setActiveChunk(index, waiting) {
        if (state.activeQueueIndex !== null) {
          const prev = chapterText.querySelector(
            `.chunk[data-queue-index="${state.activeQueueIndex}"]`
          );
          if (prev) {
            prev.classList.remove("active", "waiting");
            prev.classList.add("played");
          }
        }
        const item = state.queue[index];
        if (!item) {
          return;
        }
        if (state.currentChapterId !== item.chapterId) {
          renderChapter(item.chapterId);
        }
        const span = chapterText.querySelector(
          `.chunk[data-queue-index="${index}"]`
        );
        if (span) {
          span.classList.add(waiting ? "waiting" : "active");
          span.classList.remove(waiting ? "active" : "waiting");
          span.scrollIntoView({ block: "center", behavior: "smooth" });
        }
        state.activeQueueIndex = index;
        applyLastPlayedHighlight();
      }

      function hasUnsavedCleanChanges() {
        return (
          state.cleanEditing &&
          editCleanInput.value !== state.cleanEditOriginal
        );
      }

      function setCleanEditMode(enabled) {
        state.cleanEditing = enabled;
        editCleanInput.hidden = !enabled;
        editCleanActions.hidden = !enabled;
        editClean.hidden = enabled;
        editCleanBtn.disabled = enabled;
        editReload.disabled = enabled;
        dropChapterBtn.disabled =
          enabled ||
          !state.previewSelectedTitle ||
          state.previewSelectedKind === "title";
        if (enabled) {
          const text = editClean.textContent || "";
          editCleanInput.value = text;
          state.cleanEditOriginal = text;
          state.cleanEditChapter = state.previewChapterIndex;
          editStatus.textContent = "Editing clean text...";
          setTimeout(() => editCleanInput.focus(), 0);
        } else {
          editCleanInput.value = "";
          state.cleanEditOriginal = "";
          state.cleanEditChapter = null;
        }
      }

      function startCleanEdit() {
        if (!state.book || state.previewChapterIndex === null) {
          editStatus.textContent = "Select a chapter to edit.";
          return;
        }
        setCleanEditMode(true);
      }

      function cancelCleanEdit() {
        if (!state.cleanEditing) {
          return;
        }
        if (hasUnsavedCleanChanges()) {
          const discard = window.confirm("Discard unsaved clean text edits?");
          if (!discard) {
            return;
          }
        }
        setCleanEditMode(false);
        editStatus.textContent = "Edit canceled.";
      }

      async function saveCleanText() {
        if (!state.book || state.previewChapterIndex === null) {
          return;
        }
        const text = editCleanInput.value || "";
        editStatus.textContent = "Saving clean text...";
        try {
          const data = await fetchJson("/api/sanitize/clean", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              book_id: state.book.id,
              chapter_index: state.previewChapterIndex,
              text,
            }),
          });
          setCleanEditMode(false);
          editStatus.textContent = data.tts_cleared
            ? "Saved clean text. TTS cache cleared."
            : "Saved clean text.";
          await selectBook(state.book.id, state.currentChapterId);
          await loadPreview(state.previewChapterIndex);
        } catch (err) {
          editStatus.textContent = err.message || "Failed to save clean text.";
        }
      }

      function parseRuleLines(text) {
        return text
          .split("\n")
          .map((line) => line.trim())
          .filter((line) => line.length > 0);
      }

      function rulesFromForm() {
        return {
          paragraph_breaks: rulesParagraphs.value || "double",
          drop_chapter_title_patterns: parseRuleLines(rulesDrop.value || ""),
          section_cutoff_patterns: parseRuleLines(rulesCutoff.value || ""),
          remove_patterns: parseRuleLines(rulesRemove.value || ""),
          replace_defaults: !!rulesReplace.checked,
        };
      }

      function applyRulesToForm(rules) {
        state.rulesLoading = true;
        rulesParagraphs.value = rules.paragraph_breaks || "double";
        rulesDrop.value = (rules.drop_chapter_title_patterns || []).join("\n");
        rulesCutoff.value = (rules.section_cutoff_patterns || []).join("\n");
        rulesRemove.value = (rules.remove_patterns || []).join("\n");
        rulesReplace.checked = !!rules.replace_defaults;
        state.rulesLoading = false;
      }

      function scheduleRulesSave() {
        if (state.rulesLoading) {
          return;
        }
        if (state.rulesSaveTimer) {
          clearTimeout(state.rulesSaveTimer);
        }
        state.rulesSaveTimer = setTimeout(() => {
          saveRules();
        }, 700);
      }

      async function saveRules() {
        if (!state.book) {
          return;
        }
        const payload = rulesFromForm();
        editStatus.textContent = "Saving rules...";
        try {
          await fetchJson("/api/sanitize/rules", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          editStatus.textContent = "Rules saved.";
          await loadPreview(state.previewChapterIndex);
        } catch (err) {
          editStatus.textContent = err.message || "Failed to save rules.";
        }
      }

      function renderEditChapterList(chapters, selectedIndex) {
        editChapterList.innerHTML = "";
        if (!chapters.length) {
          editChapterList.innerHTML = "<p class=\"empty-state\">No chapters.</p>";
          return;
        }
        chapters.forEach((entry) => {
          const button = document.createElement("button");
          button.type = "button";
          button.className = "edit-chapter-item";
          if (entry.index === selectedIndex) {
            button.classList.add("active");
          }
          const title = entry.title || "Chapter";
          button.textContent = `${entry.index}. ${title}`;
          button.addEventListener("click", () => {
            loadPreview(entry.index);
          });
          editChapterList.appendChild(button);
        });
      }

      function renderDroppedList(items) {
        editDroppedList.innerHTML = "";
        if (!items.length) {
          editDroppedList.innerHTML = "<p class=\"empty-state\">None.</p>";
          return;
        }
        items.forEach((entry) => {
          const row = document.createElement("div");
          row.className = "edit-dropped-item";
          const title = entry.title || "Chapter";
          row.innerHTML = `
            <span>${entry.index}. ${title}</span>
            <button class="btn small" type="button">Restore</button>
          `;
          const button = row.querySelector("button");
          button.addEventListener("click", () =>
            restoreChapter(entry.title, entry.index)
          );
          editDroppedList.appendChild(row);
        });
      }

      async function loadPreview(chapterIndex) {
        if (!state.book) {
          return;
        }
        if (
          state.cleanEditing &&
          chapterIndex !== undefined &&
          chapterIndex !== null &&
          chapterIndex !== state.cleanEditChapter
        ) {
          if (hasUnsavedCleanChanges()) {
            const discard = window.confirm(
              "Discard unsaved clean text edits?"
            );
            if (!discard) {
              return;
            }
          }
          setCleanEditMode(false);
        }
        const params = new URLSearchParams();
        params.set("book_id", state.book.id);
        if (chapterIndex) {
          params.set("chapter", chapterIndex);
        }
        try {
          const data = await fetchJson(`/api/sanitize/preview?${params.toString()}`);
          const selected = data.selected || {};
          state.previewChapterIndex = selected.index || null;
          state.previewSelectedTitle = selected.title || "";
          state.previewSelectedKind = selected.kind || "";
          if (selected.title) {
            const prefix = selected.index ? `${selected.index}. ` : "";
            editSelectedTitle.textContent = `${prefix}${selected.title}`;
          } else {
            editSelectedTitle.textContent = "Select a chapter";
          }
          dropChapterBtn.disabled =
            !selected.title || selected.kind === "title" || state.cleanEditing;
          editRaw.innerHTML = data.raw_text || "";
          const selectedIndex =
            typeof selected.index === "number"
              ? selected.index
              : state.previewChapterIndex;
          const preserveClean =
            state.cleanEditing && state.cleanEditChapter === selectedIndex;
          if (!preserveClean) {
            editClean.textContent = data.clean_text || "";
            editCleanInput.value = data.clean_text || "";
          }
          renderEditChapterList(data.chapters || [], selected.index);
          renderDroppedList(data.dropped || []);
          if (!state.cleanEditing) {
            applyRulesToForm(data.rules || {});
          }
          editStatus.textContent = "";
        } catch (err) {
          editStatus.textContent = err.message || "Failed to load preview.";
        }
      }

      function toggleEditPanel() {
        state.editOpen = !state.editOpen;
        editPanel.classList.toggle("open", state.editOpen);
        editToggle.textContent = state.editOpen ? "Close" : "Edit";
        if (state.editOpen) {
          loadPreview(state.previewChapterIndex);
        } else if (state.cleanEditing) {
          setCleanEditMode(false);
        }
      }

      async function dropSelectedChapter() {
        if (!state.book || !state.previewSelectedTitle) {
          return;
        }
        try {
          const data = await fetchJson("/api/sanitize/drop", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              book_id: state.book.id,
              title: state.previewSelectedTitle,
              chapter_index: state.previewChapterIndex,
            }),
          });
          editStatus.textContent = data.dropped
            ? "Chapter dropped."
            : "Chapter already dropped.";
          await selectBook(state.book.id);
        } catch (err) {
          editStatus.textContent = err.message || "Failed to drop chapter.";
        }
      }

      async function restoreChapter(title, chapterIndex) {
        if (!state.book || !title) {
          return;
        }
        try {
          const data = await fetchJson("/api/sanitize/restore", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              book_id: state.book.id,
              title,
              chapter_index: chapterIndex,
            }),
          });
          editStatus.textContent = data.restored
            ? "Chapter restored."
            : "Chapter already restored.";
          await selectBook(state.book.id);
        } catch (err) {
          editStatus.textContent = err.message || "Failed to restore chapter.";
        }
      }

      async function runSanitize() {
        if (!state.book) {
          return;
        }
        editStatus.textContent = "Sanitizing...";
        try {
          const data = await fetchJson("/api/sanitize/run", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ book_id: state.book.id }),
          });
          const cleared = data.tts_cleared ? " TTS cache cleared." : "";
          editStatus.textContent = `Sanitized.${cleared}`;
          await selectBook(state.book.id);
          await loadPreview(state.previewChapterIndex);
        } catch (err) {
          editStatus.textContent = err.message || "Sanitize failed.";
        }
      }

      async function chunkExists(item) {
        const chunkNum = item.chunkIndex + 1;
        const url = `/api/chunk-status?book_id=${encodeURIComponent(
          state.book.id
        )}&chapter_id=${encodeURIComponent(
          item.chapterId
        )}&chunk=${chunkNum}`;
        const data = await fetchJson(url);
        return data.exists;
      }

      function chunkUrl(item) {
        const chunkNum = item.chunkIndex + 1;
        return `${state.audioBase}/${item.chapterId}/${pad6(chunkNum)}.wav`;
      }

      function resetAudioPlayers() {
        [audio, audioNext].forEach((element) => {
          element.ontimeupdate = null;
          element.pause();
          element.removeAttribute("src");
          element.load();
        });
        currentAudio = audio;
        nextAudio = audioNext;
        state.preloadedIndex = null;
        state.gaplessArmedIndex = null;
        setPlayButton(false);
      }

      function setPlayButton(isPlaying) {
        playBtn.classList.toggle("is-playing", isPlaying);
        playBtn.setAttribute("aria-label", isPlaying ? "Pause" : "Play");
        playBtn.title = isPlaying ? "Pause" : "Play";
      }

      function setPlaybackRate(rate) {
        currentAudio.playbackRate = rate;
        nextAudio.playbackRate = rate;
      }

      function setSpeedRate(rate) {
        state.playbackRate = rate;
        speedValue.textContent = `${rate.toFixed(1)}x`;
        setPlaybackRate(rate);
      }

      function clearPreload() {
        state.preloadedIndex = null;
        nextAudio.pause();
        nextAudio.removeAttribute("src");
        nextAudio.load();
      }

      function usePreloadedAudio(index) {
        if (state.preloadedIndex !== index || !nextAudio.src) {
          return false;
        }
        currentAudio.pause();
        [currentAudio, nextAudio] = [nextAudio, currentAudio];
        clearPreload();
        return true;
      }

      function clearGapless() {
        state.gaplessArmedIndex = null;
        currentAudio.ontimeupdate = null;
      }

      function gaplessTailSeconds() {
        const padMs = Number(state.padMs) || 0;
        if (!padMs) {
          return 0;
        }
        return Math.min(0.2, padMs / 1000);
      }

      function armGapless(index) {
        clearGapless();
        const tailSec = gaplessTailSeconds();
        if (!tailSec) {
          return;
        }
        state.gaplessArmedIndex = index;
        currentAudio.ontimeupdate = () => {
          if (state.gaplessArmedIndex !== index) {
            return;
          }
          if (currentAudio.paused) {
            return;
          }
          const duration = currentAudio.duration;
          if (!duration || Number.isNaN(duration)) {
            return;
          }
          const remaining = duration - currentAudio.currentTime;
          if (remaining > tailSec) {
            return;
          }
          currentAudio.ontimeupdate = null;
          const nextIndex = index + 1;
          if (state.preloadedIndex === nextIndex && nextAudio.src) {
            playIndex(nextIndex);
          }
        };
      }

      async function preloadIndex(index) {
        if (!state.queue.length) {
          return;
        }
        if (index < 0 || index >= state.queue.length) {
          clearPreload();
          return;
        }
        if (state.preloadedIndex === index && nextAudio.src) {
          return;
        }
        const item = state.queue[index];
        let available = false;
        if (state.preloadedIndex === index && nextAudio.src) {
          available = true;
        } else {
          try {
            available = await chunkExists(item);
          } catch (err) {
            available = false;
          }
        }
        if (!available) {
          return;
        }
        nextAudio.src = chunkUrl(item);
        nextAudio.load();
        nextAudio.playbackRate = state.playbackRate || 1;
        state.preloadedIndex = index;
      }

      async function playIndex(index) {
        if (!state.queue.length) {
          return;
        }
        if (index < 0 || index >= state.queue.length) {
          setStatus("End of book.");
          currentAudio.pause();
          clearGapless();
          return;
        }
        state.playTransitioning = true;
        try {
          clearGapless();
          const item = state.queue[index];
          state.currentQueueIndex = index;
          setLastPlayed(index);
          setActiveChunk(index, true);
          setStatus(`Waiting for chunk ${index + 1} of ${state.queue.length}...`);
          updateMarks();

          let available = false;
          try {
            available = await chunkExists(item);
          } catch (err) {
            available = false;
          }

          if (!available) {
            waitForChunk(index);
            currentAudio.pause();
            setPlayButton(false);
            setStatus("Chunk not ready. Press Play to retry.");
            return;
          }

          if (state.waitTimer) {
            clearTimeout(state.waitTimer);
          }
          state.waitingFor = null;
          setActiveChunk(index, false);
          const usedPreload = usePreloadedAudio(index);
          if (!usedPreload) {
            clearPreload();
            currentAudio.pause();
            currentAudio.src = chunkUrl(item);
            currentAudio.load();
          }
          setPlaybackRate(state.playbackRate || 1);
          try {
            await currentAudio.play();
            setStatus(
              `Playing ${item.chapterId} ${item.chunkIndex + 1} / ${state.queue.length}`
            );
            setPlayButton(true);
          } catch (err) {
            setStatus("Press Play to start audio.");
            setPlayButton(false);
          }
          armGapless(index);
          void preloadIndex(index + 1);
        } finally {
          state.playTransitioning = false;
        }
      }

      function waitForChunk(index) {
        state.waitingFor = index;
        if (state.waitTimer) {
          clearTimeout(state.waitTimer);
        }
        state.waitTimer = null;
      }

      function togglePlay() {
        if (!state.queue.length) {
          return;
        }
        if (currentAudio.paused) {
          const lastIndex = getLastPlayed();
          const startIndex = lastIndex === null ? 0 : lastIndex;
          playIndex(startIndex);
        } else {
          currentAudio.pause();
          setPlayButton(false);
          setIdleStatus();
          clearGapless();
        }
      }

      function nextChunk() {
        playIndex(state.currentQueueIndex + 1);
      }

      function prevChunk() {
        playIndex(Math.max(0, state.currentQueueIndex - 1));
      }

      playBtn.addEventListener("click", togglePlay);
      prevBtn.addEventListener("click", prevChunk);
      nextBtn.addEventListener("click", nextChunk);
      uploadZone.addEventListener("click", () => {
        if (state.ingestRunning) {
          return;
        }
        uploadInput.click();
      });
      uploadZone.addEventListener("keydown", (event) => {
        if (event.key === "Enter" || event.key === " ") {
          event.preventDefault();
          if (!state.ingestRunning) {
            uploadInput.click();
          }
        }
      });
      uploadZone.addEventListener("dragover", (event) => {
        event.preventDefault();
        if (state.ingestRunning) {
          return;
        }
        uploadZone.classList.add("dragover");
      });
      uploadZone.addEventListener("dragleave", () => {
        uploadZone.classList.remove("dragover");
      });
      uploadZone.addEventListener("drop", (event) => {
        event.preventDefault();
        uploadZone.classList.remove("dragover");
        if (state.ingestRunning) {
          return;
        }
        const file = event.dataTransfer?.files?.[0];
        ingestFile(file);
      });
      uploadInput.addEventListener("change", () => {
        const file = uploadInput.files ? uploadInput.files[0] : null;
        ingestFile(file);
      });
      startTts.addEventListener("click", toggleSynth);
      sampleTts.addEventListener("click", toggleSample);
      mergeBtn.addEventListener("click", () => {
        if (state.mergeOutputExists && !state.mergeRunning) {
          downloadM4b();
        } else {
          startMerge();
        }
      });
      clearTtsBtn.addEventListener("click", clearTtsCache);
      bookMenuBtn.addEventListener("click", toggleBookMenu);
      document.addEventListener("click", (event) => {
        if (!bookMenuPanel.classList.contains("open")) {
          return;
        }
        const target = event.target;
        if (
          target === bookMenuBtn ||
          bookMenuPanel.contains(target)
        ) {
          return;
        }
        closeBookMenu();
      });
      deleteBookBtn.addEventListener("click", deleteBook);
      editToggle.addEventListener("click", toggleEditPanel);
      sanitizeBtn.addEventListener("click", runSanitize);
      editReload.addEventListener("click", () => loadPreview(state.previewChapterIndex));
      dropChapterBtn.addEventListener("click", dropSelectedChapter);
      editCleanBtn.addEventListener("click", startCleanEdit);
      saveCleanBtn.addEventListener("click", saveCleanText);
      cancelCleanBtn.addEventListener("click", cancelCleanEdit);
      rulesDrop.addEventListener("input", scheduleRulesSave);
      rulesCutoff.addEventListener("input", scheduleRulesSave);
      rulesRemove.addEventListener("input", scheduleRulesSave);
      rulesParagraphs.addEventListener("change", scheduleRulesSave);
      rulesReplace.addEventListener("change", scheduleRulesSave);
      bookmarkBtn.addEventListener("click", () => {
        if (bookmarkPanel.classList.contains("open")) {
          closeBookmarkPanel();
        } else {
          openBookmarkPanel();
        }
      });
      bookmarkList.addEventListener("click", (event) => {
        const target = event.target;
        if (!target || !target.dataset || !target.dataset.action) {
          return;
        }
        const action = target.dataset.action;
        const index = parseInt(target.dataset.index, 10);
        if (Number.isNaN(index)) {
          return;
        }
        if (action === "play" || action === "play-furthest") {
          jumpToIndex(index, true);
          closeBookmarkPanel();
          return;
        }
        if (action === "remove") {
          removeBookmark(index);
          updateMarks();
          setStatus("Bookmark removed.");
        }
      });
      saveBookmarkBtn.addEventListener("click", () => {
        if (!state.queue.length) {
          return;
        }
        addBookmark(state.currentQueueIndex);
        updateMarks();
        setStatus("Bookmark saved.");
      });
      advancedToggle.addEventListener("click", () => {
        state.advancedMode = !state.advancedMode;
        updateAdvancedMode();
      });
      advancedSelectAll.addEventListener("change", () => {
        if (!state.book) {
          return;
        }
        if (advancedSelectAll.checked) {
          state.advancedSelection = new Set(
            state.chapters.map((chapter) => chapter.id).filter(Boolean)
          );
        } else {
          state.advancedSelection = new Set();
        }
        renderAdvancedList();
      });
      advancedApplyVoice.addEventListener("click", () => {
        const value = advancedBulkVoice.value;
        if (!value) {
          return;
        }
        state.advancedSelection.forEach((chapterId) => {
          if (value === "default") {
            delete state.voiceMap.chapters[chapterId];
          } else {
            state.voiceMap.chapters[chapterId] = value;
          }
        });
        scheduleVoiceMapSave();
        renderAdvancedList();
      });
      advancedClearVoice.addEventListener("click", () => {
        state.advancedSelection.forEach((chapterId) => {
          delete state.voiceMap.chapters[chapterId];
        });
        scheduleVoiceMapSave();
        renderAdvancedList();
      });
      ttsToggle.addEventListener("click", () => {
        ttsPanel.classList.toggle("collapsed");
        ttsToggle.textContent = ttsPanel.classList.contains("collapsed")
          ? "Expand"
          : "Collapse";
        localStorage.setItem(
          "ptts.ttsCollapsed",
          ttsPanel.classList.contains("collapsed") ? "1" : "0"
        );
      });
      if (themeToggle) {
        themeToggle.addEventListener("click", cycleTheme);
      }
      function handleEnded(event) {
        if (event.target !== currentAudio) {
          return;
        }
        if (state.playTransitioning) {
          return;
        }
        playIndex(state.currentQueueIndex + 1);
      }
      audio.addEventListener("ended", handleEnded);
      audioNext.addEventListener("ended", handleEnded);

      speedBtn.addEventListener("click", () => {
        const steps = [0.8, 1.0, 1.2, 1.4, 1.6, 1.8, 2.0];
        const current = state.playbackRate || 1.0;
        const idx = steps.findIndex((val) => Math.abs(val - current) < 0.01);
        const next = idx === -1 ? 1.0 : steps[(idx + 1) % steps.length];
        setSpeedRate(next);
      });
      jumpShelf.addEventListener("click", scrollToBookSection);

      chapterText.addEventListener("click", (event) => {
        const target = event.target;
        if (target && target.classList.contains("chunk")) {
          const index = parseInt(target.dataset.queueIndex, 10);
          if (!Number.isNaN(index)) {
            playIndex(index);
          }
        }
      });
      updateMergeButtonState();
      updateClearButtonState();
      loadSettings();
      loadVoices();
      readUrlState();
      loadBooks();

      let lastTouchEnd = 0;
      document.addEventListener(
        "touchend",
        (event) => {
          const now = Date.now();
          if (now - lastTouchEnd <= 300) {
            event.preventDefault();
          }
          lastTouchEnd = now;
        },
        { passive: false }
      );
    </script>
  </body>
</html>
