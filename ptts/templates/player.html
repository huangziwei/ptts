<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>pTTS player</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Fraunces:opsz,wght@9..144,600&family=Source+Serif+4:wght@400;600&family=Work+Sans:wght@400;600&display=swap");

      :root {
        color-scheme: light;
        --bg: #f6f1ea;
        --panel: #fffaf2;
        --panel-2: #f1e8dc;
        --ink: #2c2620;
        --muted: #7b7066;
        --accent: #1d7f6e;
        --accent-2: #e07a5f;
        --accent-ink: #fff;
        --highlight: #fff0c2;
        --shadow: 0 12px 30px rgba(32, 28, 24, 0.15);
        --shadow-accent: 0 10px 24px rgba(29, 127, 110, 0.18);
        --shadow-pop: 0 12px 24px rgba(30, 25, 20, 0.18);
        --shadow-float: 0 8px 18px rgba(32, 28, 24, 0.2);
        --shadow-top: 0 -8px 20px rgba(30, 25, 20, 0.12);
        --bg-gradient: linear-gradient(130deg, #f6f1ea 0%, #f2e8da 40%, #e9f2ef 100%);
        --line: #eadfd2;
        --line-strong: #d8caba;
        --surface: #fffdf9;
        --surface-2: #fff;
        --surface-muted: #f2e2c7;
        --surface-soft: #efe5d8;
        --surface-soft-2: #e6d9cb;
        --surface-highlight: #fff4d6;
        --surface-wait: #fde2cf;
        --surface-drag: #f0faf7;
        --text-soft: #8a7a6e;
        --text-dim: #897d72;
        --active-ink: #3a2e22;
        --danger: #b04838;
        --danger-ink: #fff;
        --success-bg: #e4f3ee;
        --success-border: #a6d2c8;
        --success-ink: #1d7f6e;
        --subtle-bg: #faf6f0;
        --subtle-border: #e6d9cb;
        --subtle-ink: #6f6358;
        --bookmark-bg: #f7efe3;
        --bookmark-ink: #50463f;
        --mark-bg: #ffe4a8;
        --cover-gradient: linear-gradient(150deg, #f2cc8f, #e07a5f);
        --cover-gradient-large: linear-gradient(160deg, #f2cc8f, #e07a5f);
        --text-pane-bg: rgba(255, 255, 255, 0.9);
        --library-bg: rgba(255, 250, 242, 0.9);
        --player-bar-bg: #fffdf9;
        --jump-bg: rgba(123, 112, 102, 0.75);
        --jump-border: rgba(123, 112, 102, 0.6);
        --jump-hover-bg: rgba(123, 112, 102, 0.9);
        --radius: 16px;
        --cover-thumb-height: 70px;
        --ui: "Work Sans", "Segoe UI", sans-serif;
        --read: "Source Serif 4", Georgia, serif;
        --title: "Fraunces", "Times New Roman", serif;
      }

      @media (prefers-color-scheme: dark) {
        :root {
          color-scheme: dark;
          --bg: #14110e;
          --panel: #1b1814;
          --panel-2: #221e19;
          --ink: #f5efe6;
          --muted: #b9ada0;
          --accent: #2fa88f;
          --accent-2: #f0a269;
          --accent-ink: #fff;
          --highlight: #f2b56b;
          --shadow: 0 16px 36px rgba(0, 0, 0, 0.35);
          --shadow-accent: 0 12px 26px rgba(47, 168, 143, 0.35);
          --shadow-pop: 0 18px 36px rgba(0, 0, 0, 0.45);
          --shadow-float: 0 10px 22px rgba(0, 0, 0, 0.5);
          --shadow-top: 0 -10px 26px rgba(0, 0, 0, 0.55);
          --bg-gradient: linear-gradient(130deg, #14110e 0%, #1a1613 45%, #0f1a17 100%);
          --line: #2c2621;
          --line-strong: #3b332c;
          --surface: #1c1916;
          --surface-2: #241f1a;
          --surface-muted: #2b241e;
          --surface-soft: #241f1a;
          --surface-soft-2: #312a23;
          --surface-highlight: #2c241b;
          --surface-wait: #2f211b;
          --surface-drag: #1b2a26;
          --text-soft: #a79c90;
          --text-dim: #7f756a;
          --active-ink: #f4eadc;
          --danger: #d56a59;
          --danger-ink: #fff;
          --success-bg: #1c3a32;
          --success-border: #2f5b51;
          --success-ink: #bfe9de;
          --subtle-bg: #221d19;
          --subtle-border: #353029;
          --subtle-ink: #c0b6ab;
          --bookmark-bg: #1f1b17;
          --bookmark-ink: #d8cec2;
          --mark-bg: #4b3520;
          --cover-gradient: linear-gradient(150deg, #8a5a32, #d17c46);
          --cover-gradient-large: linear-gradient(160deg, #8a5a32, #d17c46);
          --text-pane-bg: rgba(26, 22, 19, 0.96);
          --library-bg: rgba(23, 20, 18, 0.9);
          --player-bar-bg: #1b1814;
          --jump-bg: rgba(72, 61, 54, 0.88);
          --jump-border: rgba(140, 125, 112, 0.65);
          --jump-hover-bg: rgba(92, 79, 70, 0.95);
        }
      }

      :root.theme-switching *,
      :root.theme-switching *::before,
      :root.theme-switching *::after {
        transition: none !important;
      }

      :root[data-theme="light"] {
        color-scheme: light;
        --bg: #f6f1ea;
        --panel: #fffaf2;
        --panel-2: #f1e8dc;
        --ink: #2c2620;
        --muted: #7b7066;
        --accent: #1d7f6e;
        --accent-2: #e07a5f;
        --accent-ink: #fff;
        --highlight: #fff0c2;
        --shadow: 0 12px 30px rgba(32, 28, 24, 0.15);
        --shadow-accent: 0 10px 24px rgba(29, 127, 110, 0.18);
        --shadow-pop: 0 12px 24px rgba(30, 25, 20, 0.18);
        --shadow-float: 0 8px 18px rgba(32, 28, 24, 0.2);
        --shadow-top: 0 -8px 20px rgba(30, 25, 20, 0.12);
        --bg-gradient: linear-gradient(130deg, #f6f1ea 0%, #f2e8da 40%, #e9f2ef 100%);
        --line: #eadfd2;
        --line-strong: #d8caba;
        --surface: #fffdf9;
        --surface-2: #fff;
        --surface-muted: #f2e2c7;
        --surface-soft: #efe5d8;
        --surface-soft-2: #e6d9cb;
        --surface-highlight: #fff4d6;
        --surface-wait: #fde2cf;
        --surface-drag: #f0faf7;
        --text-soft: #8a7a6e;
        --text-dim: #897d72;
        --active-ink: #3a2e22;
        --danger: #b04838;
        --danger-ink: #fff;
        --success-bg: #e4f3ee;
        --success-border: #a6d2c8;
        --success-ink: #1d7f6e;
        --subtle-bg: #faf6f0;
        --subtle-border: #e6d9cb;
        --subtle-ink: #6f6358;
        --bookmark-bg: #f7efe3;
        --bookmark-ink: #50463f;
        --mark-bg: #ffe4a8;
        --cover-gradient: linear-gradient(150deg, #f2cc8f, #e07a5f);
        --cover-gradient-large: linear-gradient(160deg, #f2cc8f, #e07a5f);
        --text-pane-bg: rgba(255, 255, 255, 0.9);
        --library-bg: rgba(255, 250, 242, 0.9);
        --player-bar-bg: #fffdf9;
        --jump-bg: rgba(123, 112, 102, 0.75);
        --jump-border: rgba(123, 112, 102, 0.6);
        --jump-hover-bg: rgba(123, 112, 102, 0.9);
      }

      :root[data-theme="dark"] {
        color-scheme: dark;
        --bg: #14110e;
        --panel: #1b1814;
        --panel-2: #221e19;
        --ink: #f5efe6;
        --muted: #b9ada0;
        --accent: #2fa88f;
        --accent-2: #f0a269;
        --accent-ink: #fff;
        --highlight: #f2b56b;
        --shadow: 0 16px 36px rgba(0, 0, 0, 0.35);
        --shadow-accent: 0 12px 26px rgba(47, 168, 143, 0.35);
        --shadow-pop: 0 18px 36px rgba(0, 0, 0, 0.45);
        --shadow-float: 0 10px 22px rgba(0, 0, 0, 0.5);
        --shadow-top: 0 -10px 26px rgba(0, 0, 0, 0.55);
        --bg-gradient: linear-gradient(130deg, #14110e 0%, #1a1613 45%, #0f1a17 100%);
        --line: #2c2621;
        --line-strong: #3b332c;
        --surface: #1c1916;
        --surface-2: #241f1a;
        --surface-muted: #2b241e;
        --surface-soft: #241f1a;
        --surface-soft-2: #312a23;
        --surface-highlight: #2c241b;
        --surface-wait: #2f211b;
        --surface-drag: #1b2a26;
        --text-soft: #a79c90;
        --text-dim: #7f756a;
        --active-ink: #f4eadc;
        --danger: #d56a59;
        --danger-ink: #fff;
        --success-bg: #1c3a32;
        --success-border: #2f5b51;
        --success-ink: #bfe9de;
        --subtle-bg: #221d19;
        --subtle-border: #353029;
        --subtle-ink: #c0b6ab;
        --bookmark-bg: #1f1b17;
        --bookmark-ink: #d8cec2;
        --mark-bg: #4b3520;
        --cover-gradient: linear-gradient(150deg, #8a5a32, #d17c46);
        --cover-gradient-large: linear-gradient(160deg, #8a5a32, #d17c46);
        --text-pane-bg: rgba(26, 22, 19, 0.96);
        --library-bg: rgba(23, 20, 18, 0.9);
        --player-bar-bg: #1b1814;
        --jump-bg: rgba(72, 61, 54, 0.88);
        --jump-border: rgba(140, 125, 112, 0.65);
        --jump-hover-bg: rgba(92, 79, 70, 0.95);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: var(--ui);
        color: var(--ink);
        background-color: var(--bg);
        background: var(--bg-gradient);
        touch-action: manipulation;
      }

      .app {
        display: grid;
        grid-template-columns: 280px 1fr;
        min-height: 100vh;
      }

      .library {
        padding: 24px 20px;
        background: var(--library-bg);
        border-right: 1px solid var(--line);
        position: sticky;
        top: 0;
        height: 100vh;
        overflow-y: auto;
        padding-bottom: 140px;
        animation: fade-up 0.6s ease;
      }

      .brand {
        font-family: var(--title);
        font-size: 22px;
        letter-spacing: 0.5px;
        margin-bottom: 8px;
      }

      .library-header .brand {
        margin-bottom: 0;
      }

      .root-path {
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 16px;
      }

      .upload-panel {
        display: grid;
        gap: 8px;
        margin-bottom: 16px;
      }

      .upload-zone {
        border: 1px dashed var(--line-strong);
        border-radius: 14px;
        padding: 12px;
        text-align: center;
        background: var(--surface);
        cursor: pointer;
        transition: border 0.2s ease, background 0.2s ease;
        min-height: var(--cover-thumb-height);
        display: flex;
        flex-direction: column;
        justify-content: center;
      }

      .upload-zone strong {
        display: block;
        font-size: 12px;
        font-weight: 600;
      }

      .upload-zone span {
        display: block;
        font-size: 11px;
        color: var(--muted);
        margin-top: 2px;
      }

      .upload-zone.dragover {
        border-color: var(--accent);
        background: var(--surface-drag);
      }

      .upload-zone.disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .upload-status {
        font-size: 11px;
        color: var(--muted);
        min-height: 14px;
      }

      .upload-status[data-tone="error"] {
        color: var(--danger);
      }

      .library-tabs {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 6px;
        margin-bottom: 16px;
        padding: 4px;
        border-radius: 999px;
        border: 1px solid var(--line);
        background: var(--surface-2);
      }

      .library-tabs[hidden] {
        display: none !important;
      }

      .library-shelf-tabs {
        margin-bottom: 8px;
      }

      .library-tab {
        border: none;
        background: transparent;
        color: var(--text-soft);
        padding: 6px 8px;
        border-radius: 999px;
        font-size: 11px;
        font-weight: 600;
        letter-spacing: 0.6px;
        text-transform: uppercase;
        cursor: pointer;
        transition: background 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
      }

      .library-tab.active {
        background: var(--surface-highlight);
        color: var(--active-ink);
        box-shadow: var(--shadow-float);
      }

      .book-list {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .book-card {
        display: grid;
        grid-template-columns: 52px 1fr;
        gap: 12px;
        padding: 10px;
        border-radius: 14px;
        border: 1px solid var(--line);
        background: var(--surface);
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease, border 0.2s ease;
      }

      .book-card.finished {
        border-color: var(--success-border);
        background: linear-gradient(135deg, var(--success-bg), var(--surface));
        box-shadow: var(--shadow);
      }

      .book-card:hover {
        transform: translateY(-2px);
        box-shadow: var(--shadow);
      }

      .book-card.active {
        border-color: var(--accent);
        box-shadow: var(--shadow-accent);
      }

      .book-cover {
        width: 52px;
        height: var(--cover-thumb-height);
        border-radius: 10px;
        background: var(--cover-gradient);
        overflow: hidden;
      }

      .book-cover img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .cover-fallback {
        position: relative;
        width: 100%;
        height: 100%;
        border-radius: inherit;
        display: flex;
        flex-direction: column;
        justify-content: flex-end;
        gap: var(--cover-gap, 4px);
        padding: var(--cover-pad, 6px);
        background: linear-gradient(
          140deg,
          var(--cover-bg),
          var(--cover-bg-2)
        );
        color: var(--cover-ink);
      }

      .cover-fallback::before {
        content: "";
        position: absolute;
        inset: -30% -40% auto -40%;
        height: 45%;
        background: linear-gradient(
          120deg,
          transparent,
          var(--cover-accent),
          transparent
        );
        opacity: 0.35;
        transform: rotate(var(--cover-tilt));
      }

      .cover-fallback::after {
        content: "";
        position: absolute;
        inset: auto 0 0 0;
        height: var(--cover-band);
        background: var(--cover-accent);
        opacity: 0.25;
      }

      .cover-text {
        position: relative;
        z-index: 1;
        display: grid;
        gap: 3px;
        text-shadow: 0 1px 1px rgba(0, 0, 0, 0.18);
      }

      .cover-title {
        font-family: var(--title);
        font-size: var(--cover-title-size, 11px);
        line-height: var(--cover-title-leading, 1.1);
        word-break: break-word;
        hyphens: auto;
      }

      .cover-meta {
        font-size: var(--cover-meta-size, 8px);
        line-height: var(--cover-meta-leading, 1.15);
        text-transform: uppercase;
        letter-spacing: 0.4px;
        word-break: break-word;
        hyphens: auto;
      }

      .cover-fallback.small {
        --cover-title-size: 9px;
        --cover-meta-size: 7px;
        --cover-pad: 5px;
      }

      .cover-fallback.large {
        --cover-title-size: 14px;
        --cover-meta-size: 10px;
        --cover-pad: 12px;
      }

      .book-meta h4 {
        margin: 0 0 4px;
        font-size: 14px;
        font-weight: 600;
      }

      .book-meta p {
        margin: 0;
        font-size: 12px;
        color: var(--muted);
      }

      .book-status {
        display: flex;
        align-items: center;
        gap: 6px;
        flex-wrap: wrap;
      }

      .book-tag {
        display: inline-flex;
        align-items: center;
        padding: 2px 8px;
        border-radius: 999px;
        font-size: 10px;
        font-weight: 600;
        letter-spacing: 0.6px;
        text-transform: uppercase;
        border: 1px solid var(--line-strong);
        color: var(--muted);
        background: var(--surface-2);
      }

      .book-tag.finished {
        background: var(--success-bg);
        border-color: var(--success-border);
        color: var(--success-ink);
      }

      .reader {
        padding: 28px 18px 120px;
        animation: fade-up 0.6s ease;
      }

      .reader-header {
        display: flex;
        gap: 20px;
        align-items: center;
        margin-bottom: 24px;
      }

      .tts-panel {
        background: var(--panel);
        border-radius: var(--radius);
        padding: 16px 18px;
        border: 1px solid var(--line);
        margin-bottom: 24px;
        box-shadow: var(--shadow);
      }

      .tts-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      .tts-header-actions {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .tts-toggle {
        border: 1px solid var(--line-strong);
        background: var(--surface-2);
        color: var(--ink);
        padding: 6px 12px;
        border-radius: 999px;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
      }

      .tts-toggle.mode-on {
        background: var(--accent);
        border-color: var(--accent);
        color: var(--accent-ink);
      }

      .tts-toggle.mode-off {
        background: var(--surface-2);
        border-color: var(--line-strong);
        color: var(--ink);
      }

      .tts-panel.collapsed .tts-grid,
      .tts-panel.collapsed .tts-actions,
      .tts-panel.collapsed .advanced-panel {
        display: none;
      }

      .tts-panel h3 {
        margin-bottom: 6px; 
        font-size: 13px;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: var(--muted);
      }

      .tts-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 12px;
        margin-bottom: 12px;
      }

      .tts-field label {
        display: block;
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 4px;
      }

      .tts-field input,
      .tts-field select {
        width: 100%;
        padding: 8px 10px;
        border-radius: 10px;
        border: 1px solid var(--line-strong);
        background: var(--surface-2);
        color: var(--ink);
        font-family: var(--ui);
      }

      .voice-groups {
        display: grid;
        gap: 10px;
      }

      .voice-group-title {
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.6px;
        color: var(--muted);
        margin-bottom: 6px;
      }

      .voice-buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .local-voice-row {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
      }

      .local-voice-section {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 8px;
        border: 1px solid var(--line);
        border-radius: 999px;
        background: var(--surface);
      }

      .local-voice-section-label {
        font-size: 10px;
        text-transform: uppercase;
        letter-spacing: 0.6px;
        color: var(--muted);
      }

      .local-voice-section-buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }

      .local-voice-section-buttons .voice-button {
        padding: 5px 10px;
      }

      .voice-button {
        border: 1px solid var(--line-strong);
        background: var(--surface-2);
        color: var(--ink);
        padding: 6px 12px;
        border-radius: 999px;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
      }

      .voice-button.voice-action {
        min-width: 30px;
        padding: 6px 0;
        font-size: 14px;
        line-height: 1;
      }

      .voice-button.voice-action.edit-mode {
        padding: 6px 10px;
        font-size: 11px;
        line-height: 1.2;
      }

      .voice-button.active {
        background: var(--accent);
        border-color: var(--accent);
        color: var(--accent-ink);
      }

      .voice-button:focus-visible {
        outline: 2px solid var(--accent-2);
        outline-offset: 2px;
      }

      .voice-empty {
        font-size: 12px;
        color: var(--muted);
      }

      .advanced-panel {
        margin: 12px 0;
        padding: 10px;
        border-radius: 12px;
        border: 1px solid var(--line);
        background: var(--surface);
        display: none;
      }

      .advanced-panel.open {
        display: block;
      }

      .advanced-header {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-bottom: 10px;
      }

      .advanced-title {
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.8px;
        color: var(--muted);
      }

      .advanced-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
        font-size: 12px;
        color: var(--muted);
      }

      .advanced-actions label {
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .advanced-actions select {
        padding: 6px 8px;
        border-radius: 8px;
        border: 1px solid var(--line-strong);
        font-family: var(--ui);
        font-size: 12px;
        background: var(--surface-2);
        color: var(--ink);
      }

      .advanced-list {
        display: flex;
        flex-direction: column;
        gap: 6px;
        max-height: 260px;
        overflow-y: auto;
      }

      .advanced-row {
        display: grid;
        grid-template-columns: 22px 1fr 180px;
        gap: 10px;
        align-items: center;
        padding: 6px 8px;
        border-radius: 10px;
        border: 1px solid var(--line);
        background: var(--surface-2);
      }

      .advanced-row.selected {
        background: var(--surface-muted);
      }

      .advanced-meta {
        font-size: 11px;
        color: var(--muted);
      }

      .advanced-select {
        width: 100%;
        padding: 6px 8px;
        border-radius: 8px;
        border: 1px solid var(--line-strong);
        font-family: var(--ui);
        font-size: 12px;
        background: var(--surface-2);
        color: var(--ink);
      }

      .tts-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        align-items: center;
        margin-bottom: 12px;
      }

      .tts-divider {
        width: 1px;
        height: 24px;
        background: var(--surface-soft-2);
        border-radius: 999px;
      }

      .tts-delete {
        margin-left: auto;
      }

      .tts-actions label {
        font-size: 13px;
        color: var(--muted);
        display: flex;
        gap: 6px;
        align-items: center;
      }

      .progress-track {
        width: 100%;
        height: 10px;
        background: var(--surface-soft);
        border-radius: 999px;
        overflow: hidden;
      }

      .progress-fill {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, var(--accent), var(--accent-2));
        transition: width 0.3s ease;
      }

      .progress-text {
        margin-top: 8px;
        font-size: 13px;
        color: var(--muted);
      }

      .progress-detail {
        margin-top: 4px;
        font-size: 12px;
        color: var(--text-soft);
      }

      .merge-status {
        margin-top: 6px;
        font-size: 12px;
        color: var(--muted);
      }

      .cover-large {
        width: 120px;
        height: 160px;
        border-radius: 16px;
        background: var(--cover-image-bg, var(--cover-gradient-large));
        overflow: hidden;
        box-shadow: var(--shadow);
      }

      .cover-large img {
        width: 100%;
        height: 100%;
        object-fit: contain;
      }

      .book-title {
        font-family: var(--title);
        font-size: 30px;
        margin: 0 0 8px;
      }

      .book-subtitle {
        margin: 0 0 4px;
        color: var(--muted);
        font-size: 14px;
      }

      .book-actions {
        margin-top: 10px;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .library-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 8px;
      }

      .btn.theme-toggle {
        width: 36px;
        height: 36px;
        padding: 0;
        border-radius: 12px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }

      .theme-toggle svg {
        width: 20px;
        height: 20px;
        display: none;
        fill: currentColor;
      }

      .theme-toggle[data-theme-mode="dark"] svg[data-icon="dark"],
      .theme-toggle[data-theme-mode="light"] svg[data-icon="light"] {
        display: block;
      }

      .book-menu {
        position: relative;
      }

      .download-menu {
        position: relative;
      }

      .menu-panel {
        position: fixed;
        top: 0;
        left: 0;
        right: auto;
        background: var(--surface);
        border: 1px solid var(--line);
        border-radius: 12px;
        box-shadow: var(--shadow-pop);
        padding: 8px;
        display: none;
        min-width: 160px;
        z-index: 10;
      }

      .menu-panel.open {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .menu-panel .btn {
        width: 100%;
        border-radius: 10px;
        padding: 8px 12px;
        text-align: left;
      }

      .meta-modal {
        position: fixed;
        inset: 0;
        background: rgba(18, 14, 10, 0.45);
        display: grid;
        place-items: center;
        z-index: 40;
      }

      .meta-modal[hidden] {
        display: none;
      }

      .meta-card {
        width: min(420px, calc(100vw - 32px));
        background: var(--panel);
        border: 1px solid var(--line);
        border-radius: 18px;
        padding: 18px;
        box-shadow: var(--shadow-pop);
      }

      .meta-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 12px;
      }

      .meta-header h3 {
        margin: 0;
        font-size: 14px;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: var(--muted);
      }

      .meta-form {
        display: grid;
        gap: 10px;
      }

      .meta-form label {
        font-size: 12px;
        color: var(--muted);
      }

      .meta-form input {
        width: 100%;
        padding: 8px 10px;
        border-radius: 10px;
        border: 1px solid var(--line-strong);
        background: var(--surface-2);
        color: var(--ink);
        font-family: var(--ui);
      }

      .meta-form select {
        width: 100%;
        padding: 8px 10px;
        border-radius: 10px;
        border: 1px solid var(--line-strong);
        background: var(--surface-2);
        color: var(--ink);
        font-family: var(--ui);
      }

      .meta-actions {
        display: flex;
        align-items: center;
        justify-content: flex-end;
        gap: 8px;
        margin-top: 14px;
      }

      .meta-status {
        margin-right: auto;
        font-size: 11px;
        color: var(--muted);
      }

      .meta-status[data-tone="error"] {
        color: var(--danger);
      }

      .clone-card {
        width: min(560px, calc(100vw - 32px));
      }

      .clone-form {
        gap: 8px;
      }

      .clone-grid {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 10px;
      }

      .clone-hint {
        margin: 2px 0 0;
        font-size: 11px;
        color: var(--muted);
      }

      .clone-preview {
        margin-top: 6px;
      }

      .clone-preview audio {
        width: 100%;
      }

      .clone-edit-note {
        margin: 2px 0 0;
        font-size: 11px;
        color: var(--muted);
      }

      .clone-inline-actions {
        display: flex;
        justify-content: flex-start;
      }

      .clone-gender-toggle {
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }

      .clone-gender-option {
        position: relative;
        display: inline-flex;
        align-items: center;
        cursor: pointer;
      }

      .clone-gender-option input {
        position: absolute;
        opacity: 0;
        pointer-events: none;
      }

      .clone-gender-option span {
        border: 1px solid var(--line-strong);
        background: var(--surface-2);
        color: var(--ink);
        padding: 6px 12px;
        border-radius: 999px;
        font-size: 12px;
        font-weight: 600;
      }

      .clone-gender-option input:checked + span {
        background: var(--accent);
        border-color: var(--accent);
        color: var(--accent-ink);
      }

      .clone-gender-option input:focus-visible + span {
        outline: 2px solid var(--accent-2);
        outline-offset: 2px;
      }

      .clone-gender-option input:disabled + span {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .reader-body {
        display: grid;
        grid-template-columns: 230px 1fr;
        gap: 16px;
        align-items: start;
      }

      .toc {
        background: var(--panel);
        border-radius: var(--radius);
        padding: 14px;
        border: 1px solid var(--line);
        max-height: calc(100vh - 320px);
        overflow-y: auto;
      }

      .toc-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 10px;
      }

      .toc h3 {
        font-size: 13px;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: var(--muted);
        margin: 0;
      }

      .toc-item {
        padding: 8px 10px;
        border-radius: 10px;
        margin-bottom: 6px;
        cursor: pointer;
        transition: background 0.2s ease;
      }

      .toc-item.active {
        background: var(--surface-muted);
        color: var(--active-ink);
      }

      .toc-item small {
        display: block;
        color: var(--muted);
        font-size: 11px;
      }

      .text-pane {
        background: var(--text-pane-bg);
        border-radius: 22px;
        padding: 22px;
        box-shadow: var(--shadow);
        min-height: 300px;
      }

      .chapter-title {
        font-family: var(--title);
        font-size: 22px;
        margin: 0 0 14px;
      }

      .chapter-text {
        font-family: var(--read);
        font-size: 18px;
        line-height: 1.7;
        white-space: pre-line;
      }

      .chapter-text p {
        margin: 0 0 16px;
      }

      .chapter-text hr.section-break {
        border: 0;
        border-top: 1px solid var(--line);
        margin: 18px auto 20px;
        max-width: 72px;
        opacity: 0.75;
      }

      .chapter-text hr.section-break.title-break {
        border-top-width: 2px;
        max-width: 120px;
        opacity: 0.95;
      }

      .panel {
        background: var(--surface);
        border: 1px solid var(--line);
        border-radius: 12px;
        padding: 12px;
      }

      .chunk {
        padding: 2px 1px;
        border-radius: 6px;
        transition: background 0.2s ease, color 0.2s ease;
      }

      .chunk.last-played {
        background: var(--surface-highlight);
      }

      .chunk.active {
        background: var(--highlight);
        color: #000;
      }

      .chunk.waiting {
        background: var(--surface-wait);
      }

      .chunk.played {
        color: var(--text-dim);
      }

      .chunk.active,
      .chunk.played.active {
        color: #000;
      }

      .empty-state {
        color: var(--muted);
        font-size: 15px;
      }

      .edit-panel {
        margin-top: 24px;
        background: var(--panel);
        border-radius: var(--radius);
        border: 1px solid var(--line);
        padding: 18px;
        display: none;
      }

      .edit-panel.open {
        display: block;
      }

      .edit-header {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 16px;
      }

      .edit-header h3 {
        margin: 0;
        font-size: 13px;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: var(--muted);
      }

      .edit-meta {
        margin: 6px 0 0;
        font-size: 12px;
        color: var(--muted);
      }

      .edit-actions {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
      }

      .edit-status {
        font-size: 12px;
        color: var(--muted);
      }

      .edit-grid {
        display: grid;
        grid-template-columns: 240px 1fr;
        gap: 16px;
      }

      .edit-sidebar,
      .edit-main {
        display: flex;
        flex-direction: column;
        gap: 14px;
      }

      .edit-section-title {
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.8px;
        color: var(--muted);
        margin-bottom: 8px;
      }

      .edit-chapter-list,
      .edit-dropped-list {
        display: flex;
        flex-direction: column;
        gap: 6px;
        max-height: 280px;
        overflow-y: auto;
      }

      .edit-chapter-item,
      .edit-dropped-item {
        border: 1px solid var(--line);
        background: var(--surface);
        color: var(--ink);
        padding: 6px 8px;
        border-radius: 8px;
        font-size: 12px;
        cursor: pointer;
        text-align: left;
      }

      .edit-chapter-item.active {
        background: var(--surface-muted);
      }

      .edit-dropped-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
      }

      .edit-selected {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      .edit-selected-title {
        font-weight: 600;
        font-size: 13px;
      }

      .edit-split {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 16px;
      }

      .edit-block h4 {
        margin: 0;
        font-size: 13px;
        color: var(--muted);
      }

      .edit-block-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        margin-bottom: 8px;
      }

      .edit-block pre {
        margin: 0;
        white-space: pre-wrap;
        line-height: 1.5;
        font-size: 13px;
      }

      .edit-clean-textarea {
        width: 100%;
        min-height: 220px;
        border: 1px solid var(--line);
        border-radius: 8px;
        padding: 8px;
        background: var(--surface);
        font-family: var(--read);
        font-size: 13px;
        line-height: 1.5;
        color: var(--ink);
      }

      .edit-clean-actions {
        display: flex;
        gap: 8px;
        justify-content: flex-end;
        margin-top: 8px;
      }

      .edit-panel mark {
        background: var(--mark-bg);
        padding: 0 2px;
        border-radius: 3px;
      }

      .edit-overrides .edit-meta {
        margin: 4px 0 8px;
        font-size: 12px;
        color: var(--muted);
      }

      .edit-overrides textarea {
        width: 100%;
        min-height: 96px;
        border: 1px solid var(--line);
        border-radius: 8px;
        padding: 8px;
        background: var(--surface);
        font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
        font-size: 12px;
        color: var(--ink);
      }

      .edit-rules label {
        display: block;
        font-size: 12px;
        color: var(--muted);
        margin: 10px 0 4px;
      }

      .edit-rules textarea {
        width: 100%;
        min-height: 80px;
        border: 1px solid var(--line);
        border-radius: 8px;
        padding: 8px;
        background: var(--surface);
        font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
        font-size: 12px;
        color: var(--ink);
      }

      .edit-rules select {
        width: 100%;
        border: 1px solid var(--line);
        border-radius: 8px;
        padding: 6px 8px;
        font-size: 12px;
        color: var(--ink);
        background: var(--surface);
      }

      .edit-rules input[type="checkbox"] {
        margin-right: 6px;
      }

      .player-bar {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: var(--player-bar-bg);
        border-top: 1px solid var(--line);
        box-shadow: var(--shadow-top);
        padding: 12px 20px;
        display: flex;
        align-items: center;
        gap: 16px;
        flex-wrap: wrap;
      }

      .player-controls {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .jump-btn {
        position: absolute;
        right: 14px;
        bottom: 14px;
        border: 1px solid var(--jump-border);
        background: var(--jump-bg);
        color: var(--accent-ink);
        width: 44px;
        height: 44px;
        border-radius: 50%;
        font-size: 18px;
        font-weight: 700;
        cursor: pointer;
        box-shadow: var(--shadow-float);
        display: none;
        z-index: 10;
      }

      .jump-btn:hover {
        background: var(--jump-hover-bg);
      }

      .player-left,
      .player-right {
        display: flex;
        align-items: center;
        gap: 16px;
        flex: 1;
        min-width: 0;
      }

      .player-left {
        justify-content: flex-start;
      }

      .player-right {
        justify-content: flex-end;
      }

      .btn {
        border: 1px solid var(--line-strong);
        background: var(--surface-2);
        color: var(--ink);
        padding: 8px 14px;
        border-radius: 999px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s ease, background 0.2s ease;
      }

      .btn.circle {
        width: 36px;
        height: 36px;
        padding: 0;
        border-radius: 50%;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
      }

      .btn.primary {
        background: var(--accent);
        border-color: var(--accent);
        color: var(--accent-ink);
      }

      .btn.success {
        background: var(--success-bg);
        border-color: var(--success-border);
        color: var(--success-ink);
      }

      .btn.subtle {
        background: var(--subtle-bg);
        border-color: var(--subtle-border);
        color: var(--subtle-ink);
      }

      .btn.play {
        padding: 12px 22px;
        font-size: 16px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }

      .btn.icon {
        width: 36px;
        height: 36px;
        padding: 0;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }

      .btn.icon svg {
        width: 16px;
        height: 16px;
        display: block;
      }

      .btn.play svg {
        width: 18px;
        height: 18px;
        display: block;
      }

      .btn.play .pause-icon {
        display: none;
      }

      .btn.play.is-playing .play-icon {
        display: none;
      }

      .btn.play.is-playing .pause-icon {
        display: block;
      }

      .btn.danger {
        background: var(--danger);
        border-color: var(--danger);
        color: var(--danger-ink);
      }

      .btn:active {
        transform: scale(0.98);
      }

      .status {
        color: var(--muted);
        font-size: 13px;
      }

      .marks {
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
        font-size: 12px;
        color: var(--muted);
        position: relative;
      }

      .bookmark-panel {
        position: fixed;
        bottom: calc(env(safe-area-inset-bottom, 0px) + 84px);
        left: 50%;
        transform: translateX(-50%);
        width: 280px;
        max-width: min(280px, calc(100vw - 32px));
        background: var(--surface);
        border: 1px solid var(--line);
        border-radius: 16px;
        box-shadow: var(--shadow-pop);
        padding: 12px;
        display: none;
        z-index: 20;
      }

      .bookmark-panel.open {
        display: block;
      }

      .bookmark-title {
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 8px;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .bookmark-list {
        max-height: 220px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-bottom: 12px;
      }

      .bookmark-item {
        background: var(--bookmark-bg);
        border-radius: 12px;
        padding: 8px 10px;
        display: grid;
        gap: 8px;
      }

      .bookmark-item span {
        font-size: 12px;
        color: var(--bookmark-ink);
      }

      .bookmark-actions {
        display: flex;
        gap: 8px;
      }

      .btn.small {
        padding: 4px 10px;
        font-size: 11px;
      }

      .bookmark-empty {
        font-size: 12px;
        color: var(--muted);
        padding: 6px 4px;
      }

      .marks span {
        max-width: 220px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .speed {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 13px;
      }

      .btn.speed {
        border: 1px solid var(--line-strong);
        background: var(--surface-2);
        color: var(--ink);
        height: 36px;
        padding: 0 12px;
        border-radius: 999px;
        font-weight: 600;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .btn.speed svg {
        width: 16px;
        height: 16px;
        display: block;
      }

      @keyframes fade-up {
        from {
          opacity: 0;
          transform: translateY(12px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @media (max-width: 980px) {
        .app {
          grid-template-columns: 1fr;
        }
        .library {
          position: relative;
          height: auto;
          border-right: none;
          border-bottom: 1px solid var(--line);
          padding-bottom: 160px;
        }
        .book-list {
          display: grid;
          grid-template-columns: repeat(auto-fill, minmax(72px, 1fr));
          gap: 12px;
        }
        .upload-zone {
          padding: 10px;
        }
        .book-card {
          grid-template-columns: 1fr;
          justify-items: stretch;
          padding: 6px;
          overflow: hidden;
        }
        .book-meta {
          display: none;
        }
        .book-cover {
          width: 100%;
          height: auto;
          aspect-ratio: 2 / 3;
        }
        .book-cover img {
          display: block;
        }
        .reader-body {
          grid-template-columns: 1fr;
        }
        .toc {
          max-height: none;
        }
        .edit-panel {
          display: none !important;
        }
        .edit-toggle {
          display: none;
        }
        .jump-btn {
          display: inline-flex;
          align-items: center;
          justify-content: center;
        }
      }

      @media (max-width: 720px) {
        .reader-header {
          flex-direction: column;
          align-items: flex-start;
        }
        .player-bar {
          flex-wrap: wrap;
          gap: 10px;
        }
        .player-controls {
          order: 0;
          width: 100%;
          justify-content: center;
        }
        .player-left {
          order: 1;
          flex: 1 1 100%;
          justify-content: center;
        }
        .player-right {
          order: 2;
          flex: 1 1 100%;
          justify-content: center;
          flex-wrap: wrap;
        }
        .status {
          text-align: center;
        }

        .tts-delete {
          margin-left: 0;
        }

        .advanced-row {
          grid-template-columns: 22px 1fr;
          grid-template-rows: auto auto;
        }
        .advanced-row .advanced-select {
          grid-column: 2 / -1;
        }

        .clone-grid {
          grid-template-columns: 1fr;
        }
      }
    </style>
    <script>
      (() => {
        try {
          const stored = localStorage.getItem("ptts.theme");
          if (stored === "dark" || stored === "light") {
            document.documentElement.setAttribute("data-theme", stored);
          }
        } catch (err) {
          // ignore storage errors
        }
      })();
    </script>
  </head>
  <body>
    <div class="app">
      <aside class="library" id="bookshelf">
        <div class="library-header">
          <div class="brand">pTTS player</div>
          <button class="btn subtle theme-toggle" id="themeToggle" type="button" data-theme-mode="light" aria-label="Theme: Light" title="Theme: Light">
            <svg data-icon="dark" viewBox="0 0 24 24" aria-hidden="true">
              <path d="M12,22 C17.5228475,22 22,17.5228475 22,12 C22,6.4771525 17.5228475,2 12,2 C6.4771525,2 2,6.4771525 2,12 C2,17.5228475 6.4771525,22 12,22 Z M12,20.5 L12,3.5 C16.6944204,3.5 20.5,7.30557963 20.5,12 C20.5,16.6944204 16.6944204,20.5 12,20.5 Z" fill="currentColor" fill-rule="evenodd"></path>
            </svg>
            <svg data-icon="light" viewBox="0 0 24 24" aria-hidden="true">
              <path d="M12,22 C17.5228475,22 22,17.5228475 22,12 C22,6.4771525 17.5228475,2 12,2 C6.4771525,2 2,6.4771525 2,12 C2,17.5228475 6.4771525,22 12,22 Z M12,20.5 L12,3.5 C16.6944204,3.5 20.5,7.30557963 20.5,12 C20.5,16.6944204 16.6944204,20.5 12,20.5 Z" fill="currentColor" fill-rule="evenodd" transform="translate(24 0) scale(-1 1)"></path>
            </svg>
          </button>
        </div>
        <div class="root-path">Root: {{ root_dir }}</div>
        <div class="upload-panel">
          <div class="upload-zone" id="uploadZone" role="button" tabindex="0">
            <strong>Drop EPUB or TXT here</strong>
            <span>or click to browse</span>
          </div>
          <input type="file" id="uploadInput" accept=".epub,.txt" hidden />
          <div class="upload-status" id="uploadStatus"></div>
        </div>
        <div class="library-tabs library-shelf-tabs" role="tablist" aria-label="Bookshelf sections" hidden>
          <button class="library-tab active" data-shelf="books" data-label="Books" type="button" role="tab" aria-selected="true">Books</button>
          <button class="library-tab" data-shelf="tsundoku" data-label="Tsundoku" type="button" role="tab" aria-selected="false">Tsundoku</button>
        </div>
        <div class="library-tabs library-type-tabs" role="tablist" aria-label="Bookshelf formats" hidden>
          <button class="library-tab active" data-filter="epub" data-label="EPUB" type="button" role="tab" aria-selected="true">EPUB</button>
          <button class="library-tab" data-filter="txt" data-label="TXT" type="button" role="tab" aria-selected="false">TXT</button>
        </div>
        <div id="bookList" class="book-list"></div>
      </aside>
      <main class="reader" id="bookSection">
        <div class="reader-header">
          <div class="cover-large" id="coverLarge"></div>
          <div>
            <h1 class="book-title" id="bookTitle">Select a book</h1>
            <p class="book-subtitle" id="bookMeta">No book loaded.</p>
            <p class="book-subtitle" id="bookStatus"></p>
            <div class="book-actions">
              <div class="book-menu">
                <button class="btn circle" id="bookMenuBtn" type="button" aria-haspopup="true" aria-expanded="false" disabled aria-label="More">â‹¯</button>
                <div class="menu-panel" id="bookMenuPanel">
                  <button class="btn" id="editMetaBtn" type="button" disabled>Edit metadata</button>
                  <button class="btn" id="deleteM4bBtn" type="button" disabled hidden>Delete M4B</button>
                  <button class="btn danger" id="deleteBookBtn" type="button" disabled>Delete book</button>
                </div>
              </div>
            </div>
          </div>
        </div>
        <section class="tts-panel" id="ttsPanel">
          <div class="tts-header">
            <h3>Text To Speech</h3>
            <div class="tts-header-actions">
              <button class="tts-toggle" id="advancedToggle" type="button">Multi-Voices</button>
              <button class="tts-toggle" id="ttsToggle">Collapse</button>
            </div>
          </div>
          <div class="tts-grid">
            <div class="tts-field">
              <div class="voice-groups" id="voiceGroup">
                <div class="voice-empty">Loading voices...</div>
              </div>
            </div>
          </div>
          <div class="advanced-panel" id="advancedPanel">
            <div class="advanced-header">
              <div class="advanced-title">Per-chapter voices</div>
              <div class="advanced-actions">
                <label>
                  <input type="checkbox" id="advancedSelectAll" />
                  Select all
                </label>
                <span id="advancedSelectedCount">0 selected</span>
                <select id="advancedBulkVoice"></select>
                <button class="btn small" id="advancedApplyVoice" type="button">Assign</button>
                <button class="btn small" id="advancedClearVoice" type="button">Clear</button>
              </div>
            </div>
            <div class="advanced-list" id="advancedList"></div>
          </div>
          <div class="tts-actions">
            <button class="btn primary" id="startTts">Start TTS</button>
            <button class="btn" id="sampleTts" type="button">Sample</button>
            <span class="tts-divider" aria-hidden="true"></span>
            <button class="btn" id="mergeBtn" type="button">Merge M4B</button>
            <div class="download-menu" id="downloadMenu">
              <button class="btn" id="downloadM4bBtn" type="button" hidden aria-haspopup="true" aria-expanded="false">Download M4B</button>
              <div class="menu-panel" id="downloadMenuPanel"></div>
            </div>
            <button class="btn subtle tts-delete" id="clearTtsBtn" type="button" title="Delete TTS segments for this book.">Delete TTS cache</button>
          </div>
          <div class="progress-track">
            <div class="progress-fill" id="progressFill"></div>
          </div>
          <div class="progress-text" id="progressText">Idle.</div>
          <div class="progress-detail" id="progressDetail"></div>
          <div class="merge-status" id="ffmpegStatus"></div>
          <div class="merge-status" id="mergeStatus"></div>
        </section>
        <div class="reader-body">
          <aside class="toc">
            <div class="toc-header">
              <h3>Chapters</h3>
              <button class="btn small edit-toggle" id="editToggle" type="button">Edit</button>
            </div>
            <div id="chapterList"></div>
          </aside>
          <section class="text-pane" id="textPane">
            <h2 class="chapter-title" id="chapterTitle">Waiting for a book...</h2>
            <div class="chapter-text" id="chapterText">
              <p class="empty-state">Pick a book on the left to start.</p>
            </div>
          </section>
        </div>
        <section class="edit-panel" id="editPanel">
          <div class="edit-header">
            <div>
              <h3>Sanitize & Preview</h3>
              <p class="edit-meta">Rules auto-save. Re-sanitize refreshes clean text and clears TTS cache.</p>
            </div>
            <div class="edit-actions">
              <button class="btn" id="sanitizeBtn" type="button">Re-sanitize</button>
              <button class="btn" id="editReload" type="button">Reload</button>
              <span class="edit-status" id="editStatus"></span>
            </div>
          </div>
          <div class="edit-grid">
            <aside class="edit-sidebar">
              <div class="panel">
                <div class="edit-section-title">Chapters</div>
                <div class="edit-chapter-list" id="editChapterList"></div>
              </div>
              <div class="panel">
                <div class="edit-section-title">Dropped</div>
                <div class="edit-dropped-list" id="editDroppedList"></div>
              </div>
            </aside>
            <div class="edit-main">
              <div class="panel edit-selected">
                <div class="edit-selected-title" id="editSelectedTitle">Select a chapter</div>
                <button class="btn small" id="dropChapterBtn" type="button">Drop chapter</button>
              </div>
              <div class="panel edit-split">
                <div class="edit-block">
                  <div class="edit-block-header">
                    <h4>Raw</h4>
                  </div>
                  <pre id="editRaw"></pre>
                </div>
                <div class="edit-block">
                  <div class="edit-block-header">
                    <h4>Clean</h4>
                    <button class="btn small" id="editCleanBtn" type="button">Edit</button>
                  </div>
                  <pre id="editClean"></pre>
                  <textarea id="editCleanInput" class="edit-clean-textarea" hidden></textarea>
                  <div class="edit-clean-actions" id="editCleanActions" hidden>
                    <button class="btn small" id="saveCleanBtn" type="button">Save</button>
                    <button class="btn small" id="cancelCleanBtn" type="button">Cancel</button>
                  </div>
                </div>
              </div>
              <div class="panel edit-overrides">
                <div class="edit-section-title" id="editOverridesTitle">Reading overrides (global)</div>
                <p class="edit-meta" id="editOverridesHelp">One line each: `base=reading` or `re:pattern=reading`. Applied only at TTS time.</p>
                <textarea id="readingOverrides"></textarea>
                <div class="edit-clean-actions">
                  <button class="btn small" id="saveOverridesBtn" type="button">Save overrides</button>
                </div>
              </div>
              <div class="panel edit-rules">
                <div class="edit-section-title">Rules</div>
                <label for="rulesParagraphs">Paragraph breaks</label>
                <select id="rulesParagraphs">
                  <option value="double">Double newline (default)</option>
                  <option value="single">Single newline (treat line breaks as paragraphs)</option>
                </select>
                <label for="rulesDrop">Drop chapter title patterns</label>
                <textarea id="rulesDrop"></textarea>
                <label for="rulesCutoff">Section cutoff patterns</label>
                <textarea id="rulesCutoff"></textarea>
                <label for="rulesRemove">Remove patterns</label>
                <textarea id="rulesRemove"></textarea>
                <label><input type="checkbox" id="rulesReplace" /> Replace defaults</label>
              </div>
            </div>
          </div>
        </section>
        <div class="meta-modal" id="cloneModal" hidden>
          <div class="meta-card clone-card" role="dialog" aria-modal="true" aria-labelledby="cloneTitleLabel">
            <div class="meta-header">
              <h3 id="cloneTitleLabel">Clone local voice</h3>
              <button class="btn circle" id="cloneClose" type="button" aria-label="Close">x</button>
            </div>
            <div class="meta-form clone-form">
              <div id="cloneAudioFields">
                <label for="cloneSource">Source URL or local path</label>
                <input
                  id="cloneSource"
                  type="text"
                  placeholder="https://... or /absolute/path/to/audio.mp3"
                  autocomplete="off"
                />
                <div class="clone-grid">
                  <div>
                    <label for="cloneStart">Start</label>
                    <input id="cloneStart" type="text" placeholder="0 or 00:00:00 (default: 0)" />
                  </div>
                  <div>
                    <label for="cloneDuration">Duration (seconds)</label>
                    <input id="cloneDuration" type="number" min="0.1" step="0.1" placeholder="12 (default)" />
                  </div>
                </div>
                <p class="clone-hint">Use URL or absolute local path, then tweak start/duration and preview until it sounds right.</p>
              </div>
              <div class="clone-edit-note" id="cloneEditNote" hidden>
                Editing voice metadata for <strong id="cloneEditVoiceLabel"></strong>
              </div>
              <label for="cloneName">Voice name</label>
              <input id="cloneName" type="text" placeholder="Defaults to source name" autocomplete="off" />
              <label>Voice gender</label>
              <div class="clone-gender-toggle" role="radiogroup" aria-label="Voice gender">
                <label class="clone-gender-option">
                  <input id="cloneGenderMale" type="radio" name="cloneGender" value="male" />
                  <span>Male</span>
                </label>
                <label class="clone-gender-option">
                  <input id="cloneGenderFemale" type="radio" name="cloneGender" value="female" />
                  <span>Female</span>
                </label>
              </div>
              <div class="clone-preview" id="clonePreviewWrap" hidden>
                <audio id="clonePreviewAudio" controls preload="metadata"></audio>
              </div>
            </div>
            <div class="meta-actions">
              <div class="clone-inline-actions" id="cloneBuiltinWrap">
                <button class="btn small" id="cloneBuiltinToggle" type="button">
                  Hide built-in voices
                </button>
              </div>
              <span class="meta-status" id="cloneStatus"></span>
              <button class="btn" id="cloneCancel" type="button">Cancel</button>
              <button class="btn danger" id="cloneDelete" type="button" hidden>Delete voice</button>
              <button class="btn" id="clonePreviewBtn" type="button">Preview</button>
              <button class="btn primary" id="cloneSave" type="button">Save voice</button>
            </div>
          </div>
        </div>
        <div class="meta-modal" id="metaModal" hidden>
          <div class="meta-card" role="dialog" aria-modal="true" aria-labelledby="metaTitleLabel">
            <div class="meta-header">
              <h3 id="metaTitleLabel">Edit metadata</h3>
              <button class="btn circle" id="metaClose" type="button" aria-label="Close">x</button>
            </div>
            <div class="meta-form">
              <label for="metaTitle">Title</label>
              <input id="metaTitle" type="text" autocomplete="off" />
              <label for="metaAuthors">Authors</label>
              <input id="metaAuthors" type="text" placeholder="Comma-separated" autocomplete="off" />
              <label for="metaYear">Year</label>
              <input id="metaYear" type="text" inputmode="numeric" autocomplete="off" />
            </div>
            <div class="meta-actions">
              <span class="meta-status" id="metaStatus"></span>
              <button class="btn" id="metaCancel" type="button">Cancel</button>
              <button class="btn primary" id="metaSave" type="button">Save</button>
            </div>
          </div>
        </div>
      </main>
    </div>

    <div class="player-bar">
      <div class="player-left">
        <button class="btn icon" id="regenChunkBtn" aria-label="Regenerate chunk" title="Regenerate selected chunk">
          <svg
            viewBox="0 0 24 24"
            aria-hidden="true"
            focusable="false"
          >
            <path d="M17.65 6.35A7.95 7.95 0 0 0 12 4V1L7 6l5 5V7a5 5 0 1 1-5 5H5a7 7 0 1 0 12.65-5.65z" fill="currentColor"></path>
          </svg>
        </button>
        <div class="status" id="status">Last: â€”</div>
      </div>
      <div class="player-controls">
        <button class="btn icon" id="prevBtn" aria-label="Previous" title="Previous">
          <svg
            viewBox="0 0 24 24"
            aria-hidden="true"
            focusable="false"
          >
            <path d="M6 6h2v12H6zM10 12l8-6v12z" fill="currentColor"></path>
          </svg>
        </button>
        <button class="btn primary play" id="playBtn" aria-label="Play" title="Play">
          <svg
            class="play-icon"
            viewBox="0 0 24 24"
            aria-hidden="true"
            focusable="false"
          >
            <path d="M6 4l12 8-12 8z" fill="currentColor"></path>
          </svg>
          <svg
            class="pause-icon"
            viewBox="0 0 24 24"
            aria-hidden="true"
            focusable="false"
          >
            <path d="M6 5h4v14H6zM14 5h4v14h-4z" fill="currentColor"></path>
          </svg>
        </button>
        <button class="btn icon" id="nextBtn" aria-label="Next" title="Next">
          <svg
            viewBox="0 0 24 24"
            aria-hidden="true"
            focusable="false"
          >
            <path d="M16 6h2v12h-2zM6 6l8 6-8 6z" fill="currentColor"></path>
          </svg>
        </button>
      </div>
      <div class="player-right">
        <div class="marks">
          <button class="btn icon" id="bookmarkBtn" aria-label="Bookmarks" title="Bookmarks">
            <svg
              viewBox="0 0 24 24"
              aria-hidden="true"
              focusable="false"
            >
              <path d="M6 3h12a1 1 0 0 1 1 1v17l-7-4-7 4V4a1 1 0 0 1 1-1z" fill="currentColor"></path>
            </svg>
          </button>
          <div class="bookmark-panel" id="bookmarkPanel">
            <div class="bookmark-title">Bookmarks</div>
            <div class="bookmark-list" id="bookmarkList"></div>
            <button class="btn" id="saveBookmarkBtn">Save current</button>
          </div>
        </div>
        <div class="speed">
          <button class="btn speed" id="speedBtn" type="button" aria-label="Playback speed" title="Playback speed">
            <svg
              viewBox="0 0 30 30"
              aria-hidden="true"
              focusable="false"
            >
              <path
                d="m 14.703125,5.5722656 a 12,12 0 0 0 -12,12.0000004 12,12 0 0 0 0.6894531,3.964843 A 10.746539,10.746539 0 0 1 3.0976562,19.09375 10.746539,10.746539 0 0 1 13.84375,8.3476562 10.746539,10.746539 0 0 1 19.826172,10.173828 L 21.966797,8.0332031 A 12,12 0 0 0 14.703125,5.5722656 Z m 9.148437,3.6035156 c -0.25173,0.00423 -0.507325,0.1022801 -0.71875,0.28125 l -9.193359,7.7812498 c -0.422789,0.35795 -1.416166,1.411952 -0.002,2.826172 1.414471,1.41445 2.468093,0.418804 2.826172,-0.0039 l 7.783203,-9.189453 c 0.358051,-0.42275 0.391737,-1.0223328 0,-1.4140628 -0.195869,-0.19587 -0.443582,-0.285475 -0.695313,-0.28125 z m 1.84961,3.6074218 -2.021484,2.021485 A 10.746539,10.746539 0 0 1 24.585938,19 h 2.015624 a 12,12 0 0 0 0.101563,-1.427734 12,12 0 0 0 -1.001953,-4.789063 z"
                fill="currentColor"
              ></path>
            </svg>
            <span id="speedValue">1.0x</span>
          </button>
        </div>
      </div>
      <button class="jump-btn" id="jumpShelf" type="button" aria-label="Back to bookshelf">â†‘</button>
    </div>

    <audio id="audio"></audio>
    <audio id="audioNext" preload="auto"></audio>

    <script>
      const state = {
        books: [],
        libraryShelf: "books",
        bookFilter: "epub",
        book: null,
        chapters: [],
        chapterMap: {},
        chapterTextRequests: {},
        chapterRenderToken: 0,
        queue: [],
        chapterOffsets: {},
        currentChapterId: null,
        currentQueueIndex: 0,
        activeQueueIndex: null,
        selectedQueueIndex: null,
        waitingFor: null,
        waitTimer: null,
        audioBase: "",
        chunkCacheBust: {},
        chunkRegenRunning: false,
        synthTimer: null,
        loadingBook: false,
        initialBookId: null,
        initialChapterId: null,
        pendingManifestRefresh: false,
        needsRechunk: false,
        synthRunning: false,
        synthMode: "tts",
        statusMode: "idle",
        themePreference: "system",
        playbackSaveTimer: null,
        playback: {
          lastPlayed: null,
          furthestPlayed: null,
          bookmarks: [],
        },
        voicePreference: null,
        selectedVoice: null,
        advancedMode: false,
        voiceMap: { default: null, chapters: {} },
        voiceOptions: [],
        advancedSelection: new Set(),
        advancedLastIndex: null,
        voiceMapSaveTimer: null,
        preloadedIndex: null,
        padMs: 0,
        gaplessArmedIndex: null,
        gaplessPollTimer: null,
        playbackRate: 1.0,
        mergeRunning: false,
        mergeReady: false,
        mergePartial: false,
        mergeExitCode: null,
        mergeOutputExists: false,
        mergeOutputParts: [],
        mergeStage: "idle",
        editOpen: false,
        previewChapterIndex: null,
        previewSelectedTitle: "",
        previewSelectedKind: "",
        rulesLoading: false,
        rulesSaveTimer: null,
        ingestRunning: false,
        cleanEditing: false,
        cleanEditOriginal: "",
        cleanEditChapter: null,
        readingOverridesDirty: false,
        readingOverridesOriginal: "",
        bookVoice: null,
        playTransitioning: false,
        pendingBoundary: null,
        boundaryLogBuffer: [],
        boundaryLogFlushTimer: null,
        boundaryLogInFlight: false,
        localVoiceValues: [],
        voiceGenderMap: {},
        voiceDisplayNameMap: {},
        cloneMode: "add",
        cloneEditVoice: null,
        cloneNameDirty: false,
        cloneModalBusy: false,
        showBuiltinVoices: true,
      };

      const bookList = document.getElementById("bookList");
      const uploadZone = document.getElementById("uploadZone");
      const uploadInput = document.getElementById("uploadInput");
      const uploadStatus = document.getElementById("uploadStatus");
      const libraryShelfTabs = document.querySelectorAll(
        ".library-shelf-tabs .library-tab"
      );
      const libraryShelfTabsWrap = document.querySelector(".library-shelf-tabs");
      const libraryTypeTabs = document.querySelectorAll(
        ".library-type-tabs .library-tab"
      );
      const libraryTypeTabsWrap = document.querySelector(".library-type-tabs");
      const chapterList = document.getElementById("chapterList");
      const chapterTitle = document.getElementById("chapterTitle");
      const chapterText = document.getElementById("chapterText");
      const bookTitle = document.getElementById("bookTitle");
      const bookMeta = document.getElementById("bookMeta");
      const bookStatus = document.getElementById("bookStatus");
      const themeToggle = document.getElementById("themeToggle");
      const coverLarge = document.getElementById("coverLarge");
      const editToggle = document.getElementById("editToggle");
      const editPanel = document.getElementById("editPanel");
      const sanitizeBtn = document.getElementById("sanitizeBtn");
      const editReload = document.getElementById("editReload");
      const editStatus = document.getElementById("editStatus");
      const editChapterList = document.getElementById("editChapterList");
      const editDroppedList = document.getElementById("editDroppedList");
      const editSelectedTitle = document.getElementById("editSelectedTitle");
      const dropChapterBtn = document.getElementById("dropChapterBtn");
      const editRaw = document.getElementById("editRaw");
      const editClean = document.getElementById("editClean");
      const editCleanBtn = document.getElementById("editCleanBtn");
      const editCleanInput = document.getElementById("editCleanInput");
      const editCleanActions = document.getElementById("editCleanActions");
      const saveCleanBtn = document.getElementById("saveCleanBtn");
      const cancelCleanBtn = document.getElementById("cancelCleanBtn");
      const editOverridesTitle = document.getElementById("editOverridesTitle");
      const editOverridesHelp = document.getElementById("editOverridesHelp");
      const readingOverrides = document.getElementById("readingOverrides");
      const saveOverridesBtn = document.getElementById("saveOverridesBtn");
      const bookMenuBtn = document.getElementById("bookMenuBtn");
      const bookMenuPanel = document.getElementById("bookMenuPanel");
      const editMetaBtn = document.getElementById("editMetaBtn");
      const deleteM4bBtn = document.getElementById("deleteM4bBtn");
      const deleteBookBtn = document.getElementById("deleteBookBtn");
      const cloneModal = document.getElementById("cloneModal");
      const cloneClose = document.getElementById("cloneClose");
      const cloneCancel = document.getElementById("cloneCancel");
      const clonePreviewBtn = document.getElementById("clonePreviewBtn");
      const cloneDelete = document.getElementById("cloneDelete");
      const cloneSave = document.getElementById("cloneSave");
      const cloneStatus = document.getElementById("cloneStatus");
      const cloneTitleLabel = document.getElementById("cloneTitleLabel");
      const cloneAudioFields = document.getElementById("cloneAudioFields");
      const cloneEditNote = document.getElementById("cloneEditNote");
      const cloneEditVoiceLabel = document.getElementById("cloneEditVoiceLabel");
      const cloneSource = document.getElementById("cloneSource");
      const cloneStart = document.getElementById("cloneStart");
      const cloneDuration = document.getElementById("cloneDuration");
      const cloneName = document.getElementById("cloneName");
      const cloneBuiltinWrap = document.getElementById("cloneBuiltinWrap");
      const cloneBuiltinToggle = document.getElementById("cloneBuiltinToggle");
      const cloneGenderMale = document.getElementById("cloneGenderMale");
      const cloneGenderFemale = document.getElementById("cloneGenderFemale");
      const clonePreviewWrap = document.getElementById("clonePreviewWrap");
      const clonePreviewAudio = document.getElementById("clonePreviewAudio");
      const metaModal = document.getElementById("metaModal");
      const metaClose = document.getElementById("metaClose");
      const metaCancel = document.getElementById("metaCancel");
      const metaSave = document.getElementById("metaSave");
      const metaStatus = document.getElementById("metaStatus");
      const metaTitle = document.getElementById("metaTitle");
      const metaAuthors = document.getElementById("metaAuthors");
      const metaYear = document.getElementById("metaYear");
      const rulesDrop = document.getElementById("rulesDrop");
      const rulesCutoff = document.getElementById("rulesCutoff");
      const rulesRemove = document.getElementById("rulesRemove");
      const rulesParagraphs = document.getElementById("rulesParagraphs");
      const rulesReplace = document.getElementById("rulesReplace");
      const status = document.getElementById("status");
      const playBtn = document.getElementById("playBtn");
      const prevBtn = document.getElementById("prevBtn");
      const nextBtn = document.getElementById("nextBtn");
      const speedBtn = document.getElementById("speedBtn");
      const speedValue = document.getElementById("speedValue");
      const jumpShelf = document.getElementById("jumpShelf");
      const audio = document.getElementById("audio");
      const audioNext = document.getElementById("audioNext");
      let currentAudio = audio;
      let nextAudio = audioNext;
      const bookmarkBtn = document.getElementById("bookmarkBtn");
      const regenChunkBtn = document.getElementById("regenChunkBtn");
      const bookmarkList = document.getElementById("bookmarkList");
      const bookmarkPanel = document.getElementById("bookmarkPanel");
      const saveBookmarkBtn = document.getElementById("saveBookmarkBtn");
      const voiceGroup = document.getElementById("voiceGroup");
      const startTts = document.getElementById("startTts");
      const sampleTts = document.getElementById("sampleTts");
      const mergeBtn = document.getElementById("mergeBtn");
      const downloadM4bBtn = document.getElementById("downloadM4bBtn");
      const downloadMenuPanel = document.getElementById("downloadMenuPanel");
      const clearTtsBtn = document.getElementById("clearTtsBtn");
      const progressFill = document.getElementById("progressFill");
      const progressText = document.getElementById("progressText");
      const progressDetail = document.getElementById("progressDetail");
      const ffmpegStatus = document.getElementById("ffmpegStatus");
      const mergeStatus = document.getElementById("mergeStatus");
      const ttsPanel = document.getElementById("ttsPanel");
      const ttsToggle = document.getElementById("ttsToggle");
      const advancedToggle = document.getElementById("advancedToggle");
      const advancedPanel = document.getElementById("advancedPanel");
      const advancedList = document.getElementById("advancedList");
      const advancedSelectAll = document.getElementById("advancedSelectAll");
      const advancedSelectedCount = document.getElementById("advancedSelectedCount");
      const advancedBulkVoice = document.getElementById("advancedBulkVoice");
      const advancedApplyVoice = document.getElementById("advancedApplyVoice");
      const advancedClearVoice = document.getElementById("advancedClearVoice");
      const themeQuery = window.matchMedia("(prefers-color-scheme: dark)");
      const BOUNDARY_LOG_ENABLED = (() => {
        try {
          const params = new URLSearchParams(window.location.search || "");
          if (params.get("debug_boundary_log") === "1") {
            return true;
          }
        } catch (err) {
          // ignore
        }
        try {
          return localStorage.getItem("ptts.debugBoundaryLog") === "1";
        } catch (err) {
          return false;
        }
      })();
      const BOUNDARY_LOG_BATCH_SIZE = 24;
      const BOUNDARY_LOG_FLUSH_MS = 4000;
      let latencyAudioContext = null;
      let latencyAudioContextInit = false;
      let localVoiceActionButton = null;

      function ensureLatencyAudioContext() {
        if (!BOUNDARY_LOG_ENABLED) {
          return null;
        }
        if (latencyAudioContextInit) {
          return latencyAudioContext;
        }
        latencyAudioContextInit = true;
        const Ctor = window.AudioContext || window.webkitAudioContext;
        if (!Ctor) {
          return null;
        }
        try {
          latencyAudioContext = new Ctor();
        } catch (err) {
          latencyAudioContext = null;
        }
        return latencyAudioContext;
      }

      async function primeLatencyAudioContext() {
        const ctx = ensureLatencyAudioContext();
        if (!ctx || typeof ctx.resume !== "function" || ctx.state !== "suspended") {
          return;
        }
        try {
          await ctx.resume();
        } catch (err) {
          // ignore
        }
      }

      function readAudioLatencySnapshot() {
        const snapshot = {
          baseLatencyMs: null,
          outputLatencyMs: null,
          contextState: "",
        };
        const ctx = ensureLatencyAudioContext();
        if (!ctx) {
          return snapshot;
        }
        snapshot.contextState = String(ctx.state || "");
        const base = Number(ctx.baseLatency);
        if (Number.isFinite(base) && base >= 0) {
          snapshot.baseLatencyMs = Number((base * 1000).toFixed(3));
        }
        const output = Number(ctx.outputLatency);
        if (Number.isFinite(output) && output >= 0) {
          snapshot.outputLatencyMs = Number((output * 1000).toFixed(3));
        }
        return snapshot;
      }

      function setStatus(message, mode = "message") {
        status.textContent = message;
        state.statusMode = mode;
      }

      function clearPendingBoundaryMeasurement() {
        state.pendingBoundary = null;
      }

      function queueBoundaryMeasurement(
        fromIndex,
        toIndex,
        expectedAt,
        trigger,
        remainingMs = 0
      ) {
        if (!BOUNDARY_LOG_ENABLED) {
          return;
        }
        if (!Number.isFinite(expectedAt)) {
          return;
        }
        if (
          typeof fromIndex !== "number" ||
          typeof toIndex !== "number" ||
          toIndex !== fromIndex + 1
        ) {
          return;
        }
        state.pendingBoundary = {
          fromIndex,
          toIndex,
          expectedAt,
          trigger: String(trigger || "auto"),
          remainingMs: Math.max(0, Number(remainingMs) || 0),
          queuedAt: performance.now(),
        };
      }

      function scheduleBoundaryLogFlush() {
        if (!BOUNDARY_LOG_ENABLED) {
          return;
        }
        if (state.boundaryLogFlushTimer) {
          return;
        }
        state.boundaryLogFlushTimer = setTimeout(() => {
          state.boundaryLogFlushTimer = null;
          void flushBoundaryLogBuffer();
        }, BOUNDARY_LOG_FLUSH_MS);
      }

      async function flushBoundaryLogBuffer(force = false) {
        if (!BOUNDARY_LOG_ENABLED) {
          if (state.boundaryLogFlushTimer) {
            clearTimeout(state.boundaryLogFlushTimer);
            state.boundaryLogFlushTimer = null;
          }
          state.boundaryLogBuffer = [];
          return;
        }
        if (!state.book || !state.boundaryLogBuffer.length) {
          return;
        }
        if (state.boundaryLogInFlight) {
          if (force) {
            scheduleBoundaryLogFlush();
          }
          return;
        }
        if (state.boundaryLogFlushTimer) {
          clearTimeout(state.boundaryLogFlushTimer);
          state.boundaryLogFlushTimer = null;
        }

        const takeCount = force
          ? state.boundaryLogBuffer.length
          : Math.min(BOUNDARY_LOG_BATCH_SIZE, state.boundaryLogBuffer.length);
        if (!takeCount) {
          return;
        }
        const entries = state.boundaryLogBuffer.slice(0, takeCount);
        state.boundaryLogBuffer = state.boundaryLogBuffer.slice(takeCount);
        const payload = { book_id: state.book.id, entries };

        if (
          force &&
          typeof navigator !== "undefined" &&
          typeof navigator.sendBeacon === "function"
        ) {
          try {
            const blob = new Blob([JSON.stringify(payload)], {
              type: "application/json",
            });
            const queued = navigator.sendBeacon(
              "/api/playback/boundary-log",
              blob
            );
            if (queued) {
              return;
            }
          } catch (err) {
            // fallback to fetch
          }
        }

        state.boundaryLogInFlight = true;
        try {
          await fetchJson("/api/playback/boundary-log", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
        } catch (err) {
          state.boundaryLogBuffer = entries.concat(state.boundaryLogBuffer);
        } finally {
          state.boundaryLogInFlight = false;
        }

        if (state.boundaryLogBuffer.length) {
          if (force) {
            void flushBoundaryLogBuffer(false);
          } else {
            scheduleBoundaryLogFlush();
          }
        }
      }

      function enqueueBoundaryLog(entry) {
        if (!BOUNDARY_LOG_ENABLED) {
          return;
        }
        if (!state.book || !entry || typeof entry !== "object") {
          return;
        }
        state.boundaryLogBuffer.push(entry);
        if (state.boundaryLogBuffer.length >= BOUNDARY_LOG_BATCH_SIZE) {
          void flushBoundaryLogBuffer();
          return;
        }
        scheduleBoundaryLogFlush();
      }

      function finalizeBoundaryMeasurement(index, context = {}) {
        const pending = state.pendingBoundary;
        if (!pending) {
          return;
        }
        if (!BOUNDARY_LOG_ENABLED) {
          state.pendingBoundary = null;
          return;
        }
        if (pending.toIndex !== index) {
          state.pendingBoundary = null;
          return;
        }
        const deltaMs = performance.now() - pending.expectedAt;
        if (!Number.isFinite(deltaMs)) {
          state.pendingBoundary = null;
          return;
        }
        const playCallAt = Number(context.playCallAt);
        const playResolvedAt = Number(context.playResolvedAt);
        const playCallDelayMs =
          Number.isFinite(playCallAt)
            ? Math.max(0, playCallAt - pending.queuedAt)
            : null;
        const playPromiseMs =
          Number.isFinite(playCallAt) && Number.isFinite(playResolvedAt)
            ? Math.max(0, playResolvedAt - playCallAt)
            : null;
        const baseLatencyMs = Number(context.baseLatencyMs);
        const outputLatencyMs = Number(context.outputLatencyMs);
        const audioContextState = String(context.audioContextState || "");
        const fromItem = state.queue[pending.fromIndex] || {};
        const toItem = state.queue[pending.toIndex] || {};
        const entry = {
          from_index: pending.fromIndex,
          to_index: pending.toIndex,
          from_chapter_id: String(fromItem.chapterId || ""),
          to_chapter_id: String(toItem.chapterId || ""),
          from_chunk_index:
            typeof fromItem.chunkIndex === "number" ? fromItem.chunkIndex : null,
          to_chunk_index:
            typeof toItem.chunkIndex === "number" ? toItem.chunkIndex : null,
          chapter_switch: (fromItem.chapterId || "") !== (toItem.chapterId || ""),
          trigger: String(pending.trigger || "auto"),
          remaining_ms: Math.max(0, Number(pending.remainingMs) || 0),
          delta_ms: Number(deltaMs.toFixed(3)),
          pad_ms: Number(state.padMs) || 0,
          playback_rate: Number(state.playbackRate) || 1,
          preloaded: Boolean(context.usedPreload),
          captured_unix: Math.floor(Date.now() / 1000),
        };
        if (playCallDelayMs !== null) {
          entry.play_call_delay_ms = Number(playCallDelayMs.toFixed(3));
        }
        if (playPromiseMs !== null) {
          entry.play_promise_ms = Number(playPromiseMs.toFixed(3));
        }
        if (Number.isFinite(baseLatencyMs) && baseLatencyMs >= 0) {
          entry.base_latency_ms = Number(baseLatencyMs.toFixed(3));
        }
        if (Number.isFinite(outputLatencyMs) && outputLatencyMs >= 0) {
          entry.output_latency_ms = Number(outputLatencyMs.toFixed(3));
        }
        if (audioContextState) {
          entry.audio_context_state = audioContextState;
        }
        enqueueBoundaryLog(entry);
        state.pendingBoundary = null;
      }

      function setUploadStatus(message, tone = "idle") {
        uploadStatus.textContent = message || "";
        uploadStatus.dataset.tone = tone;
      }

      function setIngestRunning(running) {
        state.ingestRunning = running;
        uploadZone.classList.toggle("disabled", running);
        uploadInput.disabled = running;
      }

      function normalizeBookFilter(value) {
        return value === "txt" ? "txt" : "epub";
      }

      function normalizeShelf(value) {
        return value === "tsundoku" ? "tsundoku" : "books";
      }

      function escapeHtml(value) {
        return String(value || "")
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      function hashString(value) {
        let hash = 2166136261;
        const text = String(value || "");
        for (let i = 0; i < text.length; i += 1) {
          hash ^= text.charCodeAt(i);
          hash = Math.imul(hash, 16777619);
        }
        return hash >>> 0;
      }

      const COVER_THEMES = [
        { bg1: "#f3d7c0", bg2: "#e9b7a0", accent: "#5a8f7d", ink: "#2b211a" },
        { bg1: "#d7e6d2", bg2: "#b7d0c4", accent: "#b26b4b", ink: "#20332b" },
        { bg1: "#f1e1b6", bg2: "#e5c98c", accent: "#58759b", ink: "#2b2417" },
        { bg1: "#d7dbe5", bg2: "#bfc7d6", accent: "#8a5a32", ink: "#2a2f3a" },
        { bg1: "#f0d9de", bg2: "#d7b7c0", accent: "#3c7a6b", ink: "#2c2023" },
        { bg1: "#e6e1d8", bg2: "#cfc7ba", accent: "#7b5742", ink: "#2a241c" },
        { bg1: "#d6e5ea", bg2: "#b7ccd6", accent: "#b15d3f", ink: "#1f2e35" },
        { bg1: "#f2e6da", bg2: "#d7c2ae", accent: "#2c5a6b", ink: "#2b221b" },
      ];

      function coverTheme(book) {
        const seed = hashString(book && (book.id || book.title || ""));
        const theme = COVER_THEMES[seed % COVER_THEMES.length];
        const tilt = (seed % 18) - 9;
        const band = 18 + (seed % 12);
        return {
          ...theme,
          tilt: `${tilt}deg`,
          band: `${band}%`,
        };
      }

      function normalizeCoverText(book) {
        const title = String(book.title || book.id || "Untitled").trim();
        let authors = [];
        if (Array.isArray(book.authors)) {
          authors = book.authors;
        } else if (typeof book.authors === "string") {
          authors = book.authors
            .split(",")
            .map((item) => item.trim())
            .filter(Boolean);
        }
        const authorText = authors.length ? authors.join(", ") : "Unknown";
        const yearText = String(book.year || "n.d.").trim();
        return {
          titleText: title,
          authorText,
          yearText,
          metaText: `${authorText} ${yearText}`,
        };
      }

      function coverText(book) {
        const normalized = normalizeCoverText(book);
        return {
          title: escapeHtml(normalized.titleText),
          meta: `${escapeHtml(normalized.authorText)}<br>${escapeHtml(normalized.yearText)}`,
        };
      }

      function coverDimensions(size) {
        return size === "large"
          ? { width: 120, height: 160 }
          : { width: 52, height: 70 };
      }

      function coverSizing(book, size) {
        const normalized = normalizeCoverText(book);
        const titleLen = normalized.titleText.length;
        const metaLen = normalized.authorText.length + normalized.yearText.length;
        const isLarge = size === "large";
        let titleSize = isLarge ? 16 : 10;
        let metaSize = isLarge ? 11 : 8;
        let pad = isLarge ? 12 : 6;
        let gap = isLarge ? 6 : 4;
        let titleLeading = 1.1;
        let metaLeading = 1.1;

        if (titleLen > 45) {
          titleSize -= isLarge ? 2 : 1;
        }
        if (titleLen > 70) {
          titleSize -= isLarge ? 3 : 2;
        }
        if (titleLen > 95) {
          titleSize -= isLarge ? 3 : 2;
        }
        if (metaLen > 40) {
          metaSize -= isLarge ? 2 : 1;
        }
        if (metaLen > 70) {
          metaSize -= isLarge ? 2 : 1;
        }
        const totalLen = titleLen + metaLen;
        if (totalLen > 120) {
          titleSize -= isLarge ? 2 : 1;
          metaSize -= isLarge ? 1 : 1;
          pad -= isLarge ? 2 : 1;
          titleLeading = 1.05;
          metaLeading = 1.05;
        }

        const minTitle = isLarge ? 8 : 6;
        const minMeta = isLarge ? 6 : 5;
        const minPad = isLarge ? 8 : 4;
        const minGap = isLarge ? 4 : 2;
        const dims = coverDimensions(size);

        const estimateLines = (text, fontSize, width) => {
          if (!text) {
            return 0;
          }
          const avgChar = Math.max(fontSize * 0.56, 1);
          const charsPerLine = Math.max(Math.floor(width / avgChar), 1);
          return Math.ceil(text.length / charsPerLine);
        };

        for (let step = 0; step < 10; step += 1) {
          const availWidth = Math.max(dims.width - pad * 2, 1);
          const availHeight = Math.max(dims.height - pad * 2, 1);
          const titleLines = estimateLines(
            normalized.titleText,
            titleSize,
            availWidth
          );
          const metaLines =
            estimateLines(normalized.authorText, metaSize, availWidth) +
            estimateLines(normalized.yearText, metaSize, availWidth);
          const heightNeeded =
            titleLines * titleSize * titleLeading +
            metaLines * metaSize * metaLeading +
            gap;
          if (heightNeeded <= availHeight) {
            break;
          }
          titleSize = Math.max(titleSize - (isLarge ? 1.4 : 1), minTitle);
          metaSize = Math.max(metaSize - (isLarge ? 1 : 0.8), minMeta);
          if (step % 2 === 0) {
            pad = Math.max(pad - 1, minPad);
            gap = Math.max(gap - 1, minGap);
          }
          titleLeading = 1.05;
          metaLeading = 1.05;
          if (titleSize === minTitle && metaSize === minMeta && pad === minPad) {
            break;
          }
        }

        titleSize = Math.max(titleSize, minTitle);
        metaSize = Math.max(metaSize, minMeta);
        pad = Math.max(pad, minPad);
        gap = Math.max(gap, minGap);

        return {
          titleSize,
          metaSize,
          pad,
          gap,
          titleLeading,
          metaLeading,
        };
      }

      function renderFallbackCover(book, size) {
        const theme = coverTheme(book);
        const text = coverText(book);
        const sizing = coverSizing(book, size);
        const sizeClass = size === "large" ? "large" : "small";
        return `
          <div
            class="cover-fallback ${sizeClass}"
            style="--cover-bg:${theme.bg1};--cover-bg-2:${theme.bg2};--cover-accent:${theme.accent};--cover-ink:${theme.ink};--cover-tilt:${theme.tilt};--cover-band:${theme.band};--cover-title-size:${sizing.titleSize}px;--cover-meta-size:${sizing.metaSize}px;--cover-pad:${sizing.pad}px;--cover-gap:${sizing.gap}px;--cover-title-leading:${sizing.titleLeading};--cover-meta-leading:${sizing.metaLeading};"
          >
            <div class="cover-text">
              <div class="cover-title">${text.title}</div>
              <div class="cover-meta">${text.meta}</div>
            </div>
          </div>
        `;
      }

      function renderCover(book, size) {
        if (book.cover_url) {
          const src = escapeHtml(book.cover_url);
          return `<img src="${src}" alt="Cover" />`;
        }
        return renderFallbackCover(book, size);
      }

      function clampColor(value) {
        return Math.max(0, Math.min(255, Math.round(value)));
      }

      function mixColor(base, target, amount) {
        return {
          r: base.r + (target.r - base.r) * amount,
          g: base.g + (target.g - base.g) * amount,
          b: base.b + (target.b - base.b) * amount,
        };
      }

      function rgbCss(color) {
        return `rgb(${clampColor(color.r)}, ${clampColor(color.g)}, ${clampColor(
          color.b
        )})`;
      }

      function computeAverageColor(img) {
        const width = img.naturalWidth;
        const height = img.naturalHeight;
        if (!width || !height) {
          return null;
        }
        const canvas = document.createElement("canvas");
        const size = 24;
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext("2d", { willReadFrequently: true });
        if (!ctx) {
          return null;
        }
        ctx.drawImage(img, 0, 0, size, size);
        let data;
        try {
          data = ctx.getImageData(0, 0, size, size).data;
        } catch (err) {
          return null;
        }
        let r = 0;
        let g = 0;
        let b = 0;
        let count = 0;
        for (let i = 0; i < data.length; i += 4) {
          const alpha = data[i + 3];
          if (alpha < 8) {
            continue;
          }
          r += data[i];
          g += data[i + 1];
          b += data[i + 2];
          count += 1;
        }
        if (!count) {
          return null;
        }
        return { r: r / count, g: g / count, b: b / count };
      }

      function setCoverBackgroundFromImage(container, img) {
        if (!container || !img || !container.contains(img)) {
          return;
        }
        const avg = computeAverageColor(img);
        if (!avg) {
          container.style.removeProperty("--cover-image-bg");
          return;
        }
        const light = mixColor(avg, { r: 255, g: 255, b: 255 }, 0.22);
        const dark = mixColor(avg, { r: 0, g: 0, b: 0 }, 0.18);
        const gradient = `linear-gradient(160deg, ${rgbCss(light)}, ${rgbCss(
          dark
        )})`;
        container.style.setProperty("--cover-image-bg", gradient);
      }

      function bookSourceType(book) {
        const value = String(book && book.source_type ? book.source_type : "").toLowerCase();
        if (value === "txt") {
          return "txt";
        }
        return "epub";
      }

      function countBookSources() {
        const counts = { epub: 0, txt: 0 };
        state.books.forEach((book) => {
          if (bookOriginType(book) !== "books") {
            return;
          }
          const kind = bookSourceType(book);
          counts[kind] += 1;
        });
        return counts;
      }

      function bookOriginType(book) {
        const explicit = String(
          book && book.source_origin ? book.source_origin : ""
        ).toLowerCase();
        if (explicit === "tsundoku") {
          return "tsundoku";
        }
        const authors = book && book.authors;
        if (Array.isArray(authors)) {
          for (const author of authors) {
            if (String(author || "").trim().toLowerCase() === "tsundoku") {
              return "tsundoku";
            }
          }
        } else if (typeof authors === "string") {
          if (authors.trim().toLowerCase() === "tsundoku") {
            return "tsundoku";
          }
        }
        return "books";
      }

      function countBookOrigins() {
        const counts = { books: 0, tsundoku: 0 };
        state.books.forEach((book) => {
          const shelf = bookOriginType(book);
          counts[shelf] += 1;
        });
        return counts;
      }

      function updateShelfTabs() {
        if (!libraryShelfTabsWrap || !libraryShelfTabs.length) {
          return;
        }
        const counts = countBookOrigins();
        const showTabs = counts.books > 0 && counts.tsundoku > 0;
        libraryShelfTabsWrap.hidden = !showTabs;
        libraryShelfTabsWrap.style.display = showTabs ? "" : "none";
        if (!showTabs) {
          return;
        }
        libraryShelfTabs.forEach((tab) => {
          const shelf = normalizeShelf(tab.dataset.shelf);
          const baseLabel = tab.dataset.label || tab.textContent.trim();
          const count = shelf === "tsundoku" ? counts.tsundoku : counts.books;
          tab.textContent = `${baseLabel} (${count})`;
          const active = state.libraryShelf === shelf;
          tab.classList.toggle("active", active);
          tab.setAttribute("aria-selected", active ? "true" : "false");
        });
      }

      function updateBookTabs() {
        if (!libraryTypeTabsWrap || !libraryTypeTabs.length) {
          return;
        }
        if (normalizeShelf(state.libraryShelf) !== "books") {
          libraryTypeTabsWrap.hidden = true;
          libraryTypeTabsWrap.style.display = "none";
          return;
        }
        const counts = countBookSources();
        const showTabs = counts.epub > 0 && counts.txt > 0;
        libraryTypeTabsWrap.hidden = !showTabs;
        libraryTypeTabsWrap.style.display = showTabs ? "" : "none";
        if (!showTabs) {
          return;
        }
        libraryTypeTabs.forEach((tab) => {
          const filter = normalizeBookFilter(tab.dataset.filter);
          const baseLabel = tab.dataset.label || tab.textContent.trim();
          const count = filter === "txt" ? counts.txt : counts.epub;
          tab.textContent = `${baseLabel} (${count})`;
          const active = state.bookFilter === filter;
          tab.classList.toggle("active", active);
          tab.setAttribute("aria-selected", active ? "true" : "false");
        });
      }

      function setBookFilter(filter, persist = true) {
        const normalized = normalizeBookFilter(filter);
        state.bookFilter = normalized;
        if (persist) {
          localStorage.setItem("ptts.bookFilter", normalized);
        }
        renderBooks();
      }

      function setShelfFilter(shelf, persist = true) {
        const normalized = normalizeShelf(shelf);
        state.libraryShelf = normalized;
        if (persist) {
          localStorage.setItem("ptts.libraryShelf", normalized);
        }
        renderBooks();
      }

      function pad6(num) {
        return String(num).padStart(6, "0");
      }

      function readUrlState() {
        const params = new URLSearchParams(window.location.search);
        state.initialBookId = params.get("book");
        state.initialChapterId = params.get("chapter");
      }

      function updateUrl(bookId, chapterId) {
        const params = new URLSearchParams();
        if (bookId) {
          params.set("book", bookId);
        }
        if (chapterId) {
          params.set("chapter", chapterId);
        }
        const query = params.toString();
        const next = query ? `/?${query}` : "/";
        history.replaceState(null, "", next);
      }

      function isMobileLayout() {
        return window.matchMedia("(max-width: 980px)").matches;
      }

      function scrollToBookSection() {
        if (!isMobileLayout()) {
          return;
        }
        const target = document.getElementById("bookSection");
        if (target) {
          target.scrollIntoView({ behavior: "smooth", block: "start" });
        }
      }

      function scrollToTextPane() {
        if (!isMobileLayout()) {
          return;
        }
        const target = document.getElementById("textPane");
        if (target) {
          target.scrollIntoView({ behavior: "smooth", block: "start" });
        }
      }

      function normalizeTheme(value) {
        const cleaned = String(value || "").trim().toLowerCase();
        if (cleaned === "light" || cleaned === "dark") {
          return cleaned;
        }
        return "system";
      }

      function resolveTheme(preference) {
        const normalized = normalizeTheme(preference);
        if (normalized === "system") {
          return themeQuery.matches ? "dark" : "light";
        }
        return normalized;
      }

      function updateThemeToggle() {
        if (!themeToggle) {
          return;
        }
        const resolved = resolveTheme(state.themePreference);
        const prettyResolved =
          resolved.charAt(0).toUpperCase() + resolved.slice(1);
        const title = `Theme: ${prettyResolved}`;
        themeToggle.setAttribute("aria-label", title);
        themeToggle.setAttribute("title", title);
        themeToggle.dataset.themeMode = resolved;
      }

      function applyTheme(preference, persist = false) {
        const normalized = normalizeTheme(preference);
        state.themePreference = normalized;
        document.documentElement.classList.add("theme-switching");
        if (normalized === "system") {
          document.documentElement.removeAttribute("data-theme");
        } else {
          document.documentElement.setAttribute("data-theme", normalized);
        }
        updateThemeToggle();
        window.setTimeout(() => {
          document.documentElement.classList.remove("theme-switching");
        }, 80);
        if (persist) {
          if (normalized === "system") {
            localStorage.removeItem("ptts.theme");
          } else {
            localStorage.setItem("ptts.theme", normalized);
          }
        }
      }

      function cycleTheme() {
        const resolved = resolveTheme(state.themePreference);
        const next = resolved === "dark" ? "light" : "dark";
        applyTheme(next, true);
      }

      function getBookmarks() {
        return state.playback.bookmarks || [];
      }

      function saveBookmarks(bookmarks, persist = true) {
        state.playback.bookmarks = Array.isArray(bookmarks) ? bookmarks : [];
        if (persist) {
          schedulePlaybackSave();
        }
      }

      function getLastPlayed() {
        const value = state.playback.lastPlayed;
        return typeof value === "number" ? value : null;
      }

      function getFurthestPlayed() {
        const value = state.playback.furthestPlayed;
        return typeof value === "number" ? value : null;
      }

      function setLastPlayed(index, persist = true) {
        state.playback.lastPlayed =
          typeof index === "number" ? index : null;
        if (typeof index === "number") {
          const currentFurthest = getFurthestPlayed();
          if (currentFurthest === null || index > currentFurthest) {
            state.playback.furthestPlayed = index;
          }
        }
        if (persist) {
          schedulePlaybackSave();
        }
      }

      async function fetchJson(url, options = {}) {
        const opts = { cache: "no-store", ...options };
        if (options.headers) {
          opts.headers = { ...options.headers };
        }
        const res = await fetch(url, opts);
        if (!res.ok) {
          let detail = `Request failed: ${res.status}`;
          let payload = null;
          try {
            payload = await res.json();
            if (payload && payload.detail) {
              detail =
                typeof payload.detail === "string"
                  ? payload.detail
                  : JSON.stringify(payload.detail);
            }
          } catch (err) {
            // ignore parse errors
          }
          const error = new Error(detail);
          error.status = res.status;
          if (payload) {
            error.payload = payload;
          }
          throw error;
        }
        return res.json();
      }

      async function ingestFile(file, options = {}) {
        if (!file) {
          return;
        }
        const name = file.name || "";
        const lowerName = name.toLowerCase();
        if (
          !lowerName.endsWith(".epub") &&
          !lowerName.endsWith(".txt")
        ) {
          setUploadStatus("Only .epub or .txt files are supported.", "error");
          return;
        }
        if (state.ingestRunning) {
          return;
        }
        let override = options.override === true;
        setIngestRunning(true);
        const makeBody = () => {
          const body = new FormData();
          body.append("file", file);
          return body;
        };
        while (true) {
          const verb = override
            ? "Overwriting and ingesting"
            : "Ingesting and sanitizing";
          setUploadStatus(`${verb} ${name}...`);
          try {
            const data = await fetchJson(
              override ? "/api/ingest?override=1" : "/api/ingest",
              {
                method: "POST",
                body: makeBody(),
              }
            );
            const title = data.title || data.book_id || "Book";
            setUploadStatus(`Ingested and sanitized ${title}.`);
            await loadBooks();
            if (data.book_id) {
              await selectBook(data.book_id);
            }
            break;
          } catch (err) {
            const detail =
              err && typeof err.message === "string" ? err.message : "";
            if (
              !override &&
              err &&
              err.status === 409 &&
              detail.startsWith("Book already exists")
            ) {
              const existing = err.payload ? err.payload.book_id : "";
              const label = existing ? `"${existing}"` : "this book";
              const confirmed = window.confirm(
                `Book ${label} already exists. Overwrite it? This will delete the existing book folder.`
              );
              if (confirmed) {
                override = true;
                continue;
              }
              setUploadStatus("Ingest canceled.", "error");
              break;
            }
            setUploadStatus(detail || "Ingest failed.", "error");
            break;
          }
        }
        setIngestRunning(false);
        uploadInput.value = "";
      }

      function setSelectedVoice(value, persist = true) {
        state.selectedVoice = value;
        const buttons = voiceGroup.querySelectorAll(".voice-button");
        buttons.forEach((button) => {
          button.classList.toggle("active", button.dataset.voice === value);
        });
        updateLocalVoiceActionButton();
        if (state.advancedMode) {
          state.voiceMap.default = value;
          if (persist) {
            scheduleVoiceMapSave();
          }
          renderAdvancedPanel();
        } else {
          state.voicePreference = value;
          if (persist) {
            if (value) {
              localStorage.setItem("ptts.voice", value);
            } else {
              localStorage.removeItem("ptts.voice");
            }
          }
        }
      }

      function getSelectedVoice() {
        return state.selectedVoice;
      }

      function normalizeVoiceGender(value) {
        const raw = String(value || "").trim().toLowerCase();
        if (raw === "female" || raw === "male") {
          return raw;
        }
        return "";
      }

      function getCloneGenderValue() {
        if (cloneGenderMale && cloneGenderMale.checked) {
          return "male";
        }
        if (cloneGenderFemale && cloneGenderFemale.checked) {
          return "female";
        }
        return "";
      }

      function setCloneGenderValue(value) {
        const normalized = normalizeVoiceGender(value);
        if (cloneGenderMale) {
          cloneGenderMale.checked = normalized === "male";
        }
        if (cloneGenderFemale) {
          cloneGenderFemale.checked = normalized === "female";
        }
      }

      function setCloneGenderDisabled(disabled) {
        if (cloneGenderMale) {
          cloneGenderMale.disabled = disabled;
        }
        if (cloneGenderFemale) {
          cloneGenderFemale.disabled = disabled;
        }
      }

      function focusCloneGender() {
        if (cloneGenderMale && !cloneGenderMale.disabled) {
          cloneGenderMale.focus();
          return;
        }
        if (cloneGenderFemale && !cloneGenderFemale.disabled) {
          cloneGenderFemale.focus();
        }
      }

      function isLocalVoice(value) {
        if (!value) {
          return false;
        }
        return state.localVoiceValues.includes(value);
      }

      function selectedLocalVoice() {
        return isLocalVoice(state.selectedVoice) ? state.selectedVoice : null;
      }

      function updateCloneBuiltinToggleLabel() {
        if (!cloneBuiltinToggle) {
          return;
        }
        cloneBuiltinToggle.textContent = state.showBuiltinVoices
          ? "Hide built-in voices"
          : "Show built-in voices";
      }

      function setBuiltinVoicesVisible(visible) {
        const normalized = !!visible;
        if (state.showBuiltinVoices === normalized) {
          return;
        }
        state.showBuiltinVoices = normalized;
        localStorage.setItem(
          "ptts.showBuiltinVoices",
          state.showBuiltinVoices ? "1" : "0"
        );
        updateCloneBuiltinToggleLabel();
        void loadVoices();
      }

      function updateLocalVoiceActionButton() {
        if (!localVoiceActionButton) {
          return;
        }
        const selected = selectedLocalVoice();
        if (selected) {
          localVoiceActionButton.textContent = "Edit";
          localVoiceActionButton.title = "Edit selected local voice metadata";
          localVoiceActionButton.setAttribute(
            "aria-label",
            "Edit selected local voice metadata"
          );
          localVoiceActionButton.classList.add("edit-mode");
          localVoiceActionButton.dataset.mode = "edit";
        } else {
          localVoiceActionButton.textContent = "+";
          localVoiceActionButton.title = "Clone local voice";
          localVoiceActionButton.setAttribute("aria-label", "Clone local voice");
          localVoiceActionButton.classList.remove("edit-mode");
          localVoiceActionButton.dataset.mode = "add";
        }
      }

      function createVoiceSelectionButton(item) {
        const button = document.createElement("button");
        button.type = "button";
        button.className = "voice-button";
        button.dataset.voice = item.value;
        button.textContent = displayVoiceLabel(item);
        button.addEventListener("click", () => {
          if (state.selectedVoice === item.value) {
            setSelectedVoice(null);
            return;
          }
          setSelectedVoice(item.value);
        });
        return button;
      }

      function createLocalVoiceActionButton() {
        const actionButton = document.createElement("button");
        actionButton.type = "button";
        actionButton.className = "voice-button voice-action";
        actionButton.addEventListener("click", () => {
          const selected = selectedLocalVoice();
          if (selected) {
            openCloneModal("edit", selected);
            return;
          }
          openCloneModal("add");
        });
        localVoiceActionButton = actionButton;
        updateLocalVoiceActionButton();
        return actionButton;
      }

      function appendVoiceGroup(container, label, items, options = {}) {
        const includeAddButton = !!options.includeAddButton;
        if (!items.length && !includeAddButton) {
          return;
        }
        const group = document.createElement("div");
        group.className = "voice-group";
        const title = document.createElement("div");
        title.className = "voice-group-title";
        title.textContent = label;
        const buttons = document.createElement("div");
        buttons.className = "voice-buttons";
        items.forEach((item) => {
          buttons.appendChild(createVoiceSelectionButton(item));
        });
        if (includeAddButton) {
          buttons.appendChild(createLocalVoiceActionButton());
        }
        group.appendChild(title);
        group.appendChild(buttons);
        container.appendChild(group);
      }

      function formatVoiceLabel(label) {
        if (!label) {
          return "";
        }
        const cleaned = String(label).replace(/[_-]+/g, " ").trim();
        if (!cleaned) {
          return "";
        }
        return cleaned
          .split(/\s+/)
          .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
          .join(" ");
      }

      function displayVoiceLabel(item) {
        if (!item || !item.label) {
          return "";
        }
        const value = typeof item.value === "string" ? item.value : "";
        const metadataLabel = value ? state.voiceDisplayNameMap[value] : "";
        if (metadataLabel) {
          return metadataLabel;
        }
        return formatVoiceLabel(item.label);
      }

      function voiceLabelFromValue(value) {
        if (!value) {
          return "";
        }
        const match = state.voiceOptions.find((entry) => entry.value === value);
        if (match && match.label) {
          return displayVoiceLabel(match);
        }
        const parts = String(value).split(/[\\/]/);
        let leaf = parts[parts.length - 1] || "";
        if (leaf) {
          leaf = leaf.replace(/\.[^.]+$/, "");
          return formatVoiceLabel(leaf);
        }
        return formatVoiceLabel(value);
      }

      function voiceStemFromValue(value) {
        if (!value) {
          return "";
        }
        const parts = String(value).split(/[\\/]/);
        const leaf = parts[parts.length - 1] || "";
        if (!leaf) {
          return "";
        }
        return leaf.replace(/\.[^.]+$/, "");
      }

      function renderLocalVoiceGroups(local) {
        const female = [];
        const male = [];
        const unspecified = [];
        local.forEach((item) => {
          const gender = normalizeVoiceGender(item.gender);
          if (gender === "female") {
            female.push(item);
          } else if (gender === "male") {
            male.push(item);
          } else {
            unspecified.push(item);
          }
        });
        const group = document.createElement("div");
        group.className = "voice-group";
        const title = document.createElement("div");
        title.className = "voice-group-title";
        title.textContent = "Local voices";
        const row = document.createElement("div");
        row.className = "local-voice-row";
        const buckets = [
          { label: "F", items: female, title: "Female voices" },
          { label: "M", items: male, title: "Male voices" },
          { label: "Other", items: unspecified, title: "Unspecified voices" },
        ];
        let hasLocal = false;
        buckets.forEach((bucket) => {
          if (!bucket.items.length) {
            return;
          }
          hasLocal = true;
          const section = document.createElement("div");
          section.className = "local-voice-section";
          section.title = bucket.title;
          const label = document.createElement("span");
          label.className = "local-voice-section-label";
          label.textContent = bucket.label;
          const buttons = document.createElement("div");
          buttons.className = "local-voice-section-buttons";
          bucket.items.forEach((item) => {
            buttons.appendChild(createVoiceSelectionButton(item));
          });
          section.appendChild(label);
          section.appendChild(buttons);
          row.appendChild(section);
        });
        if (!hasLocal) {
          const empty = document.createElement("div");
          empty.className = "voice-empty";
          empty.textContent = "No local voices.";
          row.appendChild(empty);
        }
        row.appendChild(createLocalVoiceActionButton());
        group.appendChild(title);
        group.appendChild(row);
        voiceGroup.appendChild(group);
      }

      async function loadVoices() {
        try {
          const data = await fetchJson("/api/voices");
          const local = Array.isArray(data.local) ? data.local : [];
          const builtin = Array.isArray(data.builtin) ? data.builtin : [];
          const visibleBuiltin = state.showBuiltinVoices ? builtin : [];
          const defaultVoice = data.default || "";

          state.localVoiceValues = local
            .map((item) => item.value)
            .filter((value) => typeof value === "string" && value);
          const voiceGenderMap = {};
          const voiceDisplayNameMap = {};
          local.forEach((item) => {
            const value = typeof item.value === "string" ? item.value : "";
            if (!value) {
              return;
            }
            const gender = normalizeVoiceGender(item.gender);
            if (gender) {
              voiceGenderMap[value] = gender;
            }
            if (
              typeof item.display_name === "string" &&
              item.display_name.trim()
            ) {
              voiceDisplayNameMap[value] = item.display_name.trim();
            }
          });
          state.voiceGenderMap = voiceGenderMap;
          state.voiceDisplayNameMap = voiceDisplayNameMap;

          state.voiceOptions = [...local, ...builtin];
          voiceGroup.innerHTML = "";
          localVoiceActionButton = null;
          renderLocalVoiceGroups(local);
          appendVoiceGroup(voiceGroup, "Built-in voices", visibleBuiltin);

          const available = state.voiceOptions.map((item) => item.value);
          if (!available.length) {
            setSelectedVoice(null, false);
            renderAdvancedPanel();
            return;
          }

          let selected = state.advancedMode
            ? state.voiceMap.default
            : state.bookVoice || state.voicePreference;
          if (!selected || !available.includes(selected)) {
            if (local.length) {
              selected = local[0].value;
            } else if (defaultVoice && available.includes(defaultVoice)) {
              selected = defaultVoice;
            } else if (builtin.length) {
              selected = builtin[0].value;
            } else {
              selected = null;
            }
          }
          setSelectedVoice(selected, false);
          if (state.advancedMode && state.voiceMap.default !== selected) {
            state.voiceMap.default = selected;
            scheduleVoiceMapSave();
          }
          renderAdvancedPanel();
        } catch (err) {
          voiceGroup.innerHTML = "<div class=\"voice-empty\">Unable to load voices.</div>";
        }
      }

      async function loadVoiceMap() {
        if (!state.book) {
          return;
        }
        try {
          const data = await fetchJson(
            `/api/books/${encodeURIComponent(state.book.id)}/voices`
          );
          const chapters =
            data && typeof data.chapters === "object" ? data.chapters : {};
          state.voiceMap = {
            default: data.default || null,
            chapters,
          };
        } catch (err) {
          state.voiceMap = {
            default: state.voicePreference,
            chapters: {},
          };
        }
      }

      function scheduleVoiceMapSave() {
        if (!state.book || !state.advancedMode) {
          return;
        }
        if (state.voiceMapSaveTimer) {
          clearTimeout(state.voiceMapSaveTimer);
        }
        state.voiceMapSaveTimer = setTimeout(() => {
          saveVoiceMap();
        }, 600);
      }

      async function saveVoiceMap() {
        if (!state.book || !state.advancedMode) {
          return false;
        }
        const payload = {
          default: state.voiceMap.default,
          chapters: state.voiceMap.chapters || {},
        };
        try {
          const data = await fetchJson(
            `/api/books/${encodeURIComponent(state.book.id)}/voices`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
            }
          );
          const chapters =
            data && typeof data.chapters === "object" ? data.chapters : {};
          state.voiceMap = {
            default: data.default || state.voiceMap.default,
            chapters,
          };
          renderAdvancedPanel();
          return true;
        } catch (err) {
          console.warn("Failed to save voice map.", err);
          return false;
        }
      }

      function updateAdvancedMode(persist = true) {
        advancedPanel.classList.toggle("open", !!state.advancedMode);
        advancedToggle.textContent = "Multi-Voices";
        advancedToggle.classList.toggle("mode-on", state.advancedMode);
        advancedToggle.classList.toggle("mode-off", !state.advancedMode);
        if (persist) {
          saveSettings();
        }
        updateSampleButtonState();
        if (state.book) {
          loadVoiceMap().then(() => loadVoices());
        } else {
          renderAdvancedPanel();
        }
        updateAdvancedControls();
      }

      function renderAdvancedPanel() {
        const show = state.advancedMode && !!state.book;
        advancedPanel.classList.toggle("open", show);
        if (!show) {
          advancedList.innerHTML = "";
          return;
        }
        renderAdvancedList();
        updateAdvancedControls();
      }

      function renderAdvancedList() {
        advancedList.innerHTML = "";
        const chapters = state.chapters || [];
        if (!chapters.length) {
          advancedList.innerHTML =
            "<p class=\"voice-empty\">No chapters yet.</p>";
          updateAdvancedSelectionStats();
          return;
        }
        const chapterIds = new Set(
          chapters.map((chapter) => chapter.id).filter(Boolean)
        );
        state.advancedSelection = new Set(
          [...state.advancedSelection].filter((id) => chapterIds.has(id))
        );
        const defaultLabel = voiceLabelFromValue(state.voiceMap.default || "");
        buildVoiceOptions(advancedBulkVoice, defaultLabel);
        if (!advancedBulkVoice.value) {
          advancedBulkVoice.value = "default";
        }
        chapters.forEach((chapter, index) => {
          const row = document.createElement("div");
          const chapterId = chapter.id || "";
          row.className = "advanced-row";
          if (state.advancedSelection.has(chapterId)) {
            row.classList.add("selected");
          }
          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.checked = state.advancedSelection.has(chapterId);
          checkbox.addEventListener("click", (event) => {
            handleAdvancedSelection(event, index, chapterId);
          });

          const info = document.createElement("div");
          const title = document.createElement("div");
          title.textContent = chapter.title || chapterId || "Chapter";
          const meta = document.createElement("div");
          meta.className = "advanced-meta";
          meta.textContent = `${chapter.chunk_count || 0} chunks`;
          info.appendChild(title);
          info.appendChild(meta);

          const select = document.createElement("select");
          select.className = "advanced-select";
          buildVoiceOptions(select, defaultLabel);
          const override = state.voiceMap.chapters
            ? state.voiceMap.chapters[chapterId]
            : null;
          select.value = override || "default";
          select.addEventListener("change", () => {
            updateChapterVoice(chapterId, select.value);
          });

          row.appendChild(checkbox);
          row.appendChild(info);
          row.appendChild(select);
          advancedList.appendChild(row);
        });
        updateAdvancedSelectionStats();
      }

      function buildVoiceOptions(select, defaultLabel) {
        select.innerHTML = "";
        const defaultOption = document.createElement("option");
        defaultOption.value = "default";
        defaultOption.textContent = defaultLabel
          ? `Default (${defaultLabel})`
          : "Default";
        select.appendChild(defaultOption);
        const buckets = {
          female: [],
          male: [],
          unspecified: [],
          builtin: [],
        };
        state.voiceOptions.forEach((entry) => {
          if (!entry || !entry.value) {
            return;
          }
          if (isLocalVoice(entry.value)) {
            const gender = normalizeVoiceGender(
              entry.gender || state.voiceGenderMap[entry.value]
            );
            if (gender === "female") {
              buckets.female.push(entry);
            } else if (gender === "male") {
              buckets.male.push(entry);
            } else {
              buckets.unspecified.push(entry);
            }
          } else {
            buckets.builtin.push(entry);
          }
        });

        const appendOptionGroup = (label, items) => {
          if (!items.length) {
            return;
          }
          const group = document.createElement("optgroup");
          group.label = label;
          items.forEach((entry) => {
            const option = document.createElement("option");
            option.value = entry.value;
            option.textContent = displayVoiceLabel(entry);
            group.appendChild(option);
          });
          select.appendChild(group);
        };

        appendOptionGroup("Female local voices", buckets.female);
        appendOptionGroup("Male local voices", buckets.male);
        appendOptionGroup("Unspecified local voices", buckets.unspecified);
        appendOptionGroup("Built-in voices", buckets.builtin);
      }

      function updateChapterVoice(chapterId, voiceValue) {
        if (!chapterId) {
          return;
        }
        if (voiceValue === "default" || !voiceValue) {
          delete state.voiceMap.chapters[chapterId];
        } else {
          state.voiceMap.chapters[chapterId] = voiceValue;
        }
        scheduleVoiceMapSave();
        renderAdvancedList();
      }

      function handleAdvancedSelection(event, index, chapterId) {
        const checked = event.target.checked;
        if (event.shiftKey && state.advancedLastIndex !== null) {
          const start = Math.min(state.advancedLastIndex, index);
          const end = Math.max(state.advancedLastIndex, index);
          for (let i = start; i <= end; i += 1) {
            const entry = state.chapters[i];
            if (!entry || !entry.id) {
              continue;
            }
            if (checked) {
              state.advancedSelection.add(entry.id);
            } else {
              state.advancedSelection.delete(entry.id);
            }
          }
        } else {
          if (checked) {
            state.advancedSelection.add(chapterId);
          } else {
            state.advancedSelection.delete(chapterId);
          }
        }
        state.advancedLastIndex = index;
        renderAdvancedList();
      }

      function updateAdvancedSelectionStats() {
        const total = state.chapters.length;
        const selected = state.advancedSelection.size;
        advancedSelectedCount.textContent = `${selected} selected`;
        if (total > 0) {
          advancedSelectAll.checked = selected === total;
          advancedSelectAll.indeterminate = selected > 0 && selected < total;
        } else {
          advancedSelectAll.checked = false;
          advancedSelectAll.indeterminate = false;
        }
      }

      function updateAdvancedControls() {
        const disabled =
          !state.book ||
          !state.advancedMode ||
          state.synthRunning ||
          state.mergeRunning;
        advancedSelectAll.disabled = disabled;
        advancedBulkVoice.disabled = disabled;
        const hasSelection = state.advancedSelection.size > 0;
        advancedApplyVoice.disabled = disabled || !hasSelection;
        advancedClearVoice.disabled = disabled || !hasSelection;
        advancedList.querySelectorAll("input, select").forEach((element) => {
          element.disabled = disabled;
        });
      }

      function schedulePlaybackSave() {
        if (!state.book) {
          return;
        }
        if (state.playbackSaveTimer) {
          clearTimeout(state.playbackSaveTimer);
        }
        state.playbackSaveTimer = setTimeout(() => {
          persistPlayback();
        }, 500);
      }

      async function persistPlayback(payload) {
        if (!state.book) {
          return;
        }
        const body = payload || {
          last_played: getLastPlayed(),
          furthest_played: getFurthestPlayed(),
          bookmarks: getBookmarks(),
        };
        try {
          await fetchJson(
            `/api/playback?book_id=${encodeURIComponent(state.book.id)}`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(body),
            }
          );
        } catch (err) {
          console.warn("Failed to persist playback state.", err);
        }
      }

      function clearBookView() {
        void flushBoundaryLogBuffer(true);
        clearPendingBoundaryMeasurement();
        if (state.boundaryLogFlushTimer) {
          clearTimeout(state.boundaryLogFlushTimer);
          state.boundaryLogFlushTimer = null;
        }
        state.boundaryLogBuffer = [];
        state.boundaryLogInFlight = false;
        state.book = null;
        state.chapters = [];
        state.chapterMap = {};
        state.chapterTextRequests = {};
        state.chapterRenderToken = 0;
        state.queue = [];
        state.chapterOffsets = {};
        state.currentChapterId = null;
        state.currentQueueIndex = 0;
        state.activeQueueIndex = null;
        state.selectedQueueIndex = null;
        state.audioBase = "";
        state.chunkCacheBust = {};
        state.chunkRegenRunning = false;
        state.padMs = 0;
        state.mergeRunning = false;
        state.mergeReady = false;
        state.mergePartial = false;
        state.mergeExitCode = null;
        state.mergeOutputExists = false;
        state.mergeOutputParts = [];
        state.mergeStage = "idle";
        closeDownloadMenu();
        state.synthRunning = false;
        state.synthMode = "tts";
        state.playback = { lastPlayed: null, furthestPlayed: null, bookmarks: [] };
        state.bookVoice = null;
        state.voiceMap = { default: null, chapters: {} };
        state.selectedVoice = null;
        state.voiceOptions = [];
        state.advancedSelection = new Set();
        state.advancedLastIndex = null;
        resetAudioPlayers();
        bookTitle.textContent = "Select a book";
        bookMeta.textContent = "No book loaded.";
        bookStatus.textContent = "";
        coverLarge.innerHTML = "";
        coverLarge.style.removeProperty("--cover-image-bg");
        chapterTitle.textContent = "Waiting for a book...";
        chapterText.innerHTML =
          "<p class=\"empty-state\">Pick a book on the left to start.</p>";
        chapterList.innerHTML = "";
        ffmpegStatus.textContent = "";
        editPanel.classList.remove("open");
        editToggle.textContent = "Edit";
        state.editOpen = false;
        state.previewChapterIndex = null;
        state.previewSelectedTitle = "";
        state.previewSelectedKind = "";
        state.readingOverridesDirty = false;
        state.readingOverridesOriginal = "";
        if (readingOverrides) {
          readingOverrides.value = "";
        }
        updateUrl(null, null);
        updateMergeButtonState();
        updateClearButtonState();
        renderAdvancedPanel();
        updateMarks();
        closeMetaModal();
      }

      async function loadPlayback() {
        if (!state.book) {
          return;
        }
        try {
          const data = await fetchJson(
            `/api/playback?book_id=${encodeURIComponent(state.book.id)}`
          );
          const last =
            typeof data.last_played === "number" ? data.last_played : null;
          const furthest =
            typeof data.furthest_played === "number" ? data.furthest_played : null;
          const marks = Array.isArray(data.bookmarks) ? data.bookmarks : [];
          const effectiveFurthest = furthest === null ? last : furthest;
          state.playback.furthestPlayed = effectiveFurthest;
          setLastPlayed(last, false);
          saveBookmarks(marks, false);
          if (!data.exists) {
            await persistPlayback({
              last_played: last,
              furthest_played: effectiveFurthest,
              bookmarks: marks,
            });
          }
        } catch (err) {
          console.warn("Failed to load playback state.", err);
        }
      }

      async function loadBooks() {
        try {
          const data = await fetchJson("/api/books");
          state.books = data.books || [];
          renderBooks();
          if (state.initialBookId && !state.book) {
            const initial = state.initialBookId;
            const chapter = state.initialChapterId;
            state.initialBookId = null;
            state.initialChapterId = null;
            await selectBook(initial, chapter);
          }
        } catch (err) {
          bookList.innerHTML = "<p class=\"empty-state\">Failed to load books.</p>";
        }
      }

      function loadSettings() {
        state.voicePreference = localStorage.getItem("ptts.voice");
        state.advancedMode = localStorage.getItem("ptts.advancedMode") === "1";
        state.showBuiltinVoices =
          localStorage.getItem("ptts.showBuiltinVoices") !== "0";
        state.libraryShelf = normalizeShelf(
          localStorage.getItem("ptts.libraryShelf")
        );
        state.bookFilter = normalizeBookFilter(
          localStorage.getItem("ptts.bookFilter")
        );
        applyTheme(normalizeTheme(localStorage.getItem("ptts.theme")), false);
        themeQuery.addEventListener("change", () => {
          if (normalizeTheme(state.themePreference) === "system") {
            updateThemeToggle();
          }
        });
        const collapsed = localStorage.getItem("ptts.ttsCollapsed") === "1";
        if (collapsed) {
          ttsPanel.classList.add("collapsed");
          ttsToggle.textContent = "Expand";
        }
        updateAdvancedMode(false);
      }

      function saveSettings() {
        if (state.voicePreference) {
          localStorage.setItem("ptts.voice", state.voicePreference);
        }
        localStorage.setItem("ptts.advancedMode", state.advancedMode ? "1" : "0");
        localStorage.setItem(
          "ptts.showBuiltinVoices",
          state.showBuiltinVoices ? "1" : "0"
        );
      }

      function filterBooksForShelf() {
        const shelf = normalizeShelf(state.libraryShelf);
        if (shelf === "tsundoku") {
          return state.books.filter((book) => bookOriginType(book) === "tsundoku");
        }
        const filter = normalizeBookFilter(state.bookFilter);
        if (filter === "txt") {
          return state.books.filter(
            (book) =>
              bookOriginType(book) === "books" && bookSourceType(book) === "txt"
          );
        }
        return state.books.filter(
          (book) =>
            bookOriginType(book) === "books" && bookSourceType(book) !== "txt"
        );
      }

      function renderBooks() {
        bookList.innerHTML = "";
        const originCounts = countBookOrigins();
        if (originCounts.books === 0 && originCounts.tsundoku > 0) {
          state.libraryShelf = "tsundoku";
        } else if (originCounts.tsundoku === 0 && originCounts.books > 0) {
          state.libraryShelf = "books";
        }
        updateShelfTabs();
        if (normalizeShelf(state.libraryShelf) === "books") {
          const counts = countBookSources();
          if (counts.epub > 0 && counts.txt === 0) {
            state.bookFilter = "epub";
          } else if (counts.txt > 0 && counts.epub === 0) {
            state.bookFilter = "txt";
          }
        }
        updateBookTabs();
        if (!state.books.length) {
          bookList.innerHTML = "<p class=\"empty-state\">No books found.</p>";
          return;
        }
        const visible = filterBooksForShelf();
        if (!visible.length) {
          if (normalizeShelf(state.libraryShelf) === "tsundoku") {
            bookList.innerHTML =
              "<p class=\"empty-state\">No Tsundoku items found.</p>";
          } else {
            const label = state.bookFilter === "txt" ? "TXT" : "EPUB";
            bookList.innerHTML = `<p class="empty-state">No ${label} books found.</p>`;
          }
          return;
        }
        visible.forEach((book) => {
          const card = document.createElement("div");
          card.className = "book-card";
          if (state.book && state.book.id === book.id) {
            card.classList.add("active");
          }
          if (book.playback_complete) {
            card.classList.add("finished");
          }
          const audioTotal = Number(book.audio_total || 0);
          const audioDone = Number(book.audio_done || 0);
          let statusText = "No audio yet";
          if (book.has_audio) {
            if (audioTotal && audioDone >= audioTotal) {
              statusText = "Audio complete";
            } else if (audioTotal && audioDone > 0) {
              statusText = `Audio ${audioDone}/${audioTotal}`;
            } else {
              statusText = "Audio preparing";
            }
          }
          const finishedBadge = book.playback_complete
            ? "<span class=\"book-tag finished\">Finished</span>"
            : "";
          card.innerHTML = `
            <div class="book-cover">${renderCover(book, "small")}</div>
            <div class="book-meta">
              <h4>${escapeHtml(book.title || book.id || "Untitled")}</h4>
              <p>${escapeHtml((book.authors || []).join(", "))}</p>
              <p class="book-status">
                <span>${statusText}</span>
                ${finishedBadge}
              </p>
            </div>
          `;
          card.addEventListener("click", () => selectBook(book.id));
          bookList.appendChild(card);
        });
      }

      function markBookFinished() {
        if (!state.book || !state.queue.length) {
          return;
        }
        const furthest = getFurthestPlayed();
        if (furthest === null || furthest < state.queue.length - 1) {
          return;
        }
        const entry = state.books.find((book) => book.id === state.book.id);
        if (entry && !entry.playback_complete) {
          entry.playback_complete = true;
          renderBooks();
        }
        if (state.book && !state.book.playback_complete) {
          state.book.playback_complete = true;
        }
      }

      async function selectBook(bookId, chapterId) {
        if (state.book && state.book.id !== bookId) {
          await flushBoundaryLogBuffer(true);
          clearPendingBoundaryMeasurement();
          state.boundaryLogBuffer = [];
        }
        state.loadingBook = true;
        resetAudioPlayers();
        try {
          const data = await fetchJson(`/api/books/${bookId}`);
          state.book = data.book;
          state.chapters = data.chapters || [];
          state.advancedSelection = new Set();
          state.advancedLastIndex = null;
          state.padMs = data.book ? data.book.pad_ms || 0 : 0;
          state.bookVoice = data.book ? data.book.last_voice || null : null;
          state.playback = { lastPlayed: null, furthestPlayed: null, bookmarks: [] };
          state.mergeRunning = false;
          state.mergeReady = false;
          state.mergePartial = false;
          state.mergeExitCode = null;
          state.mergeOutputExists = false;
          state.mergeOutputParts = [];
          state.mergeStage = "idle";
          closeDownloadMenu();
          state.synthMode = "tts";
          mergeStatus.textContent = "";
          state.chapterMap = {};
          state.chapterTextRequests = {};
          state.chapterRenderToken = 0;
          state.chapters.forEach((chapter) => {
            if (chapter && chapter.id) {
              state.chapterMap[chapter.id] = chapter;
            }
          });
          state.audioBase = data.audio_base || "";
          state.currentQueueIndex = 0;
          state.activeQueueIndex = null;
          state.selectedQueueIndex = null;
          state.chunkCacheBust = {};
          state.chunkRegenRunning = false;
          state.waitingFor = null;
          if (state.waitTimer) {
            clearTimeout(state.waitTimer);
          }
          await loadPlayback();
          buildQueue();
          const desiredChapter = state.chapters.length
            ? chapterId || state.chapters[0].id
            : null;
          const prefetchIds = new Set();
          if (desiredChapter) {
            prefetchIds.add(desiredChapter);
          }
          const lastIndex = getLastPlayed();
          if (lastIndex !== null) {
            const lastChapterId = chapterIdForQueueIndex(lastIndex);
            if (lastChapterId) {
              prefetchIds.add(lastChapterId);
            }
          }
          const furthestIndex = getFurthestPlayed();
          if (furthestIndex !== null) {
            const furthestChapterId = chapterIdForQueueIndex(furthestIndex);
            if (furthestChapterId) {
              prefetchIds.add(furthestChapterId);
            }
          }
          prefetchIds.forEach((id) => {
            void ensureChapterText(id);
          });
          const hasSpanData = state.chapters.some(
            (chapter) => (chapter.chunk_spans || []).length > 0
          );
          state.needsRechunk = state.chapters.length > 0 && !hasSpanData;
          renderBooks();
          renderBookHeader();
          await loadVoiceMap();
          await loadVoices();
          updateDeleteButtonState();
          updateRegenButtonState();
          renderChapters();
          if (state.chapters.length) {
            const desired = desiredChapter || state.chapters[0].id;
            renderChapter(desired);
            const offset = state.chapterOffsets[desired];
            let anchorIndex =
              typeof offset === "number" ? offset : state.currentQueueIndex;
            const lastIndex = getLastPlayed();
            if (lastIndex !== null) {
              const lastItem = state.queue[lastIndex];
              if (lastItem && lastItem.chapterId === desired) {
                anchorIndex = lastIndex;
              }
            }
            state.currentQueueIndex = anchorIndex;
            setIdleStatus();
            if (state.needsRechunk) {
              setStatus("Manifest missing chunk spans. Delete TTS cache and start TTS.");
            }
          } else {
            chapterTitle.textContent = "No audio yet";
            chapterText.innerHTML =
              "<p class=\"empty-state\">Run `ptts synth` to generate audio chunks.</p>";
            setStatus("No audio available.");
          }
          updateUrl(state.book.id, state.currentChapterId);
          startSynthPolling();
          if (state.editOpen) {
            await loadPreview(state.previewChapterIndex);
            await loadReadingOverrides(true);
          }
          scrollToBookSection();
        } catch (err) {
          setStatus("Failed to load book.");
        } finally {
          state.loadingBook = false;
        }
      }

      function renderBookHeader() {
        if (!state.book) {
          return;
        }
        bookTitle.textContent = state.book.title || state.book.id;
        const author = (state.book.authors || []).join(", ");
        const year = state.book.year ? ` (${state.book.year})` : "";
        bookMeta.textContent = `${author}${year}`;
        bookStatus.textContent = state.book.has_audio
          ? "Audio manifest loaded."
          : "Waiting for audio.";
        coverLarge.style.removeProperty("--cover-image-bg");
        coverLarge.innerHTML = renderCover(state.book, "large");
        const coverImg = coverLarge.querySelector("img");
        if (coverImg) {
          if (coverImg.complete) {
            setCoverBackgroundFromImage(coverLarge, coverImg);
          } else {
            coverImg.addEventListener(
              "load",
              () => setCoverBackgroundFromImage(coverLarge, coverImg),
              { once: true }
            );
          }
        }
      }

      function snippet(text, length) {
        if (!text) {
          return "";
        }
        const cleaned = text.replace(/\s+/g, " ").trim();
        return cleaned.slice(0, length);
      }

      function getChapterById(chapterId) {
        return state.chapterMap[chapterId] || null;
      }

      function chapterIdForQueueIndex(index) {
        const item = state.queue[index];
        return item ? item.chapterId : null;
      }

      async function ensureChapterText(chapterId) {
        if (!state.book) {
          return "";
        }
        const chapter = getChapterById(chapterId);
        if (!chapter) {
          return "";
        }
        if (chapter.clean_text) {
          return chapter.clean_text;
        }
        if (!state.chapterTextRequests[chapterId]) {
          const url = `/api/books/${encodeURIComponent(
            state.book.id
          )}/chapter-text?chapter_id=${encodeURIComponent(chapterId)}`;
          state.chapterTextRequests[chapterId] = fetchJson(url)
            .then((data) => {
              chapter.clean_text = data.clean_text || "";
              return chapter.clean_text;
            })
            .catch((err) => {
              console.warn("Failed to load chapter text.", err);
              return "";
            })
            .finally(() => {
              delete state.chapterTextRequests[chapterId];
            });
        }
        return state.chapterTextRequests[chapterId];
      }

      function getChapterChunkTotal(item) {
        const chapter = getChapterById(item.chapterId);
        if (!chapter) {
          return 0;
        }
        const count = chapter.chunk_count;
        if (Number.isInteger(count) && count > 0) {
          return count;
        }
        const spans = chapter.chunk_spans || [];
        return Array.isArray(spans) ? spans.length : 0;
      }

      function getChunkSpan(item) {
        const chapter = getChapterById(item.chapterId);
        if (!chapter) {
          return null;
        }
        const spans = chapter.chunk_spans || [];
        return spans[item.chunkIndex] || null;
      }

      function getChunkText(item) {
        const chapter = getChapterById(item.chapterId);
        if (!chapter) {
          return "";
        }
        const span = getChunkSpan(item);
        if (!span || !chapter.clean_text) {
          return "";
        }
        return chapter.clean_text.slice(span[0], span[1]);
      }

      function splitParagraphSpans(text) {
        const spans = [];
        const re = /\n(?:[ \t]*\n)+/g;
        const classifyBreak = (delimiter) => {
          const newlineCount = (delimiter.match(/\n/g) || []).length;
          if (newlineCount >= 5) {
            return "title";
          }
          if (newlineCount >= 3) {
            return "section";
          }
          return "paragraph";
        };
        let start = 0;
        let match;
        while ((match = re.exec(text)) !== null) {
          const end = match.index;
          let paraStart = start;
          let paraEnd = end;
          while (paraStart < paraEnd && /\s/.test(text[paraStart])) {
            paraStart += 1;
          }
          while (paraEnd > paraStart && /\s/.test(text[paraEnd - 1])) {
            paraEnd -= 1;
          }
          if (paraStart < paraEnd) {
            spans.push({
              start: paraStart,
              end: paraEnd,
              breakAfter: classifyBreak(match[0]),
            });
          }
          start = match.index + match[0].length;
        }
        let tailStart = start;
        let tailEnd = text.length;
        while (tailStart < tailEnd && /\s/.test(text[tailStart])) {
          tailStart += 1;
        }
        while (tailEnd > tailStart && /\s/.test(text[tailEnd - 1])) {
          tailEnd -= 1;
        }
        if (tailStart < tailEnd) {
          spans.push({ start: tailStart, end: tailEnd, breakAfter: null });
        }
        return spans;
      }

      function describeIndex(index) {
        const item = state.queue[index];
        if (!item) {
          return "â€”";
        }
        const text = getChunkText(item);
        if (!text) {
          return "\"selected chunk\"";
        }
        const cleaned = text.replace(/\s+/g, " ").trim();
        return cleaned ? `"${cleaned}"` : "\"selected chunk\"";
      }

      function describeStatusIndex(index) {
        const item = state.queue[index];
        if (!item) {
          return "â€”";
        }
        const chapterTotal = getChapterChunkTotal(item);
        const chunkLabel =
          chapterTotal > 0
            ? `${item.chunkIndex + 1} / ${chapterTotal}`
            : `${item.chunkIndex + 1}`;
        const chapterId = item.chapterId || "";
        return chapterId ? `${chapterId} ${chunkLabel}` : chunkLabel;
      }

      function idleStatusText() {
        const lastIndex = getLastPlayed();
        const furthestIndex = getFurthestPlayed();
        const lastLabel =
          lastIndex === null ? "â€”" : describeStatusIndex(lastIndex);
        const furthestLabel =
          furthestIndex === null ? "â€”" : describeStatusIndex(furthestIndex);
        return `Last: ${lastLabel} Â· Furthest: ${furthestLabel}`;
      }

      function setIdleStatus() {
        setStatus(idleStatusText(), "idle");
      }

      function applyLastPlayedHighlight() {
        const prev = chapterText.querySelector(".chunk.last-played");
        if (prev) {
          prev.classList.remove("last-played");
        }
        const lastIndex = getLastPlayed();
        if (lastIndex === null) {
          return;
        }
        const item = state.queue[lastIndex];
        if (!item || item.chapterId !== state.currentChapterId) {
          return;
        }
        const span = chapterText.querySelector(
          `.chunk[data-queue-index="${lastIndex}"]`
        );
        if (span) {
          span.classList.add("last-played");
        }
      }

      function updateMarks() {
        if (!state.book) {
          bookmarkList.innerHTML = "<div class=\"bookmark-empty\">No bookmarks yet.</div>";
          saveBookmarkBtn.disabled = true;
          return;
        }
        const bookmarks = getBookmarks();
        bookmarkList.innerHTML = "";
        const furthestIndex = getFurthestPlayed();
        if (furthestIndex !== null) {
          const item = document.createElement("div");
          item.className = "bookmark-item";
          const label = describeIndex(furthestIndex);
          item.innerHTML = `
            <span>Furthest: ${label}</span>
            <div class="bookmark-actions">
              <button class="btn small" data-action="play-furthest" data-index="${furthestIndex}">Play</button>
            </div>
          `;
          bookmarkList.appendChild(item);
        }
        if (!bookmarks.length) {
          if (furthestIndex === null) {
            bookmarkList.innerHTML = "<div class=\"bookmark-empty\">No bookmarks yet.</div>";
          }
        } else {
          bookmarks.forEach((entry) => {
            const item = document.createElement("div");
            item.className = "bookmark-item";
            const label = describeIndex(entry.index);
            item.innerHTML = `
              <span>${label}</span>
              <div class="bookmark-actions">
                <button class="btn small" data-action="play" data-index="${entry.index}">Play</button>
                <button class="btn small" data-action="remove" data-index="${entry.index}">Remove</button>
              </div>
            `;
            bookmarkList.appendChild(item);
          });
        }
        saveBookmarkBtn.disabled = !state.queue.length;
        if (state.statusMode === "idle") {
          setIdleStatus();
        }
      }

      function jumpToIndex(index, autoplay) {
        if (index === null || index < 0 || index >= state.queue.length) {
          return;
        }
        state.currentQueueIndex = index;
        setActiveChunk(index, false);
        if (autoplay) {
          playIndex(index);
        } else {
          const item = state.queue[index];
          if (item && state.currentChapterId !== item.chapterId) {
            renderChapter(item.chapterId);
          }
        }
        updateMarks();
      }

      function positionBookmarkPanel() {
        if (!bookmarkPanel.classList.contains("open")) {
          return;
        }
        const playerBar = document.querySelector(".player-bar");
        if (!playerBar) {
          return;
        }
        const barRect = playerBar.getBoundingClientRect();
        const panelRect = bookmarkPanel.getBoundingClientRect();
        const viewportWidth = window.innerWidth || document.documentElement.clientWidth;
        const margin = 16;
        const anchorRect = bookmarkBtn.getBoundingClientRect();
        const anchorCenter = anchorRect.left + anchorRect.width / 2;
        const idealLeft = anchorCenter - panelRect.width / 2;
        const maxLeft = viewportWidth - panelRect.width - margin;
        const left = Math.max(margin, Math.min(idealLeft, maxLeft));
        const top = Math.max(margin, barRect.top - panelRect.height - 12);
        bookmarkPanel.style.left = `${left}px`;
        bookmarkPanel.style.top = `${top}px`;
        bookmarkPanel.style.bottom = "auto";
        bookmarkPanel.style.transform = "none";
      }

      function positionBookMenuPanel() {
        if (!bookMenuPanel.classList.contains("open")) {
          return;
        }
        const panelRect = bookMenuPanel.getBoundingClientRect();
        const anchorRect = bookMenuBtn.getBoundingClientRect();
        const viewportWidth = window.innerWidth || document.documentElement.clientWidth;
        const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
        const margin = 16;
        const anchorCenter = anchorRect.left + anchorRect.width / 2;
        const idealLeft = anchorCenter - panelRect.width / 2;
        const maxLeft = viewportWidth - panelRect.width - margin;
        const left = Math.max(margin, Math.min(idealLeft, maxLeft));
        let top = anchorRect.bottom + 8;
        if (top + panelRect.height + margin > viewportHeight) {
          const above = anchorRect.top - panelRect.height - 8;
          if (above >= margin) {
            top = above;
          } else {
            top = Math.max(margin, viewportHeight - panelRect.height - margin);
          }
        }
        bookMenuPanel.style.left = `${left}px`;
        bookMenuPanel.style.top = `${top}px`;
        bookMenuPanel.style.right = "auto";
        bookMenuPanel.style.bottom = "auto";
        bookMenuPanel.style.transform = "none";
      }

      function positionDownloadMenuPanel() {
        if (!downloadMenuPanel || !downloadMenuPanel.classList.contains("open")) {
          return;
        }
        const panelRect = downloadMenuPanel.getBoundingClientRect();
        const anchorRect = downloadM4bBtn.getBoundingClientRect();
        const viewportWidth = window.innerWidth || document.documentElement.clientWidth;
        const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
        const margin = 16;
        const anchorCenter = anchorRect.left + anchorRect.width / 2;
        const idealLeft = anchorCenter - panelRect.width / 2;
        const maxLeft = viewportWidth - panelRect.width - margin;
        const left = Math.max(margin, Math.min(idealLeft, maxLeft));
        let top = anchorRect.bottom + 8;
        if (top + panelRect.height + margin > viewportHeight) {
          const above = anchorRect.top - panelRect.height - 8;
          if (above >= margin) {
            top = above;
          } else {
            top = Math.max(margin, viewportHeight - panelRect.height - margin);
          }
        }
        downloadMenuPanel.style.left = `${left}px`;
        downloadMenuPanel.style.top = `${top}px`;
        downloadMenuPanel.style.right = "auto";
        downloadMenuPanel.style.bottom = "auto";
        downloadMenuPanel.style.transform = "none";
      }

      function openBookmarkPanel() {
        bookmarkPanel.classList.add("open");
        requestAnimationFrame(positionBookmarkPanel);
        window.addEventListener("resize", positionBookmarkPanel);
      }

      function closeBookmarkPanel() {
        bookmarkPanel.classList.remove("open");
        window.removeEventListener("resize", positionBookmarkPanel);
      }

      function chunkCacheKey(item) {
        return `${item.chapterId}:${item.chunkIndex}`;
      }

      function updateRegenButtonState() {
        if (!regenChunkBtn) {
          return;
        }
        const hasSelection = state.selectedQueueIndex !== null;
        const disabled =
          !state.book ||
          !state.queue.length ||
          !hasSelection ||
          state.synthRunning ||
          state.mergeRunning ||
          state.chunkRegenRunning;
        regenChunkBtn.disabled = disabled;
        if (state.chunkRegenRunning) {
          regenChunkBtn.title = "Regenerating chunk...";
        } else if (!state.book) {
          regenChunkBtn.title = "Load a book to regenerate chunks.";
        } else if (!state.queue.length) {
          regenChunkBtn.title = "No chunks available.";
        } else if (!hasSelection) {
          regenChunkBtn.title = "Select a chunk to regenerate.";
        } else if (state.synthRunning || state.mergeRunning) {
          regenChunkBtn.title = "Stop TTS/merge before regenerating.";
        } else {
          const label = describeIndex(state.selectedQueueIndex);
          regenChunkBtn.title = `Regenerate ${label}`;
        }
      }

      async function regenerateChunk() {
        if (!state.book || state.chunkRegenRunning) {
          return;
        }
        if (state.synthRunning || state.mergeRunning) {
          setStatus("Stop TTS/merge before regenerating.");
          return;
        }
        currentAudio.pause();
        nextAudio.pause();
        clearGapless();
        clearPreload();
        setPlayButton(false);
        if (state.selectedQueueIndex === null) {
          setStatus("Select a chunk to regenerate.");
          return;
        }
        const item = state.queue[state.selectedQueueIndex];
        if (!item) {
          setStatus("Chunk not found.");
          return;
        }
        const label = describeIndex(state.selectedQueueIndex);
        const ok = confirm(`Regenerate audio for ${label}?`);
        if (!ok) {
          return;
        }
        state.chunkRegenRunning = true;
        updateRegenButtonState();
        setStatus(`Regenerating ${label}...`);
        try {
          await fetchJson("/api/synth/chunk", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              book_id: state.book.id,
              chapter_id: item.chapterId,
              chunk_index: item.chunkIndex,
            }),
          });
          state.chunkCacheBust[chunkCacheKey(item)] = Date.now();
          clearPreload();
          if (state.currentQueueIndex === state.selectedQueueIndex) {
            currentAudio.pause();
            currentAudio.src = chunkUrl(item);
            currentAudio.load();
            setPlayButton(false);
          }
          setStatus(`Regenerated ${label}.`);
        } catch (err) {
          setStatus(err.message || "Failed to regenerate chunk.");
        } finally {
          state.chunkRegenRunning = false;
          updateRegenButtonState();
        }
      }

      function openBookMenu() {
        if (bookMenuPanel.classList.contains("open")) {
          return;
        }
        bookMenuPanel.classList.add("open");
        bookMenuBtn.setAttribute("aria-expanded", "true");
        requestAnimationFrame(positionBookMenuPanel);
        window.addEventListener("resize", positionBookMenuPanel);
        window.addEventListener("scroll", positionBookMenuPanel, { passive: true });
      }

      function openDownloadMenu() {
        if (!downloadMenuPanel || downloadMenuPanel.classList.contains("open")) {
          return;
        }
        downloadMenuPanel.classList.add("open");
        downloadM4bBtn.setAttribute("aria-expanded", "true");
        requestAnimationFrame(positionDownloadMenuPanel);
        window.addEventListener("resize", positionDownloadMenuPanel);
        window.addEventListener("scroll", positionDownloadMenuPanel, { passive: true });
      }

      function addBookmark(index) {
        if (index === null || index < 0 || index >= state.queue.length) {
          return;
        }
        const bookmarks = getBookmarks();
        if (bookmarks.some((entry) => entry.index === index)) {
          return;
        }
        bookmarks.push({
          index,
          label: describeIndex(index),
          created_at: Date.now(),
        });
        saveBookmarks(bookmarks);
      }

      function removeBookmark(index) {
        const bookmarks = getBookmarks();
        const next = bookmarks.filter((entry) => entry.index !== index);
        saveBookmarks(next);
      }

      function startSynthPolling() {
        if (state.synthTimer) {
          clearInterval(state.synthTimer);
        }
        state.synthTimer = setInterval(loadSynthStatus, 2000);
        loadSynthStatus();
      }

      async function loadSynthStatus() {
        if (!state.book) {
          return;
        }
        try {
          const data = await fetchJson(
            `/api/synth/status?book_id=${encodeURIComponent(state.book.id)}`
          );
          updateSynthUI(data);
          await loadMergeStatus();
          if (
            !state.loadingBook &&
            data.progress &&
            data.progress.total > 0 &&
            (state.pendingManifestRefresh || !state.chapters.length)
          ) {
            await selectBook(state.book.id);
            state.pendingManifestRefresh = false;
          }
        } catch (err) {
          progressText.textContent = "Unable to load TTS status.";
        }
      }

      function updateSynthUI(data) {
        state.synthRunning = !!data.running;
        state.synthMode = data.mode || "tts";
        const sampling = state.synthMode === "sample";
        const progress = data.progress;
        const doneChunks =
          progress && typeof progress.done === "number" ? progress.done : 0;
        const totalChunks =
          progress && typeof progress.total === "number" ? progress.total : 0;
        const complete =
          !sampling &&
          totalChunks > 0 &&
          doneChunks >= totalChunks;
        startTts.classList.remove("success");
        if (state.synthRunning && sampling) {
          startTts.textContent = "Start TTS";
          startTts.disabled = true;
          sampleTts.textContent = "Stop Sample";
        } else if (complete && !state.synthRunning) {
          startTts.textContent = "TTS Complete";
          startTts.disabled = true;
          startTts.classList.add("success");
          sampleTts.textContent = "Sample";
        } else {
          startTts.textContent = state.synthRunning ? "Stop TTS" : "Start TTS";
          startTts.disabled = false;
          sampleTts.textContent = "Sample";
        }
        const overall = data.overall_progress || null;
        state.mergePartial =
          !sampling && doneChunks > 0 && totalChunks > 0 && doneChunks < totalChunks;
        state.mergeReady = !sampling && doneChunks > 0 && totalChunks > 0;
        updateMergeButtonState();
        const stage = data.stage || "idle";
        if (stage === "chunking") {
          progressFill.style.width =
            sampling && overall
              ? `${overall.percent}%`
              : "0%";
          progressText.textContent = sampling
            ? "Chunking sample..."
            : "Chunking text...";
          progressDetail.textContent = "Preparing manifest and spans.";
        } else if (stage === "cloning") {
          progressFill.style.width =
            sampling && overall
              ? `${overall.percent}%`
              : "0%";
          progressText.textContent = sampling
            ? "Cloning voice for sample..."
            : "Cloning voice...";
          progressDetail.textContent = "Preparing voice prompt.";
        } else if (stage === "sampled") {
          progressFill.style.width =
            sampling && overall
              ? `${overall.percent}%`
              : "100%";
          progressText.textContent = "Sample ready.";
          if (progress && progress.current) {
            progressDetail.textContent = `${progress.current.chapter_title} Â· sample done.`;
          } else {
            progressDetail.textContent = "";
          }
        } else if (!progress) {
          progressFill.style.width = "0%";
          progressText.textContent = "Idle.";
          progressDetail.textContent = "";
        } else {
          const barPercent =
            sampling && overall
              ? overall.percent
              : progress.percent;
          progressFill.style.width = `${barPercent}%`;
          const prefix = sampling ? "Sample" : "Progress";
          progressText.textContent = `${prefix}: ${progress.done} / ${progress.total} chunks (${progress.percent}%).`;
          if (progress.current) {
            progressDetail.textContent = `${progress.current.chapter_title} Â· chunk ${progress.current.chunk_index} of ${progress.current.chunk_total}`;
          } else {
            progressDetail.textContent = progress.total ? "Completed." : "Idle.";
          }
        }

        if (sampling) {
          if (stage === "chunking") {
            bookStatus.textContent = "Preparing sample...";
          } else if (stage === "cloning") {
            bookStatus.textContent = "Cloning sample voice...";
          } else if (stage === "sampling") {
            bookStatus.textContent = "Generating sample...";
          } else if (stage === "sampled") {
            bookStatus.textContent = "Sample ready.";
          } else {
            bookStatus.textContent = state.book && state.book.has_audio ? "Audio ready." : "Waiting for audio.";
          }
        } else if (stage === "chunking") {
          bookStatus.textContent = "Chunking text...";
        } else if (stage === "synthesizing") {
          bookStatus.textContent = "Synthesizing audio...";
        } else if (stage === "done") {
          bookStatus.textContent = "Audio ready.";
        } else {
          bookStatus.textContent = state.book && state.book.has_audio ? "Audio ready." : "Waiting for audio.";
        }
        startTts.disabled =
          startTts.disabled || (state.synthRunning && sampling);
        const ffmpegState = data.ffmpeg_status || "unknown";
        if (ffmpegState === "installing") {
          ffmpegStatus.textContent = "Installing ffmpeg...";
        } else if (ffmpegState === "error") {
          ffmpegStatus.textContent =
            data.ffmpeg_error || "ffmpeg install failed.";
        } else if (ffmpegState === "missing") {
          ffmpegStatus.textContent =
            data.ffmpeg_error || "ffmpeg missing: merge will fail.";
        } else {
          ffmpegStatus.textContent = "";
        }
        updateClearButtonState();
      }

      async function loadMergeStatus() {
        if (!state.book) {
          return;
        }
        try {
          const data = await fetchJson(
            `/api/merge/status?book_id=${encodeURIComponent(state.book.id)}`
          );
          updateMergeUI(data);
        } catch (err) {
          mergeStatus.textContent = err.message || "Unable to load merge status.";
        }
      }

      function updateMergeButtonState() {
        const hasM4b = state.mergeOutputExists;
        mergeBtn.hidden = hasM4b && !state.mergeRunning;
        if (downloadM4bBtn) {
          downloadM4bBtn.hidden = !hasM4b || state.mergeRunning;
        }
        if (state.mergeRunning && state.mergeStage === "installing") {
          mergeBtn.textContent = "Installing ffmpeg...";
          mergeBtn.disabled = true;
          mergeBtn.title = "Installing ffmpeg...";
        } else if (state.mergeRunning) {
          mergeBtn.textContent = "Merging...";
          mergeBtn.disabled = true;
          mergeBtn.title = "Merging...";
        } else {
          mergeBtn.textContent = "Merge M4B";
          mergeBtn.disabled = !state.mergeReady || state.mergeOutputExists;
          if (state.mergeOutputExists) {
            mergeBtn.title = "Delete the merged M4B from the book menu to re-merge.";
          } else if (!state.mergeReady) {
            mergeBtn.title = "Generate at least one chunk to enable merge.";
          } else {
            mergeBtn.title = "Merge M4B";
          }
        }
        updateDownloadButtonState();
      }

      function updateDownloadButtonState() {
        if (!downloadM4bBtn) {
          return;
        }
        const available = state.mergeOutputExists && !state.mergeRunning;
        if (!available) {
          closeDownloadMenu();
        }
        renderDownloadMenu();
        downloadM4bBtn.hidden = !available;
        downloadM4bBtn.disabled = !available;
        if (!available) {
          downloadM4bBtn.title = "No merged M4B available.";
        } else {
          if ((state.mergeOutputParts || []).length > 1) {
            downloadM4bBtn.title = "Choose an M4B part to download.";
          } else {
            downloadM4bBtn.title = "Download M4B";
          }
        }
      }

      function renderDownloadMenu() {
        if (!downloadMenuPanel) {
          return;
        }
        const parts = state.mergeOutputParts || [];
        downloadMenuPanel.innerHTML = "";
        if (parts.length <= 1) {
          closeDownloadMenu();
          return;
        }
        parts.forEach((name, idx) => {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "btn";
          btn.textContent = `Download Part ${idx + 1}`;
          btn.addEventListener("click", () => {
            closeDownloadMenu();
            downloadM4bPart(idx + 1, name);
          });
          downloadMenuPanel.appendChild(btn);
        });
      }

      function updateSampleButtonState() {
        const disabled =
          !state.book ||
          state.mergeRunning ||
          state.advancedMode ||
          (state.synthRunning && state.synthMode !== "sample");
        sampleTts.disabled = disabled;
        sampleTts.title = state.advancedMode
          ? "Sample disabled in Advanced Mode."
          : "Sample";
      }

      function updateClearButtonState() {
        clearTtsBtn.disabled = state.synthRunning || state.mergeRunning;
        updateDeleteButtonState();
        updateSampleButtonState();
        updateAdvancedControls();
        updateRegenButtonState();
      }

      function updateDeleteButtonState() {
        const disabled = !state.book || state.synthRunning || state.mergeRunning;
        deleteBookBtn.disabled = disabled;
        editMetaBtn.disabled = disabled;
        const hasM4b = state.mergeOutputExists;
        deleteM4bBtn.hidden = !hasM4b;
        deleteM4bBtn.disabled = disabled || !hasM4b;
        bookMenuBtn.disabled = disabled;
        let m4bTitle = "Delete merged M4B.";
        if (!hasM4b) {
          m4bTitle = "No merged M4B available.";
        }
        if (state.mergeRunning) {
          m4bTitle = "Stop merge before deleting.";
        } else if (state.synthRunning) {
          m4bTitle = "Stop TTS before deleting.";
        }
        deleteM4bBtn.title = m4bTitle;
        if (disabled) {
          bookMenuPanel.classList.remove("open");
          bookMenuBtn.setAttribute("aria-expanded", "false");
        }
      }

      function setCloneStatus(message, tone = "") {
        if (!cloneStatus) {
          return;
        }
        cloneStatus.textContent = message || "";
        if (tone) {
          cloneStatus.dataset.tone = tone;
        } else {
          delete cloneStatus.dataset.tone;
        }
      }

      function resetClonePreview() {
        if (!clonePreviewAudio || !clonePreviewWrap) {
          return;
        }
        clonePreviewAudio.pause();
        clonePreviewAudio.removeAttribute("src");
        clonePreviewAudio.load();
        clonePreviewWrap.hidden = true;
      }

      function setCloneBusy(busy) {
        state.cloneModalBusy = busy;
        if (cloneSource) {
          cloneSource.disabled = busy;
        }
        if (cloneStart) {
          cloneStart.disabled = busy;
        }
        if (cloneDuration) {
          cloneDuration.disabled = busy;
        }
        if (cloneName) {
          cloneName.disabled = busy;
        }
        if (cloneBuiltinToggle) {
          cloneBuiltinToggle.disabled = busy;
        }
        setCloneGenderDisabled(busy);
        if (clonePreviewBtn) {
          clonePreviewBtn.disabled = busy;
        }
        if (cloneDelete) {
          cloneDelete.disabled = busy;
        }
        if (cloneSave) {
          cloneSave.disabled = busy;
        }
      }

      function setCloneMode(mode, editVoiceValue = null) {
        const editing = mode === "edit";
        state.cloneMode = editing ? "edit" : "add";
        state.cloneEditVoice = editing ? editVoiceValue : null;
        if (cloneTitleLabel) {
          cloneTitleLabel.textContent = editing
            ? "Edit local voice metadata"
            : "Clone local voice";
        }
        if (cloneAudioFields) {
          cloneAudioFields.hidden = editing;
        }
        if (clonePreviewBtn) {
          clonePreviewBtn.hidden = editing;
        }
        if (cloneDelete) {
          cloneDelete.hidden = !editing;
        }
        if (cloneSave) {
          cloneSave.textContent = editing ? "Save metadata" : "Save voice";
        }
        if (cloneEditNote) {
          cloneEditNote.hidden = !editing;
        }
        if (cloneBuiltinWrap) {
          cloneBuiltinWrap.hidden = editing;
        }
        if (cloneEditVoiceLabel) {
          cloneEditVoiceLabel.textContent = editing
            ? voiceLabelFromValue(editVoiceValue || "")
            : "";
        }
        updateCloneBuiltinToggleLabel();
        if (editing) {
          resetClonePreview();
        }
      }

      function openCloneModal(mode = "add", editVoiceValue = null) {
        if (!cloneModal) {
          return;
        }
        const selectedForEdit =
          mode === "edit" ? editVoiceValue || selectedLocalVoice() : null;
        if (mode === "edit" && !selectedForEdit) {
          mode = "add";
        }
        setCloneMode(mode, selectedForEdit);
        if (cloneSource) {
          cloneSource.value = "";
        }
        if (cloneStart) {
          cloneStart.value = "";
        }
        if (cloneDuration) {
          cloneDuration.value = "";
        }
        if (cloneName) {
          if (mode === "edit" && selectedForEdit) {
            cloneName.value = voiceStemFromValue(selectedForEdit);
          } else {
            cloneName.value = "";
          }
        }
        if (mode === "edit" && selectedForEdit) {
          setCloneGenderValue(state.voiceGenderMap[selectedForEdit] || "");
        } else {
          setCloneGenderValue("");
        }
        state.cloneNameDirty = false;
        updateCloneBuiltinToggleLabel();
        setCloneStatus("");
        setCloneBusy(false);
        cloneModal.hidden = false;
        if (mode === "edit") {
          if (cloneName) {
            cloneName.focus();
            cloneName.select();
          } else {
            focusCloneGender();
          }
        } else if (cloneSource) {
          cloneSource.focus();
          cloneSource.select();
        }
      }

      function closeCloneModal() {
        if (!cloneModal) {
          return;
        }
        cloneModal.hidden = true;
        setCloneStatus("");
        setCloneBusy(false);
        resetClonePreview();
      }

      function clonePayload() {
        if (state.cloneMode === "edit") {
          return null;
        }
        const source = cloneSource ? cloneSource.value.trim() : "";
        const start = cloneStart ? cloneStart.value.trim() : "";
        const duration = cloneDuration ? cloneDuration.value.trim() : "";
        const name = cloneName ? cloneName.value.trim() : "";
        const gender = getCloneGenderValue();
        if (!source) {
          setCloneStatus("Source is required.", "error");
          if (cloneSource) {
            cloneSource.focus();
          }
          return null;
        }
        if (!/^https?:\/\//i.test(source) && !source.startsWith("/") && !source.startsWith("~/")) {
          setCloneStatus("Local source must be an absolute path.", "error");
          if (cloneSource) {
            cloneSource.focus();
          }
          return null;
        }
        if (!gender) {
          setCloneStatus("Select Male or Female.", "error");
          focusCloneGender();
          return null;
        }
        const payload = {
          source,
          start: start || "0",
          duration: duration || "12",
          gender,
        };
        if (name) {
          payload.name = name;
        }
        return payload;
      }

      async function previewCloneVoice() {
        if (state.cloneMode === "edit") {
          return;
        }
        const payload = clonePayload();
        if (!payload) {
          return;
        }
        setCloneBusy(true);
        setCloneStatus("Generating preview...");
        try {
          const data = await fetchJson("/api/voices/clone/preview", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          if (cloneName && (!cloneName.value.trim() || !state.cloneNameDirty)) {
            if (data.suggested_name) {
              cloneName.value = data.suggested_name;
              state.cloneNameDirty = false;
            }
          }
          if (clonePreviewAudio && clonePreviewWrap && data.preview_url) {
            clonePreviewAudio.src = data.preview_url;
            clonePreviewWrap.hidden = false;
            try {
              await clonePreviewAudio.play();
            } catch (err) {
              // autoplay may be blocked by browser policy
            }
          }
          setCloneStatus("Preview ready.");
        } catch (err) {
          setCloneStatus(err.message || "Preview failed.", "error");
        } finally {
          setCloneBusy(false);
        }
      }

      async function saveVoiceMetadata() {
        const voiceValue = state.cloneEditVoice || selectedLocalVoice();
        if (!voiceValue) {
          setCloneStatus("Select a local voice to edit.", "error");
          return;
        }
        const gender = getCloneGenderValue();
        const voiceName = cloneName ? cloneName.value.trim() : "";
        if (!gender) {
          setCloneStatus("Select Male or Female.", "error");
          focusCloneGender();
          return;
        }
        if (!voiceName) {
          setCloneStatus("Voice name is required.", "error");
          if (cloneName) {
            cloneName.focus();
          }
          return;
        }
        setCloneBusy(true);
        setCloneStatus("Saving metadata...");
        try {
          const data = await fetchJson("/api/voices/metadata", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              voice: voiceValue,
              gender,
              name: voiceName,
            }),
          });
          await loadVoices();
          const nextVoice =
            data && typeof data.voice === "string" ? data.voice : voiceValue;
          setSelectedVoice(nextVoice);
          setStatus("Voice metadata updated.");
          closeCloneModal();
        } catch (err) {
          setCloneStatus(err.message || "Save failed.", "error");
        } finally {
          setCloneBusy(false);
        }
      }

      async function deleteLocalVoice() {
        const voiceValue = state.cloneEditVoice || selectedLocalVoice();
        if (!voiceValue) {
          setCloneStatus("Select a local voice to delete.", "error");
          return;
        }
        const label = voiceLabelFromValue(voiceValue) || voiceValue;
        const confirmed = window.confirm(`Delete voice "${label}"?`);
        if (!confirmed) {
          return;
        }
        setCloneBusy(true);
        setCloneStatus("Deleting voice...");
        try {
          await fetchJson("/api/voices/delete", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ voice: voiceValue }),
          });
          await loadVoices();
          setStatus(`Deleted voice: ${label}.`);
          closeCloneModal();
        } catch (err) {
          setCloneStatus(err.message || "Delete failed.", "error");
        } finally {
          setCloneBusy(false);
        }
      }

      async function saveCloneVoice() {
        if (state.cloneMode === "edit") {
          await saveVoiceMetadata();
          return;
        }
        const basePayload = clonePayload();
        if (!basePayload) {
          return;
        }
        let overwrite = false;
        while (true) {
          setCloneBusy(true);
          setCloneStatus(overwrite ? "Overwriting voice..." : "Saving voice...");
          try {
            const payload = { ...basePayload, overwrite };
            const data = await fetchJson("/api/voices/clone/save", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
            });
            await loadVoices();
            if (data && data.voice && data.voice.value) {
              setSelectedVoice(data.voice.value);
              const label = voiceLabelFromValue(data.voice.value) || data.voice.label;
              setStatus(`Saved voice: ${label}.`);
            } else {
              setStatus("Saved cloned voice.");
            }
            closeCloneModal();
            return;
          } catch (err) {
            if (err && err.status === 409 && !overwrite) {
              setCloneBusy(false);
              const confirmed = window.confirm(
                `${err.message || "Voice already exists."} Overwrite it?`
              );
              if (confirmed) {
                overwrite = true;
                continue;
              }
            }
            setCloneStatus(err.message || "Save failed.", "error");
            return;
          } finally {
            setCloneBusy(false);
          }
        }
      }

      function setMetaStatus(message, tone = "") {
        if (!metaStatus) {
          return;
        }
        metaStatus.textContent = message || "";
        if (tone) {
          metaStatus.dataset.tone = tone;
        } else {
          delete metaStatus.dataset.tone;
        }
      }

      function openMetaModal() {
        if (!state.book || !metaModal) {
          return;
        }
        metaTitle.value = state.book.title || "";
        metaAuthors.value = (state.book.authors || []).join(", ");
        metaYear.value = state.book.year || "";
        setMetaStatus("");
        metaSave.disabled = false;
        metaModal.hidden = false;
        metaTitle.focus();
      }

      function closeMetaModal() {
        if (!metaModal) {
          return;
        }
        metaModal.hidden = true;
        setMetaStatus("");
      }

      function updateBookMetadata(metadata) {
        if (!state.book || !metadata) {
          return;
        }
        if (metadata.title !== undefined) {
          state.book.title = metadata.title || "";
        }
        if (metadata.authors !== undefined) {
          if (Array.isArray(metadata.authors)) {
            state.book.authors = metadata.authors;
          } else if (typeof metadata.authors === "string") {
            state.book.authors = metadata.authors
              .split(",")
              .map((item) => item.trim())
              .filter(Boolean);
          } else {
            state.book.authors = [];
          }
        }
        if (metadata.year !== undefined) {
          state.book.year = metadata.year || "";
        }
        const entry = state.books.find((book) => book.id === state.book.id);
        if (entry) {
          entry.title = state.book.title;
          entry.authors = state.book.authors || [];
          entry.year = state.book.year || "";
        }
      }

      async function saveMetadata() {
        if (!state.book) {
          return;
        }
        const payload = {
          book_id: state.book.id,
          title: metaTitle.value.trim(),
          authors: metaAuthors.value.trim(),
          year: metaYear.value.trim(),
        };
        setMetaStatus("Saving...");
        metaSave.disabled = true;
        try {
          const data = await fetchJson("/api/books/metadata", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          updateBookMetadata(data.metadata || {});
          renderBookHeader();
          renderBooks();
          setStatus("Metadata updated.");
          closeMetaModal();
        } catch (err) {
          const detail =
            err && typeof err.message === "string" ? err.message : "";
          setMetaStatus(detail || "Failed to update metadata.", "error");
        } finally {
          metaSave.disabled = false;
        }
      }

      function updateMergeUI(data) {
        state.mergeRunning = !!data.running;
        state.mergeExitCode =
          typeof data.exit_code === "number" ? data.exit_code : null;
        state.mergeOutputExists = !!data.output_exists;
        state.mergeOutputParts = Array.isArray(data.output_parts)
          ? data.output_parts
          : [];
        state.mergeStage = data.stage || (state.mergeRunning ? "merging" : "idle");
        updateMergeButtonState();
        const progress = data && data.progress ? data.progress : {};
        const percent =
          progress && typeof progress.percent === "number"
            ? progress.percent
            : null;
        const partIndex =
          progress && typeof progress.part_index === "number"
            ? progress.part_index
            : null;
        const partTotal =
          progress && typeof progress.part_total === "number"
            ? progress.part_total
            : null;
        if (state.mergeStage === "installing") {
          mergeStatus.textContent = "Installing ffmpeg...";
        } else if (state.mergeStage === "merging") {
          let label = "Merging book";
          if (partIndex && partTotal && partTotal > 1) {
            label = `Merging part ${partIndex}/${partTotal}`;
          }
          if (percent !== null) {
            mergeStatus.textContent = `${label}: ${percent.toFixed(1)}%`;
          } else {
            mergeStatus.textContent = `${label}...`;
          }
        } else if (state.mergeStage === "done") {
          if (state.mergeOutputParts.length > 1) {
            mergeStatus.textContent = `M4B parts ready (${state.mergeOutputParts.length}).`;
          } else {
            mergeStatus.textContent = "M4B ready.";
          }
        } else if (state.mergeStage === "failed") {
          mergeStatus.textContent = "Merge failed. Check tts/merge.log.";
        } else {
          mergeStatus.textContent = "";
        }
        updateClearButtonState();
      }

      function toggleBookMenu() {
        if (bookMenuBtn.disabled) {
          return;
        }
        if (bookMenuPanel.classList.contains("open")) {
          closeBookMenu();
        } else {
          openBookMenu();
        }
      }

      function closeBookMenu() {
        if (!bookMenuPanel.classList.contains("open")) {
          return;
        }
        bookMenuPanel.classList.remove("open");
        bookMenuBtn.setAttribute("aria-expanded", "false");
        window.removeEventListener("resize", positionBookMenuPanel);
        window.removeEventListener("scroll", positionBookMenuPanel);
      }

      function closeDownloadMenu() {
        if (!downloadMenuPanel || !downloadMenuPanel.classList.contains("open")) {
          return;
        }
        downloadMenuPanel.classList.remove("open");
        downloadM4bBtn.setAttribute("aria-expanded", "false");
        window.removeEventListener("resize", positionDownloadMenuPanel);
        window.removeEventListener("scroll", positionDownloadMenuPanel);
      }

      async function startSynth() {
        if (!state.book) {
          return;
        }
        saveSettings();
        if (state.advancedMode) {
          const saved = await saveVoiceMap();
          if (!saved) {
            setStatus("Failed to save voice map.");
            return;
          }
        }
        state.mergeExitCode = null;
        state.mergeOutputExists = false;
        state.mergeOutputParts = [];
        closeDownloadMenu();
        mergeStatus.textContent = "";
        updateMergeButtonState();
        const payload = {
          book_id: state.book.id,
          voice: getSelectedVoice(),
          use_voice_map: state.advancedMode,
        };
        state.pendingManifestRefresh = !state.chapters.length;
        try {
          await fetchJson("/api/synth/start", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          setStatus("TTS started.");
          await loadSynthStatus();
        } catch (err) {
          setStatus("Failed to start TTS.");
        }
      }

      async function startMerge() {
        if (!state.book) {
          return;
        }
        if (!state.mergeReady) {
          setStatus("Generate at least one chunk before merging.");
          return;
        }
        if (state.mergeOutputExists) {
          setStatus("M4B already exists.");
          return;
        }
        if (state.mergePartial) {
          const proceed = window.confirm(
            "TTS is incomplete. This merge will produce a partial M4B and stop at the first missing chunk. Continue?"
          );
          if (!proceed) {
            setStatus("Merge canceled.");
            return;
          }
        }
        mergeStatus.textContent = "Starting merge...";
        try {
          await fetchJson("/api/merge/start", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ book_id: state.book.id }),
          });
          setStatus("Merge started.");
          await loadMergeStatus();
        } catch (err) {
          mergeStatus.textContent = err.message || "Merge failed to start.";
          setStatus(err.message || "Merge failed to start.");
        }
      }

      function downloadM4bPart(index, filename) {
        if (!state.book) {
          return;
        }
        const baseUrl = `/api/m4b/download?book_id=${encodeURIComponent(
          state.book.id
        )}`;
        const link = document.createElement("a");
        link.href = `${baseUrl}&part=${index}`;
        link.download = filename || `${state.book.id}.m4b`;
        document.body.appendChild(link);
        link.click();
        link.remove();
        setStatus("Downloading M4B...");
      }

      function downloadM4b() {
        if (!state.book || !state.mergeOutputExists) {
          setStatus("No merged M4B available.");
          return;
        }
        const parts = state.mergeOutputParts || [];
        if (parts.length > 1) {
          if (downloadMenuPanel && downloadMenuPanel.classList.contains("open")) {
            closeDownloadMenu();
          } else {
            openDownloadMenu();
          }
          return;
        }
        if (parts.length === 1) {
          downloadM4bPart(1, parts[0]);
          return;
        }
        const baseUrl = `/api/m4b/download?book_id=${encodeURIComponent(
          state.book.id
        )}`;
        const link = document.createElement("a");
        link.href = baseUrl;
        link.download = `${state.book.id}.m4b`;
        document.body.appendChild(link);
        link.click();
        link.remove();
        setStatus("Downloading M4B...");
      }

      async function sampleSynth() {
        if (!state.book) {
          return;
        }
        if (state.advancedMode) {
          setStatus("Sample disabled in Advanced Mode.");
          return;
        }
        if (state.synthRunning) {
          setStatus("Stop TTS before sampling.");
          return;
        }
        saveSettings();
        try {
          await fetchJson("/api/synth/sample", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              book_id: state.book.id,
              voice: getSelectedVoice(),
            }),
          });
          setStatus("Generating sample...");
          await loadSynthStatus();
        } catch (err) {
          setStatus(err.message || "Sample failed.");
        }
      }

      function toggleSample() {
        if (state.synthRunning && state.synthMode === "sample") {
          stopSynth();
        } else {
          sampleSynth();
        }
      }

      async function deleteBook() {
        if (!state.book) {
          return;
        }
        if (state.synthRunning || state.mergeRunning) {
          setStatus("Stop TTS or merge before deleting.");
          return;
        }
        const label = state.book.title || state.book.id;
        const confirmed = window.confirm(
          `Delete "${label}" and all files in this book folder?`
        );
        if (!confirmed) {
          return;
        }
        closeBookMenu();
        setStatus("Deleting book...");
        try {
          await fetchJson("/api/books/delete", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ book_id: state.book.id }),
          });
          clearBookView();
          await loadBooks();
          setStatus("Book deleted.");
        } catch (err) {
          setStatus(err.message || "Failed to delete book.");
        }
      }

      async function deleteM4b() {
        if (!state.book) {
          return;
        }
        if (state.mergeRunning) {
          setStatus("Stop merge before deleting.");
          return;
        }
        if (!state.mergeOutputExists) {
          setStatus("No merged M4B to delete.");
          return;
        }
        const label = state.book.title || state.book.id;
        const confirmed = window.confirm(
          `Delete the merged M4B for \"${label}\"?`
        );
        if (!confirmed) {
          return;
        }
        closeBookMenu();
        setStatus("Deleting M4B...");
        try {
          await fetchJson("/api/m4b/delete", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ book_id: state.book.id }),
          });
          state.mergeOutputExists = false;
          state.mergeOutputParts = [];
          state.mergeExitCode = null;
          state.mergeStage = "idle";
          closeDownloadMenu();
          mergeStatus.textContent = "";
          updateMergeButtonState();
          updateClearButtonState();
          setStatus("M4B deleted.");
        } catch (err) {
          setStatus(err.message || "Failed to delete M4B.");
        }
      }

      async function clearTtsCache() {
        if (!state.book) {
          return;
        }
        if (state.synthRunning || state.mergeRunning) {
          setStatus("Stop TTS/merge before clearing cache.");
          return;
        }
        const ok = confirm("Delete all TTS segments for this book?");
        if (!ok) {
          return;
        }
        try {
          await fetchJson("/api/tts/clear", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ book_id: state.book.id }),
          });
          setStatus("TTS cache deleted.");
          state.mergeOutputExists = false;
          state.mergeOutputParts = [];
          state.mergeExitCode = null;
          state.mergeStage = "idle";
          closeDownloadMenu();
          mergeStatus.textContent = "";
          updateMergeButtonState();
          await selectBook(state.book.id);
          if (state.editOpen) {
            await loadPreview(state.previewChapterIndex);
          }
        } catch (err) {
          setStatus(err.message || "Failed to clear TTS cache.");
        }
      }

      async function stopSynth() {
        if (!state.book) {
          return;
        }
        try {
          await fetchJson("/api/synth/stop", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ book_id: state.book.id }),
          });
          setStatus("TTS stopped.");
          await loadSynthStatus();
        } catch (err) {
          setStatus("Failed to stop TTS.");
        }
      }

      function toggleSynth() {
        if (state.synthRunning) {
          stopSynth();
        } else {
          startSynth();
        }
      }

      function buildQueue() {
        state.queue = [];
        state.chapterOffsets = {};
        let offset = 0;
        state.chapters.forEach((chapter, chapterIndex) => {
          state.chapterOffsets[chapter.id] = offset;
          const spans = chapter.chunk_spans || [];
          spans.forEach((_span, chunkIndex) => {
            state.queue.push({
              chapterId: chapter.id,
              chapterIndex,
              chunkIndex,
            });
          });
          offset += spans.length;
        });
      }

      function renderChapters() {
        chapterList.innerHTML = "";
        if (!state.chapters.length) {
          chapterList.innerHTML = "<p class=\"empty-state\">No chapters yet.</p>";
          return;
        }
        state.chapters.forEach((chapter) => {
          const item = document.createElement("div");
          item.className = "toc-item";
          if (chapter.id === state.currentChapterId) {
            item.classList.add("active");
          }
          item.innerHTML = `
            <div>${chapter.title}</div>
            <small>${chapter.chunk_count} chunks</small>
          `;
          item.addEventListener("click", () => {
            renderChapter(chapter.id);
            state.currentQueueIndex = state.chapterOffsets[chapter.id] || 0;
            setIdleStatus();
            updateUrl(state.book ? state.book.id : null, chapter.id);
            scrollToTextPane();
          });
          chapterList.appendChild(item);
        });
      }

      async function renderChapter(chapterId) {
        const chapter = getChapterById(chapterId);
        if (!chapter) {
          return;
        }
        const renderToken = (state.chapterRenderToken += 1);
        state.currentChapterId = chapter.id;
        chapterTitle.textContent = chapter.title;
        chapterText.innerHTML = "";
        renderChapters();
        updateUrl(state.book ? state.book.id : null, chapter.id);

        let cleanText = chapter.clean_text || "";
        if (!cleanText) {
          chapterText.innerHTML = "<p class=\"empty-state\">Loading text...</p>";
          cleanText = await ensureChapterText(chapter.id);
        }
        if (
          renderToken !== state.chapterRenderToken ||
          state.currentChapterId !== chapter.id
        ) {
          return;
        }

        const spans = chapter.chunk_spans || [];
        const startIndex = state.chapterOffsets[chapter.id] || 0;
        const paragraphs = splitParagraphSpans(cleanText);
        let spanIndex = 0;

        if (!paragraphs.length) {
          chapterText.innerHTML = "<p class=\"empty-state\">No text available.</p>";
        } else {
          chapterText.innerHTML = "";
          paragraphs.forEach((paragraph) => {
            const paraStart = paragraph.start;
            const paraEnd = paragraph.end;
            const p = document.createElement("p");
            let cursor = paraStart;

            while (spanIndex < spans.length && spans[spanIndex][1] <= paraStart) {
              spanIndex += 1;
            }

            while (spanIndex < spans.length && spans[spanIndex][0] < paraEnd) {
              const spanEntry = spans[spanIndex];
              const spanStart = spanEntry[0];
              const spanEnd = spanEntry[1];
              if (spanStart > cursor) {
                p.appendChild(
                  document.createTextNode(cleanText.slice(cursor, spanStart))
                );
              }
              const span = document.createElement("span");
              span.className = "chunk";
              span.dataset.queueIndex = startIndex + spanIndex;
              span.textContent = cleanText.slice(spanStart, spanEnd);
              p.appendChild(span);
              cursor = spanEnd;
              spanIndex += 1;
            }

            if (cursor < paraEnd) {
              p.appendChild(
                document.createTextNode(cleanText.slice(cursor, paraEnd))
              );
            }
            chapterText.appendChild(p);
            if (
              paragraph.breakAfter === "section" ||
              paragraph.breakAfter === "title"
            ) {
              const rule = document.createElement("hr");
              rule.className =
                paragraph.breakAfter === "title"
                  ? "section-break title-break"
                  : "section-break";
              chapterText.appendChild(rule);
            }
          });
        }
        applyLastPlayedHighlight();
        if (state.activeQueueIndex !== null) {
          const activeItem = state.queue[state.activeQueueIndex];
          if (activeItem && activeItem.chapterId === chapter.id) {
            setActiveChunk(state.activeQueueIndex, false);
          }
        }
        updateMarks();
      }

      function setActiveChunk(index, waiting) {
        if (state.activeQueueIndex !== null) {
          const prev = chapterText.querySelector(
            `.chunk[data-queue-index="${state.activeQueueIndex}"]`
          );
          if (prev) {
            prev.classList.remove("active", "waiting");
            prev.classList.add("played");
          }
        }
        const item = state.queue[index];
        if (!item) {
          return;
        }
        if (state.currentChapterId !== item.chapterId) {
          renderChapter(item.chapterId);
        }
        const span = chapterText.querySelector(
          `.chunk[data-queue-index="${index}"]`
        );
        if (span) {
          span.classList.add(waiting ? "waiting" : "active");
          span.classList.remove(waiting ? "active" : "waiting");
          span.scrollIntoView({ block: "center", behavior: "smooth" });
        }
        state.activeQueueIndex = index;
        state.selectedQueueIndex = index;
        applyLastPlayedHighlight();
        updateRegenButtonState();
      }

      function hasUnsavedCleanChanges() {
        return (
          state.cleanEditing &&
          editCleanInput.value !== state.cleanEditOriginal
        );
      }

      function setCleanEditMode(enabled) {
        state.cleanEditing = enabled;
        editCleanInput.hidden = !enabled;
        editCleanActions.hidden = !enabled;
        editClean.hidden = enabled;
        editCleanBtn.disabled = enabled;
        editReload.disabled = enabled;
        dropChapterBtn.disabled =
          enabled ||
          !state.previewSelectedTitle ||
          state.previewSelectedKind === "title";
        if (enabled) {
          const text = editClean.textContent || "";
          editCleanInput.value = text;
          editCleanInput.scrollTop = 0;
          editCleanInput.setSelectionRange(0, 0);
          state.cleanEditOriginal = text;
          state.cleanEditChapter = state.previewChapterIndex;
          editStatus.textContent = "Editing clean text...";
          setTimeout(() => editCleanInput.focus(), 0);
        } else {
          editCleanInput.value = "";
          state.cleanEditOriginal = "";
          state.cleanEditChapter = null;
        }
      }

      function startCleanEdit() {
        if (!state.book || state.previewChapterIndex === null) {
          editStatus.textContent = "Select a chapter to edit.";
          return;
        }
        setCleanEditMode(true);
      }

      function cancelCleanEdit() {
        if (!state.cleanEditing) {
          return;
        }
        if (hasUnsavedCleanChanges()) {
          const discard = window.confirm("Discard unsaved clean text edits?");
          if (!discard) {
            return;
          }
        }
        setCleanEditMode(false);
        editStatus.textContent = "Edit canceled.";
      }

      async function saveCleanText() {
        if (!state.book || state.previewChapterIndex === null) {
          return;
        }
        const text = editCleanInput.value || "";
        editStatus.textContent = "Saving clean text...";
        try {
          const data = await fetchJson("/api/sanitize/clean", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              book_id: state.book.id,
              chapter_index: state.previewChapterIndex,
              text,
            }),
          });
          setCleanEditMode(false);
          editStatus.textContent = data.tts_cleared
            ? "Saved clean text. TTS cache cleared."
            : "Saved clean text.";
          await selectBook(state.book.id, state.currentChapterId);
          await loadPreview(state.previewChapterIndex);
        } catch (err) {
          editStatus.textContent = err.message || "Failed to save clean text.";
        }
      }

      function parseRuleLines(text) {
        return text
          .split("\n")
          .map((line) => line.trim())
          .filter((line) => line.length > 0);
      }

      function overridesToText(entries) {
        if (!Array.isArray(entries) || entries.length === 0) {
          return "";
        }
        return entries
          .map((entry) => {
            const rawBase = entry.pattern
              ? `re:${entry.pattern}`
              : (entry.base || "");
            return `${rawBase}=${entry.reading || ""}`.trim();
          })
          .filter((line) => line !== "=")
          .join("\n");
      }

      function parseOverrideLines(text) {
        const entries = [];
        const invalid = [];
        const separators = ["ï¼", "=", "\t"];
        (text || "")
          .split("\n")
          .map((line) => line.trim())
          .forEach((line) => {
            if (!line) {
              return;
            }
            let sepIndex = -1;
            let sepLen = 1;
            separators.forEach((sep) => {
              const idx = line.indexOf(sep);
              if (idx !== -1 && (sepIndex === -1 || idx < sepIndex)) {
                sepIndex = idx;
                sepLen = sep.length;
              }
            });
            if (sepIndex === -1) {
              invalid.push(line);
              return;
            }
            const base = line.slice(0, sepIndex).trim();
            const reading = line.slice(sepIndex + sepLen).trim();
            if (!base || !reading) {
              invalid.push(line);
              return;
            }
            const lowered = base.toLowerCase();
            if (lowered.startsWith("re:") || lowered.startsWith("regex:")) {
              const prefixLen = lowered.startsWith("re:") ? 3 : 6;
              const pattern = base.slice(prefixLen).trim();
              if (!pattern) {
                invalid.push(line);
                return;
              }
              entries.push({ pattern, reading, regex: true });
              return;
            }
            entries.push({ base, reading });
          });
        return { entries, invalid };
      }

      async function loadReadingOverrides(force = false) {
        if (!state.book || !readingOverrides) {
          return;
        }
        if (state.readingOverridesDirty && !force) {
          const discard = window.confirm("Discard unsaved reading overrides?");
          if (!discard) {
            return;
          }
        }
        editStatus.textContent = "Loading reading overrides...";
        try {
          const params = new URLSearchParams();
          params.set("book_id", state.book.id);
          const data = await fetchJson(`/api/reading-overrides?${params.toString()}`);
          const text = overridesToText(data.overrides || []);
          readingOverrides.value = text;
          state.readingOverridesOriginal = text;
          state.readingOverridesDirty = false;
          editStatus.textContent = "";
        } catch (err) {
          editStatus.textContent = err.message || "Failed to load reading overrides.";
        }
      }

      async function saveReadingOverrides() {
        if (!state.book || !readingOverrides) {
          return;
        }
        const { entries, invalid } = parseOverrideLines(readingOverrides.value || "");
        editStatus.textContent = "Saving reading overrides...";
        try {
          const data = await fetchJson("/api/reading-overrides", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              book_id: state.book.id,
              overrides: entries,
            }),
          });
          const text = overridesToText(data.overrides || entries);
          readingOverrides.value = text;
          state.readingOverridesOriginal = text;
          state.readingOverridesDirty = false;
          const ignored = invalid.length
            ? ` Ignored ${invalid.length} invalid line(s).`
            : "";
          editStatus.textContent = data.tts_cleared
            ? `Saved overrides. TTS cache cleared.${ignored}`
            : `Saved overrides. Existing audio kept; regenerate chunks to apply.${ignored}`;
          await selectBook(state.book.id, state.currentChapterId);
        } catch (err) {
          editStatus.textContent = err.message || "Failed to save reading overrides.";
        }
      }

      function rulesFromForm() {
        return {
          paragraph_breaks: rulesParagraphs.value || "double",
          drop_chapter_title_patterns: parseRuleLines(rulesDrop.value || ""),
          section_cutoff_patterns: parseRuleLines(rulesCutoff.value || ""),
          remove_patterns: parseRuleLines(rulesRemove.value || ""),
          replace_defaults: !!rulesReplace.checked,
        };
      }

      function applyRulesToForm(rules) {
        state.rulesLoading = true;
        rulesParagraphs.value = rules.paragraph_breaks || "double";
        rulesDrop.value = (rules.drop_chapter_title_patterns || []).join("\n");
        rulesCutoff.value = (rules.section_cutoff_patterns || []).join("\n");
        rulesRemove.value = (rules.remove_patterns || []).join("\n");
        rulesReplace.checked = !!rules.replace_defaults;
        state.rulesLoading = false;
      }

      function scheduleRulesSave() {
        if (state.rulesLoading) {
          return;
        }
        if (state.rulesSaveTimer) {
          clearTimeout(state.rulesSaveTimer);
        }
        state.rulesSaveTimer = setTimeout(() => {
          saveRules();
        }, 700);
      }

      async function saveRules() {
        if (!state.book) {
          return;
        }
        const payload = { ...rulesFromForm(), book_id: state.book.id };
        editStatus.textContent = "Saving rules...";
        try {
          await fetchJson("/api/sanitize/rules", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          editStatus.textContent = "Rules saved.";
          await loadPreview(state.previewChapterIndex);
        } catch (err) {
          editStatus.textContent = err.message || "Failed to save rules.";
        }
      }

      function renderEditChapterList(chapters, selectedIndex) {
        editChapterList.innerHTML = "";
        if (!chapters.length) {
          editChapterList.innerHTML = "<p class=\"empty-state\">No chapters.</p>";
          return;
        }
        chapters.forEach((entry) => {
          const button = document.createElement("button");
          button.type = "button";
          button.className = "edit-chapter-item";
          if (entry.index === selectedIndex) {
            button.classList.add("active");
          }
          const title = entry.title || "Chapter";
          button.textContent = `${entry.index}. ${title}`;
          button.addEventListener("click", () => {
            loadPreview(entry.index);
          });
          editChapterList.appendChild(button);
        });
      }

      function renderDroppedList(items) {
        editDroppedList.innerHTML = "";
        if (!items.length) {
          editDroppedList.innerHTML = "<p class=\"empty-state\">None.</p>";
          return;
        }
        items.forEach((entry) => {
          const row = document.createElement("div");
          row.className = "edit-dropped-item";
          const title = entry.title || "Chapter";
          row.innerHTML = `
            <span>${entry.index}. ${title}</span>
            <button class="btn small" type="button">Restore</button>
          `;
          const button = row.querySelector("button");
          button.addEventListener("click", () =>
            restoreChapter(entry.title, entry.index)
          );
          editDroppedList.appendChild(row);
        });
      }

      async function loadPreview(chapterIndex) {
        if (!state.book) {
          return;
        }
        if (
          state.cleanEditing &&
          chapterIndex !== undefined &&
          chapterIndex !== null &&
          chapterIndex !== state.cleanEditChapter
        ) {
          if (hasUnsavedCleanChanges()) {
            const discard = window.confirm(
              "Discard unsaved clean text edits?"
            );
            if (!discard) {
              return;
            }
          }
          setCleanEditMode(false);
        }
        const params = new URLSearchParams();
        params.set("book_id", state.book.id);
        if (chapterIndex) {
          params.set("chapter", chapterIndex);
        }
        try {
          const data = await fetchJson(`/api/sanitize/preview?${params.toString()}`);
          const selected = data.selected || {};
          state.previewChapterIndex = selected.index || null;
          state.previewSelectedTitle = selected.title || "";
          state.previewSelectedKind = selected.kind || "";
          if (selected.title) {
            const prefix = selected.index ? `${selected.index}. ` : "";
            editSelectedTitle.textContent = `${prefix}${selected.title}`;
          } else {
            editSelectedTitle.textContent = "Select a chapter";
          }
          dropChapterBtn.disabled =
            !selected.title || selected.kind === "title" || state.cleanEditing;
          editRaw.innerHTML = data.raw_text || "";
          const selectedIndex =
            typeof selected.index === "number"
              ? selected.index
              : state.previewChapterIndex;
          const preserveClean =
            state.cleanEditing && state.cleanEditChapter === selectedIndex;
          if (!preserveClean) {
            editClean.textContent = data.clean_text || "";
            editCleanInput.value = data.clean_text || "";
          }
          renderEditChapterList(data.chapters || [], selected.index);
          renderDroppedList(data.dropped || []);
          if (!state.cleanEditing) {
            applyRulesToForm(data.rules || {});
          }
          editStatus.textContent = "";
        } catch (err) {
          editStatus.textContent = err.message || "Failed to load preview.";
        }
      }

      function toggleEditPanel() {
        state.editOpen = !state.editOpen;
        editPanel.classList.toggle("open", state.editOpen);
        editToggle.textContent = state.editOpen ? "Close" : "Edit";
        if (state.editOpen) {
          loadPreview(state.previewChapterIndex);
          loadReadingOverrides();
          editPanel.scrollIntoView({ behavior: "smooth", block: "start" });
        } else if (state.cleanEditing) {
          setCleanEditMode(false);
        }
      }

      async function dropSelectedChapter() {
        if (!state.book || !state.previewSelectedTitle) {
          return;
        }
        try {
          const data = await fetchJson("/api/sanitize/drop", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              book_id: state.book.id,
              title: state.previewSelectedTitle,
              chapter_index: state.previewChapterIndex,
            }),
          });
          editStatus.textContent = data.dropped
            ? "Chapter dropped."
            : "Chapter already dropped.";
          await selectBook(state.book.id);
        } catch (err) {
          editStatus.textContent = err.message || "Failed to drop chapter.";
        }
      }

      async function restoreChapter(title, chapterIndex) {
        if (!state.book || !title) {
          return;
        }
        try {
          const data = await fetchJson("/api/sanitize/restore", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              book_id: state.book.id,
              title,
              chapter_index: chapterIndex,
            }),
          });
          editStatus.textContent = data.restored
            ? "Chapter restored."
            : "Chapter already restored.";
          await selectBook(state.book.id);
        } catch (err) {
          editStatus.textContent = err.message || "Failed to restore chapter.";
        }
      }

      async function runSanitize() {
        if (!state.book) {
          return;
        }
        editStatus.textContent = "Sanitizing...";
        try {
          const data = await fetchJson("/api/sanitize/run", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ book_id: state.book.id }),
          });
          const cleared = data.tts_cleared ? " TTS cache cleared." : "";
          editStatus.textContent = `Sanitized.${cleared}`;
          await selectBook(state.book.id);
          await loadPreview(state.previewChapterIndex);
        } catch (err) {
          editStatus.textContent = err.message || "Sanitize failed.";
        }
      }

      async function chunkExists(item) {
        const chunkNum = item.chunkIndex + 1;
        const url = `/api/chunk-status?book_id=${encodeURIComponent(
          state.book.id
        )}&chapter_id=${encodeURIComponent(
          item.chapterId
        )}&chunk=${chunkNum}`;
        const data = await fetchJson(url);
        return data.exists;
      }

      function chunkUrl(item) {
        const chunkNum = item.chunkIndex + 1;
        const base = `${state.audioBase}/${item.chapterId}/${pad6(chunkNum)}.wav`;
        const key = chunkCacheKey(item);
        const bust = state.chunkCacheBust[key];
        if (!bust) {
          return base;
        }
        return `${base}?v=${bust}`;
      }

      function resetAudioPlayers() {
        clearPendingBoundaryMeasurement();
        clearGapless();
        [audio, audioNext].forEach((element) => {
          element.ontimeupdate = null;
          element.pause();
          element.removeAttribute("src");
          element.load();
        });
        currentAudio = audio;
        nextAudio = audioNext;
        state.preloadedIndex = null;
        setPlayButton(false);
      }

      function setPlayButton(isPlaying) {
        playBtn.classList.toggle("is-playing", isPlaying);
        playBtn.setAttribute("aria-label", isPlaying ? "Pause" : "Play");
        playBtn.title = isPlaying ? "Pause" : "Play";
      }

      function setPlaybackRate(rate) {
        currentAudio.playbackRate = rate;
        nextAudio.playbackRate = rate;
      }

      function setSpeedRate(rate) {
        state.playbackRate = rate;
        speedValue.textContent = `${rate.toFixed(1)}x`;
        setPlaybackRate(rate);
      }

      function clearPreload() {
        state.preloadedIndex = null;
        nextAudio.pause();
        nextAudio.removeAttribute("src");
        nextAudio.load();
      }

      function pauseInactiveAudio() {
        const inactive = currentAudio === audio ? audioNext : audio;
        if (!inactive.paused) {
          inactive.pause();
        }
      }

      function guardUnexpectedPlay(target) {
        if (target !== currentAudio) {
          target.pause();
          return;
        }
        pauseInactiveAudio();
      }

      function usePreloadedAudio(index) {
        if (state.preloadedIndex !== index || !nextAudio.src) {
          return false;
        }
        currentAudio.pause();
        [currentAudio, nextAudio] = [nextAudio, currentAudio];
        clearPreload();
        return true;
      }

      function clearGapless() {
        state.gaplessArmedIndex = null;
        if (state.gaplessPollTimer) {
          clearInterval(state.gaplessPollTimer);
          state.gaplessPollTimer = null;
        }
        currentAudio.ontimeupdate = null;
      }

      function gaplessTailSeconds() {
        const padMs = Number(state.padMs) || 0;
        if (!padMs) {
          return 0;
        }
        return Math.min(0.085, padMs / 1000);
      }

      function armGapless(index) {
        clearGapless();
        const tailSec = gaplessTailSeconds();
        if (!tailSec) {
          return;
        }
        const tryGaplessSwitch = () => {
          if (state.gaplessArmedIndex !== index) {
            return;
          }
          if (currentAudio.paused || state.playTransitioning) {
            return;
          }
          const duration = currentAudio.duration;
          if (!duration || Number.isNaN(duration)) {
            return;
          }
          const remaining = duration - currentAudio.currentTime;
          if (remaining > tailSec) {
            return;
          }
          const nextIndex = index + 1;
          if (state.preloadedIndex !== nextIndex || !nextAudio.src) {
            return;
          }
          clearGapless();
          const boundaryDelayMs = Math.max(0, remaining * 1000);
          queueBoundaryMeasurement(
            index,
            nextIndex,
            performance.now() + boundaryDelayMs,
            "gapless",
            boundaryDelayMs
          );
          playIndex(nextIndex);
        };
        state.gaplessArmedIndex = index;
        currentAudio.ontimeupdate = tryGaplessSwitch;
        state.gaplessPollTimer = window.setInterval(tryGaplessSwitch, 25);
        tryGaplessSwitch();
      }

      async function preloadIndex(index) {
        if (!state.queue.length) {
          return;
        }
        if (index < 0 || index >= state.queue.length) {
          clearPreload();
          return;
        }
        if (state.preloadedIndex === index && nextAudio.src) {
          return;
        }
        const item = state.queue[index];
        let available = false;
        if (state.preloadedIndex === index && nextAudio.src) {
          available = true;
        } else {
          try {
            available = await chunkExists(item);
          } catch (err) {
            available = false;
          }
        }
        if (!available) {
          return;
        }
        nextAudio.src = chunkUrl(item);
        nextAudio.load();
        nextAudio.playbackRate = state.playbackRate || 1;
        state.preloadedIndex = index;
      }

      async function playIndex(index) {
        void primeLatencyAudioContext();
        if (!state.queue.length) {
          clearPendingBoundaryMeasurement();
          return;
        }
        if (state.pendingBoundary && state.pendingBoundary.toIndex !== index) {
          clearPendingBoundaryMeasurement();
        }
        if (index < 0 || index >= state.queue.length) {
          clearPendingBoundaryMeasurement();
          setStatus("End of book.");
          currentAudio.pause();
          clearGapless();
          void persistPlayback();
          markBookFinished();
          return;
        }
        state.playTransitioning = true;
        try {
          clearGapless();
          const item = state.queue[index];
          const chapterTotal = getChapterChunkTotal(item);
          state.currentQueueIndex = index;
          setLastPlayed(index);
          setActiveChunk(index, true);
          setStatus(
            `Waiting for chunk ${item.chunkIndex + 1} of ${chapterTotal}...`
          );
          updateMarks();

          const preloadedReady =
            state.preloadedIndex === index && Boolean(nextAudio.src);
          let available = preloadedReady;
          if (!available) {
            try {
              available = await chunkExists(item);
            } catch (err) {
              available = false;
            }
          }

          if (!available) {
            clearPendingBoundaryMeasurement();
            waitForChunk(index);
            currentAudio.pause();
            setPlayButton(false);
            setStatus("Chunk not ready. Press Play to retry.");
            return;
          }

          if (state.waitTimer) {
            clearTimeout(state.waitTimer);
          }
          state.waitingFor = null;
          setActiveChunk(index, false);
          const usedPreload = usePreloadedAudio(index);
          if (!usedPreload) {
            clearPreload();
            currentAudio.pause();
            currentAudio.src = chunkUrl(item);
            currentAudio.load();
          }
          setPlaybackRate(state.playbackRate || 1);
          const latencyBeforePlay = readAudioLatencySnapshot();
          const playCallAt = performance.now();
          try {
            await currentAudio.play();
            const playResolvedAt = performance.now();
            const latencyAfterPlay = readAudioLatencySnapshot();
            finalizeBoundaryMeasurement(index, {
              usedPreload,
              playCallAt,
              playResolvedAt,
              baseLatencyMs:
                latencyAfterPlay.baseLatencyMs ?? latencyBeforePlay.baseLatencyMs,
              outputLatencyMs:
                latencyAfterPlay.outputLatencyMs ??
                latencyBeforePlay.outputLatencyMs,
              audioContextState:
                latencyAfterPlay.contextState || latencyBeforePlay.contextState,
            });
            setStatus(
              `Playing ${item.chapterId} ${item.chunkIndex + 1} / ${chapterTotal}`
            );
            setPlayButton(true);
          } catch (err) {
            clearPendingBoundaryMeasurement();
            setStatus("Press Play to start audio.");
            setPlayButton(false);
          }
          armGapless(index);
          void preloadIndex(index + 1);
        } finally {
          state.playTransitioning = false;
        }
      }

      function waitForChunk(index) {
        state.waitingFor = index;
        if (state.waitTimer) {
          clearTimeout(state.waitTimer);
        }
        state.waitTimer = null;
      }

      function togglePlay() {
        if (!state.queue.length) {
          return;
        }
        if (currentAudio.paused) {
          void primeLatencyAudioContext();
          const lastIndex = getLastPlayed();
          const startIndex = lastIndex === null ? 0 : lastIndex;
          playIndex(startIndex);
        } else {
          currentAudio.pause();
          setPlayButton(false);
          setIdleStatus();
          clearGapless();
          clearPendingBoundaryMeasurement();
        }
      }

      function nextChunk() {
        playIndex(state.currentQueueIndex + 1);
      }

      function prevChunk() {
        playIndex(Math.max(0, state.currentQueueIndex - 1));
      }

      playBtn.addEventListener("click", togglePlay);
      prevBtn.addEventListener("click", prevChunk);
      nextBtn.addEventListener("click", nextChunk);
      uploadZone.addEventListener("click", () => {
        if (state.ingestRunning) {
          return;
        }
        uploadInput.click();
      });
      uploadZone.addEventListener("keydown", (event) => {
        if (event.key === "Enter" || event.key === " ") {
          event.preventDefault();
          if (!state.ingestRunning) {
            uploadInput.click();
          }
        }
      });
      uploadZone.addEventListener("dragover", (event) => {
        event.preventDefault();
        if (state.ingestRunning) {
          return;
        }
        uploadZone.classList.add("dragover");
      });
      uploadZone.addEventListener("dragleave", () => {
        uploadZone.classList.remove("dragover");
      });
      uploadZone.addEventListener("drop", (event) => {
        event.preventDefault();
        uploadZone.classList.remove("dragover");
        if (state.ingestRunning) {
          return;
        }
        const file = event.dataTransfer?.files?.[0];
        ingestFile(file);
      });
      uploadInput.addEventListener("change", () => {
        const file = uploadInput.files ? uploadInput.files[0] : null;
        ingestFile(file);
      });
      startTts.addEventListener("click", toggleSynth);
      sampleTts.addEventListener("click", toggleSample);
      mergeBtn.addEventListener("click", () => {
        startMerge();
      });
      downloadM4bBtn.addEventListener("click", downloadM4b);
      clearTtsBtn.addEventListener("click", clearTtsCache);
      bookMenuBtn.addEventListener("click", toggleBookMenu);
      editMetaBtn.addEventListener("click", () => {
        closeBookMenu();
        openMetaModal();
      });
      document.addEventListener("click", (event) => {
        const target = event.target;
        if (bookMenuPanel.classList.contains("open")) {
          if (target === bookMenuBtn || bookMenuPanel.contains(target)) {
            return;
          }
          closeBookMenu();
        }
        if (downloadMenuPanel && downloadMenuPanel.classList.contains("open")) {
          if (target === downloadM4bBtn || downloadMenuPanel.contains(target)) {
            return;
          }
          closeDownloadMenu();
        }
      });
      deleteBookBtn.addEventListener("click", deleteBook);
      deleteM4bBtn.addEventListener("click", deleteM4b);
      cloneClose.addEventListener("click", closeCloneModal);
      cloneCancel.addEventListener("click", closeCloneModal);
      clonePreviewBtn.addEventListener("click", previewCloneVoice);
      if (cloneDelete) {
        cloneDelete.addEventListener("click", deleteLocalVoice);
      }
      cloneSave.addEventListener("click", saveCloneVoice);
      cloneSource.addEventListener("input", () => {
        resetClonePreview();
        setCloneStatus("");
      });
      cloneStart.addEventListener("input", () => {
        resetClonePreview();
        setCloneStatus("");
      });
      cloneDuration.addEventListener("input", () => {
        resetClonePreview();
        setCloneStatus("");
      });
      cloneName.addEventListener("input", () => {
        state.cloneNameDirty = cloneName.value.trim().length > 0;
        setCloneStatus("");
      });
      if (cloneBuiltinToggle) {
        cloneBuiltinToggle.addEventListener("click", () => {
          setBuiltinVoicesVisible(!state.showBuiltinVoices);
        });
      }
      cloneModal.addEventListener("click", (event) => {
        if (event.target === cloneModal) {
          closeCloneModal();
        }
      });
      metaClose.addEventListener("click", closeMetaModal);
      metaCancel.addEventListener("click", closeMetaModal);
      metaSave.addEventListener("click", saveMetadata);
      metaModal.addEventListener("click", (event) => {
        if (event.target === metaModal) {
          closeMetaModal();
        }
      });
      document.addEventListener("keydown", (event) => {
        if (event.key !== "Escape") {
          return;
        }
        if (cloneModal && !cloneModal.hidden) {
          closeCloneModal();
          return;
        }
        if (metaModal && !metaModal.hidden) {
          closeMetaModal();
          return;
        }
      });
      editToggle.addEventListener("click", toggleEditPanel);
      sanitizeBtn.addEventListener("click", runSanitize);
      editReload.addEventListener("click", () => {
        loadPreview(state.previewChapterIndex);
        loadReadingOverrides();
      });
      dropChapterBtn.addEventListener("click", dropSelectedChapter);
      editCleanBtn.addEventListener("click", startCleanEdit);
      saveCleanBtn.addEventListener("click", saveCleanText);
      cancelCleanBtn.addEventListener("click", cancelCleanEdit);
      readingOverrides.addEventListener("input", () => {
        state.readingOverridesDirty =
          readingOverrides.value !== state.readingOverridesOriginal;
      });
      saveOverridesBtn.addEventListener("click", saveReadingOverrides);
      rulesDrop.addEventListener("input", scheduleRulesSave);
      rulesCutoff.addEventListener("input", scheduleRulesSave);
      rulesRemove.addEventListener("input", scheduleRulesSave);
      rulesParagraphs.addEventListener("change", scheduleRulesSave);
      rulesReplace.addEventListener("change", scheduleRulesSave);
      bookmarkBtn.addEventListener("click", () => {
        if (bookmarkPanel.classList.contains("open")) {
          closeBookmarkPanel();
        } else {
          openBookmarkPanel();
        }
      });
      if (regenChunkBtn) {
        regenChunkBtn.addEventListener("click", regenerateChunk);
      }
      bookmarkList.addEventListener("click", (event) => {
        const target = event.target;
        if (!target || !target.dataset || !target.dataset.action) {
          return;
        }
        const action = target.dataset.action;
        const index = parseInt(target.dataset.index, 10);
        if (Number.isNaN(index)) {
          return;
        }
        if (action === "play" || action === "play-furthest") {
          jumpToIndex(index, true);
          closeBookmarkPanel();
          return;
        }
        if (action === "remove") {
          removeBookmark(index);
          updateMarks();
          setStatus("Bookmark removed.");
        }
      });
      saveBookmarkBtn.addEventListener("click", () => {
        if (!state.queue.length) {
          return;
        }
        addBookmark(state.currentQueueIndex);
        updateMarks();
        setStatus("Bookmark saved.");
      });
      advancedToggle.addEventListener("click", () => {
        state.advancedMode = !state.advancedMode;
        updateAdvancedMode();
      });
      advancedSelectAll.addEventListener("change", () => {
        if (!state.book) {
          return;
        }
        if (advancedSelectAll.checked) {
          state.advancedSelection = new Set(
            state.chapters.map((chapter) => chapter.id).filter(Boolean)
          );
        } else {
          state.advancedSelection = new Set();
        }
        renderAdvancedList();
      });
      advancedApplyVoice.addEventListener("click", () => {
        const value = advancedBulkVoice.value;
        if (!value) {
          return;
        }
        state.advancedSelection.forEach((chapterId) => {
          if (value === "default") {
            delete state.voiceMap.chapters[chapterId];
          } else {
            state.voiceMap.chapters[chapterId] = value;
          }
        });
        scheduleVoiceMapSave();
        renderAdvancedList();
      });
      advancedClearVoice.addEventListener("click", () => {
        state.advancedSelection.forEach((chapterId) => {
          delete state.voiceMap.chapters[chapterId];
        });
        scheduleVoiceMapSave();
        renderAdvancedList();
      });
      ttsToggle.addEventListener("click", () => {
        ttsPanel.classList.toggle("collapsed");
        ttsToggle.textContent = ttsPanel.classList.contains("collapsed")
          ? "Expand"
          : "Collapse";
        localStorage.setItem(
          "ptts.ttsCollapsed",
          ttsPanel.classList.contains("collapsed") ? "1" : "0"
        );
      });
      if (themeToggle) {
        themeToggle.addEventListener("click", cycleTheme);
      }
      function handleEnded(event) {
        if (event.target !== currentAudio) {
          return;
        }
        if (state.playTransitioning) {
          return;
        }
        const fromIndex = state.currentQueueIndex;
        const nextIndex = fromIndex + 1;
        queueBoundaryMeasurement(fromIndex, nextIndex, performance.now(), "ended", 0);
        playIndex(nextIndex);
      }
      audio.addEventListener("ended", handleEnded);
      audioNext.addEventListener("ended", handleEnded);
      audio.addEventListener("play", () => guardUnexpectedPlay(audio));
      audioNext.addEventListener("play", () => guardUnexpectedPlay(audioNext));
      document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
          if (BOUNDARY_LOG_ENABLED) {
            void flushBoundaryLogBuffer(true);
          }
          return;
        }
        if (!document.hidden) {
          pauseInactiveAudio();
        }
      });
      window.addEventListener("pagehide", () => {
        if (BOUNDARY_LOG_ENABLED) {
          void flushBoundaryLogBuffer(true);
        }
      });

      speedBtn.addEventListener("click", () => {
        const steps = [0.8, 1.0, 1.2, 1.4, 1.6, 1.8, 2.0];
        const current = state.playbackRate || 1.0;
        const idx = steps.findIndex((val) => Math.abs(val - current) < 0.01);
        const next = idx === -1 ? 1.0 : steps[(idx + 1) % steps.length];
        setSpeedRate(next);
      });
      jumpShelf.addEventListener("click", scrollToBookSection);
      libraryTypeTabs.forEach((tab) => {
        tab.addEventListener("click", () => {
          const filter = tab.dataset.filter || "epub";
          if (normalizeBookFilter(filter) === state.bookFilter) {
            return;
          }
          setBookFilter(filter);
        });
      });
      libraryShelfTabs.forEach((tab) => {
        tab.addEventListener("click", () => {
          const shelf = tab.dataset.shelf || "books";
          if (normalizeShelf(shelf) === state.libraryShelf) {
            return;
          }
          setShelfFilter(shelf);
        });
      });

      chapterText.addEventListener("click", (event) => {
        const target = event.target;
        if (target && target.classList.contains("chunk")) {
          const index = parseInt(target.dataset.queueIndex, 10);
          if (!Number.isNaN(index)) {
            playIndex(index);
          }
        }
      });
      updateMergeButtonState();
      updateClearButtonState();
      loadSettings();
      loadVoices();
      readUrlState();
      loadBooks();

      let lastTouchEnd = 0;
      document.addEventListener(
        "touchend",
        (event) => {
          const now = Date.now();
          if (now - lastTouchEnd <= 300) {
            event.preventDefault();
          }
          lastTouchEnd = now;
        },
        { passive: false }
      );
    </script>
  </body>
</html>
